{
  "built_ins": {
    "clear": {
      "type": "built_in",
      "doc": "D.clear() -> None.  Remove all items from D."
    },
    "copy": {
      "type": "built_in",
      "doc": "D.copy() -> a shallow copy of D"
    },
    "fromkeys": {
      "type": "built_in",
      "doc": "Create a new dictionary with keys from iterable and values set to value."
    },
    "get": {
      "type": "built_in",
      "doc": "Return the value for key if key is in the dictionary, else default."
    },
    "items": {
      "type": "built_in",
      "doc": "D.items() -> a set-like object providing a view on D's items"
    },
    "keys": {
      "type": "built_in",
      "doc": "D.keys() -> a set-like object providing a view on D's keys"
    },
    "pop": {
      "type": "built_in",
      "doc": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value."
    },
    "popitem": {
      "type": "built_in",
      "doc": "Remove and return a (key, value) pair as a 2-tuple."
    },
    "setdefault": {
      "type": "built_in",
      "doc": "Insert key with a value of default if key is not in the dictionary."
    },
    "update": {
      "type": "built_in",
      "doc": "D.update([E, ]**F) -> None.  Update D from dict/iterable E and F."
    },
    "values": {
      "type": "built_in",
      "doc": "D.values() -> an object providing a view on D's values"
    }
  },
  "keywords": {
    "False": {
      "type": "keyword"
    },
    "None": {
      "type": "keyword"
    },
    "True": {
      "type": "keyword"
    },
    "and": {
      "type": "keyword"
    },
    "as": {
      "type": "keyword"
    },
    "assert": {
      "type": "keyword"
    },
    "async": {
      "type": "keyword"
    },
    "await": {
      "type": "keyword"
    },
    "break": {
      "type": "keyword"
    },
    "class": {
      "type": "keyword"
    },
    "continue": {
      "type": "keyword"
    },
    "def": {
      "type": "keyword"
    },
    "del": {
      "type": "keyword"
    },
    "elif": {
      "type": "keyword"
    },
    "else": {
      "type": "keyword"
    },
    "except": {
      "type": "keyword"
    },
    "finally": {
      "type": "keyword"
    },
    "for": {
      "type": "keyword"
    },
    "from": {
      "type": "keyword"
    },
    "global": {
      "type": "keyword"
    },
    "if": {
      "type": "keyword"
    },
    "import": {
      "type": "keyword"
    },
    "in": {
      "type": "keyword"
    },
    "is": {
      "type": "keyword"
    },
    "lambda": {
      "type": "keyword"
    },
    "nonlocal": {
      "type": "keyword"
    },
    "not": {
      "type": "keyword"
    },
    "or": {
      "type": "keyword"
    },
    "pass": {
      "type": "keyword"
    },
    "raise": {
      "type": "keyword"
    },
    "return": {
      "type": "keyword"
    },
    "try": {
      "type": "keyword"
    },
    "while": {
      "type": "keyword"
    },
    "with": {
      "type": "keyword"
    },
    "yield": {
      "type": "keyword"
    }
  },
  "libraries": {
    "sys": {
      "type": "module",
      "doc": "This module provides access to some objects used or maintained by the"
    },
    "builtins": {
      "type": "module",
      "doc": "Built-in functions, exceptions, and other objects."
    },
    "marshal": {
      "type": "module",
      "doc": "This module contains functions that can read and write Python values in"
    },
    "nt": {
      "type": "module",
      "doc": "This module provides access to operating system functionality that is"
    },
    "winreg": {
      "type": "module",
      "doc": "This module provides access to the Windows registry API."
    },
    "time": {
      "type": "module",
      "doc": "This module provides various functions to manipulate time values."
    },
    "zipimport": {
      "type": "module",
      "doc": "zipimport provides support for importing Python modules from Zip archives."
    },
    "zlib": {
      "type": "module",
      "doc": "The functions in this module allow compression and decompression using the"
    },
    "codecs": {
      "type": "module",
      "doc": " codecs -- Python Codec Registry, API and helpers."
    },
    "encodings.aliases": {
      "type": "module",
      "doc": " Encoding Aliases Support"
    },
    "encodings": {
      "type": "module",
      "doc": " Standard \"encodings\" Package"
    },
    "encodings.utf_8": {
      "type": "module",
      "doc": " Python 'utf-8' Codec"
    },
    "encodings.cp1252": {
      "type": "module",
      "doc": " Python Character Mapping Codec cp1252 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1252.TXT' with gencodec.py."
    },
    "encodings.latin_1": {
      "type": "module",
      "doc": " Python 'latin-1' Codec"
    },
    "abc": {
      "type": "module",
      "doc": "Abstract Base Classes (ABCs) according to PEP 3119."
    },
    "io": {
      "type": "module",
      "doc": "The io module provides the Python interfaces to stream handling. The"
    },
    "stat": {
      "type": "module",
      "doc": "Constants/functions for interpreting results of os.stat() and os.lstat()."
    },
    "genericpath": {
      "type": "module",
      "doc": ""
    },
    "ntpath": {
      "type": "module",
      "doc": "Common pathname manipulations, WindowsNT/95 version."
    },
    "os.path": {
      "type": "module",
      "doc": "Common pathname manipulations, WindowsNT/95 version."
    },
    "os": {
      "type": "module",
      "doc": "OS routines for NT or Posix depending on what system we're on."
    },
    "importlib._bootstrap": {
      "type": "module",
      "doc": "Core implementation of import."
    },
    "importlib._bootstrap_external": {
      "type": "module",
      "doc": "Core implementation of path-based import."
    },
    "types": {
      "type": "module",
      "doc": ""
    },
    "warnings": {
      "type": "module",
      "doc": "Python part of the warnings subsystem."
    },
    "importlib": {
      "type": "module",
      "doc": "A pure Python implementation of import."
    },
    "importlib.machinery": {
      "type": "module",
      "doc": "The machinery of importlib: finders, loaders, hooks, etc."
    },
    "importlib.abc": {
      "type": "module",
      "doc": "Abstract base classes related to import."
    },
    "operator": {
      "type": "module",
      "doc": "Operator interface."
    },
    "keyword": {
      "type": "module",
      "doc": "Keywords (from \"Grammar/Grammar\")"
    },
    "heapq": {
      "type": "module",
      "doc": "Heap queue algorithm (a.k.a. priority queue)."
    },
    "itertools": {
      "type": "module",
      "doc": "Functional tools for creating and using iterators."
    },
    "reprlib": {
      "type": "module",
      "doc": "Redo the builtin repr() (representation) but with limits on most sizes."
    },
    "collections": {
      "type": "module",
      "doc": "This module implements specialized container datatypes providing"
    },
    "functools": {
      "type": "module",
      "doc": "functools.py - Tools for working with functions and callable objects"
    },
    "contextlib": {
      "type": "module",
      "doc": "Utilities for with-statement contexts.  See PEP 343."
    }
  },
  "functions": {
    "excepthook": {
      "signature": "(type_: Type[BaseException], value: BaseException, traceback: traceback) -> None",
      "doc": "",
      "module": "sys"
    },
    "unraisablehook": {
      "signature": "(unraisable)",
      "doc": "",
      "module": "sys"
    },
    "EncodedFile": {
      "signature": "(file, data_encoding, file_encoding=None, errors='strict')",
      "doc": " Return a wrapped version of file which provides transparent",
      "module": "codecs"
    },
    "getdecoder": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getencoder": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getincrementaldecoder": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getincrementalencoder": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getreader": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getwriter": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "iterdecode": {
      "signature": "(iterator, encoding, errors='strict', **kwargs)",
      "doc": "",
      "module": "codecs"
    },
    "iterencode": {
      "signature": "(iterator, encoding, errors='strict', **kwargs)",
      "doc": "",
      "module": "codecs"
    },
    "make_encoding_map": {
      "signature": "(decoding_map)",
      "doc": " Creates an encoding map from a decoding map.",
      "module": "codecs"
    },
    "make_identity_dict": {
      "signature": "(rng)",
      "doc": " make_identity_dict(rng) -> dict",
      "module": "codecs"
    },
    "open": {
      "signature": "(filename, mode='r', encoding=None, errors='strict', buffering=-1)",
      "doc": " Open an encoded file using the given mode and return",
      "module": "codecs"
    },
    "normalize_encoding": {
      "signature": "(encoding)",
      "doc": " Normalize an encoding name.",
      "module": "encodings"
    },
    "search_function": {
      "signature": "(encoding)",
      "doc": "",
      "module": "encodings"
    },
    "decode": {
      "signature": "(input, errors='strict')",
      "doc": "",
      "module": "encodings.utf_8"
    },
    "getregentry": {
      "signature": "()",
      "doc": "",
      "module": "encodings.latin_1"
    },
    "abstractmethod": {
      "signature": "(funcobj)",
      "doc": "A decorator indicating abstract methods.",
      "module": "abc"
    },
    "commonprefix": {
      "signature": "(m)",
      "doc": "Given a list of pathnames, returns the longest common leading component",
      "module": "os.path"
    },
    "exists": {
      "signature": "(path)",
      "doc": "Test whether a path exists.  Returns False for broken symbolic links",
      "module": "os.path"
    },
    "getatime": {
      "signature": "(filename)",
      "doc": "Return the last access time of a file, reported by os.stat().",
      "module": "os.path"
    },
    "getctime": {
      "signature": "(filename)",
      "doc": "Return the metadata change time of a file, reported by os.stat().",
      "module": "os.path"
    },
    "getmtime": {
      "signature": "(filename)",
      "doc": "Return the last modification time of a file, reported by os.stat().",
      "module": "os.path"
    },
    "getsize": {
      "signature": "(filename)",
      "doc": "Return the size of a file, reported by os.stat().",
      "module": "os.path"
    },
    "isdir": {
      "signature": "(s)",
      "doc": "Return true if the pathname refers to an existing directory.",
      "module": "os.path"
    },
    "isfile": {
      "signature": "(path)",
      "doc": "Test whether a path is a regular file",
      "module": "os.path"
    },
    "samefile": {
      "signature": "(f1, f2)",
      "doc": "Test whether two pathnames reference the same actual file or directory",
      "module": "os.path"
    },
    "sameopenfile": {
      "signature": "(fp1, fp2)",
      "doc": "Test whether two open file objects reference the same file",
      "module": "os.path"
    },
    "samestat": {
      "signature": "(s1, s2)",
      "doc": "Test whether two stat buffers reference the same file",
      "module": "os.path"
    },
    "abspath": {
      "signature": "(path)",
      "doc": "Return the absolute version of a path.",
      "module": "os.path"
    },
    "basename": {
      "signature": "(p)",
      "doc": "Returns the final component of a pathname",
      "module": "os.path"
    },
    "commonpath": {
      "signature": "(paths)",
      "doc": "Given a sequence of path names, returns the longest common sub-path.",
      "module": "os.path"
    },
    "dirname": {
      "signature": "(p)",
      "doc": "Returns the directory component of a pathname",
      "module": "os.path"
    },
    "expanduser": {
      "signature": "(path)",
      "doc": "Expand ~ and ~user constructs.",
      "module": "os.path"
    },
    "expandvars": {
      "signature": "(path)",
      "doc": "Expand shell variables of the forms $var, ${var} and %var%.",
      "module": "os.path"
    },
    "isabs": {
      "signature": "(s)",
      "doc": "Test whether a path is absolute",
      "module": "os.path"
    },
    "islink": {
      "signature": "(path)",
      "doc": "Test whether a path is a symbolic link.",
      "module": "os.path"
    },
    "ismount": {
      "signature": "(path)",
      "doc": "Test whether a path is a mount point (a drive root, the root of a",
      "module": "os.path"
    },
    "join": {
      "signature": "(path, *paths)",
      "doc": "",
      "module": "os.path"
    },
    "lexists": {
      "signature": "(path)",
      "doc": "Test whether a path exists.  Returns True for broken symbolic links",
      "module": "os.path"
    },
    "normcase": {
      "signature": "(s)",
      "doc": "Normalize case of pathname.",
      "module": "os.path"
    },
    "normpath": {
      "signature": "(path)",
      "doc": "Normalize path, eliminating double slashes, etc.",
      "module": "os.path"
    },
    "realpath": {
      "signature": "(path)",
      "doc": "",
      "module": "os.path"
    },
    "relpath": {
      "signature": "(path, start=None)",
      "doc": "Return a relative version of a path",
      "module": "os.path"
    },
    "split": {
      "signature": "(p)",
      "doc": "Split a pathname.",
      "module": "os.path"
    },
    "splitdrive": {
      "signature": "(p)",
      "doc": "Split a pathname into drive/UNC sharepoint and relative path specifiers.",
      "module": "os.path"
    },
    "splitext": {
      "signature": "(p)",
      "doc": "Split the extension from a pathname.",
      "module": "os.path"
    },
    "add_dll_directory": {
      "signature": "(path)",
      "doc": "Add a path to the DLL search path.",
      "module": "os"
    },
    "execl": {
      "signature": "(file, *args)",
      "doc": "execl(file, *args)",
      "module": "os"
    },
    "execle": {
      "signature": "(file, *args)",
      "doc": "execle(file, *args, env)",
      "module": "os"
    },
    "execlp": {
      "signature": "(file, *args)",
      "doc": "execlp(file, *args)",
      "module": "os"
    },
    "execlpe": {
      "signature": "(file, *args)",
      "doc": "execlpe(file, *args, env)",
      "module": "os"
    },
    "execvp": {
      "signature": "(file, args)",
      "doc": "execvp(file, args)",
      "module": "os"
    },
    "execvpe": {
      "signature": "(file, args, env)",
      "doc": "execvpe(file, args, env)",
      "module": "os"
    },
    "fdopen": {
      "signature": "(fd, *args, **kwargs)",
      "doc": "",
      "module": "os"
    },
    "fsdecode": {
      "signature": "(filename)",
      "doc": "Decode filename (an os.PathLike, bytes, or str) from the filesystem",
      "module": "os"
    },
    "fsencode": {
      "signature": "(filename)",
      "doc": "Encode filename (an os.PathLike, bytes, or str) to the filesystem",
      "module": "os"
    },
    "get_exec_path": {
      "signature": "(env=None)",
      "doc": "Returns the sequence of directories that will be searched for the",
      "module": "os"
    },
    "getenv": {
      "signature": "(key, default=None)",
      "doc": "Get an environment variable, return None if it doesn't exist.",
      "module": "os"
    },
    "makedirs": {
      "signature": "(name, mode=511, exist_ok=False)",
      "doc": "makedirs(name [, mode=0o777][, exist_ok=False])",
      "module": "os"
    },
    "popen": {
      "signature": "(cmd, mode='r', buffering=-1)",
      "doc": "",
      "module": "os"
    },
    "removedirs": {
      "signature": "(name)",
      "doc": "removedirs(name)",
      "module": "os"
    },
    "renames": {
      "signature": "(old, new)",
      "doc": "renames(old, new)",
      "module": "os"
    },
    "spawnl": {
      "signature": "(mode, file, *args)",
      "doc": "spawnl(mode, file, *args) -> integer",
      "module": "os"
    },
    "spawnle": {
      "signature": "(mode, file, *args)",
      "doc": "spawnle(mode, file, *args, env) -> integer",
      "module": "os"
    },
    "walk": {
      "signature": "(top, topdown=True, onerror=None, followlinks=False)",
      "doc": "Directory tree generator.",
      "module": "os"
    },
    "module_from_spec": {
      "signature": "(spec)",
      "doc": "Create a module based on the provided spec.",
      "module": "importlib._bootstrap"
    },
    "spec_from_loader": {
      "signature": "(name, loader, *, origin=None, is_package=None)",
      "doc": "Return a module spec based on various loader methods.",
      "module": "importlib._bootstrap"
    },
    "cache_from_source": {
      "signature": "(path, debug_override=None, *, optimization=None)",
      "doc": "Given the path to a .py file, return the path to its .pyc file.",
      "module": "importlib._bootstrap_external"
    },
    "decode_source": {
      "signature": "(source_bytes)",
      "doc": "Decode bytes representing source code and return the string.",
      "module": "importlib._bootstrap_external"
    },
    "source_from_cache": {
      "signature": "(path)",
      "doc": "Given the path to a .pyc. file, return the path to its .py file.",
      "module": "importlib._bootstrap_external"
    },
    "spec_from_file_location": {
      "signature": "(name, location=None, *, loader=None, submodule_search_locations=<object object at 0x019F6070>)",
      "doc": "Return a module spec based on a file location.",
      "module": "importlib._bootstrap_external"
    },
    "coroutine": {
      "signature": "(func)",
      "doc": "Convert regular generator function to a coroutine.",
      "module": "types"
    },
    "new_class": {
      "signature": "(name, bases=(), kwds=None, exec_body=None)",
      "doc": "Create a class object dynamically using the appropriate metaclass.",
      "module": "types"
    },
    "prepare_class": {
      "signature": "(name, bases=(), kwds=None)",
      "doc": "Call the __prepare__ method of the appropriate metaclass.",
      "module": "types"
    },
    "resolve_bases": {
      "signature": "(bases)",
      "doc": "Resolve MRO entries dynamically as specified by PEP 560.",
      "module": "types"
    },
    "filterwarnings": {
      "signature": "(action, message='', category=<class 'Warning'>, module='', lineno=0, append=False)",
      "doc": "Insert an entry into the list of warnings filters (at the front).",
      "module": "warnings"
    },
    "formatwarning": {
      "signature": "(message, category, filename, lineno, line=None)",
      "doc": "Function to format a warning the standard way.",
      "module": "warnings"
    },
    "resetwarnings": {
      "signature": "()",
      "doc": "Clear the list of warning filters, so that no filters are active.",
      "module": "warnings"
    },
    "showwarning": {
      "signature": "(message, category, filename, lineno, file=None, line=None)",
      "doc": "Hook to write a warning to a file; replace if you like.",
      "module": "warnings"
    },
    "simplefilter": {
      "signature": "(action, category=<class 'Warning'>, lineno=0, append=False)",
      "doc": "Insert a simple entry into the list of warnings filters (at the front).",
      "module": "warnings"
    },
    "find_loader": {
      "signature": "(name, path=None)",
      "doc": "Return the loader for the specified module.",
      "module": "importlib"
    },
    "import_module": {
      "signature": "(name, package=None)",
      "doc": "Import a module.",
      "module": "importlib"
    },
    "invalidate_caches": {
      "signature": "()",
      "doc": "Call the invalidate_caches() method on all meta path finders stored in",
      "module": "importlib"
    },
    "reload": {
      "signature": "(module)",
      "doc": "Reload the module and return it.",
      "module": "importlib"
    },
    "all_suffixes": {
      "signature": "()",
      "doc": "Returns a list of all recognized module suffixes for this process",
      "module": "importlib.machinery"
    },
    "merge": {
      "signature": "(*iterables, key=None, reverse=False)",
      "doc": "Merge multiple sorted inputs into a single sorted output.",
      "module": "heapq"
    },
    "nlargest": {
      "signature": "(n, iterable, key=None)",
      "doc": "Find the n largest elements in a dataset.",
      "module": "heapq"
    },
    "nsmallest": {
      "signature": "(n, iterable, key=None)",
      "doc": "Find the n smallest elements in a dataset.",
      "module": "heapq"
    },
    "recursive_repr": {
      "signature": "(fillvalue='...')",
      "doc": "Decorator to make a repr function return fillvalue for a recursive call",
      "module": "functools"
    },
    "namedtuple": {
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "doc": "Returns a new subclass of tuple with named fields.",
      "module": "functools"
    },
    "lru_cache": {
      "signature": "(maxsize=128, typed=False)",
      "doc": "Least-recently-used cache decorator.",
      "module": "functools"
    },
    "singledispatch": {
      "signature": "(func)",
      "doc": "Single-dispatch generic function decorator.",
      "module": "functools"
    },
    "total_ordering": {
      "signature": "(cls)",
      "doc": "Class decorator that fills in missing ordering methods",
      "module": "functools"
    },
    "update_wrapper": {
      "signature": "(wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))",
      "doc": "Update a wrapper function to look like the wrapped function",
      "module": "functools"
    },
    "wraps": {
      "signature": "(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))",
      "doc": "Decorator factory to apply update_wrapper() to a wrapper function",
      "module": "contextlib"
    },
    "asynccontextmanager": {
      "signature": "(func)",
      "doc": "@asynccontextmanager decorator.",
      "module": "contextlib"
    },
    "contextmanager": {
      "signature": "(func)",
      "doc": "@contextmanager decorator.",
      "module": "contextlib"
    }
  },
  "classes": {
    "ArithmeticError": {
      "methods": {},
      "doc": "Base class for arithmetic errors.",
      "module": "builtins"
    },
    "AssertionError": {
      "methods": {},
      "doc": "Assertion failed.",
      "module": "builtins"
    },
    "AttributeError": {
      "methods": {},
      "doc": "Attribute not found.",
      "module": "builtins"
    },
    "BaseException": {
      "methods": {},
      "doc": "Common base class for all exceptions",
      "module": "builtins"
    },
    "BlockingIOError": {
      "methods": {},
      "doc": "I/O operation would block.",
      "module": "io"
    },
    "BrokenPipeError": {
      "methods": {},
      "doc": "Broken pipe.",
      "module": "builtins"
    },
    "BufferError": {
      "methods": {},
      "doc": "Buffer error.",
      "module": "builtins"
    },
    "BytesWarning": {
      "methods": {},
      "doc": "Base class for warnings about bytes and buffer related problems, mostly",
      "module": "builtins"
    },
    "ChildProcessError": {
      "methods": {},
      "doc": "Child process error.",
      "module": "builtins"
    },
    "ConnectionAbortedError": {
      "methods": {},
      "doc": "Connection aborted.",
      "module": "builtins"
    },
    "ConnectionError": {
      "methods": {},
      "doc": "Connection error.",
      "module": "builtins"
    },
    "ConnectionRefusedError": {
      "methods": {},
      "doc": "Connection refused.",
      "module": "builtins"
    },
    "ConnectionResetError": {
      "methods": {},
      "doc": "Connection reset.",
      "module": "builtins"
    },
    "DeprecationWarning": {
      "methods": {},
      "doc": "Base class for warnings about deprecated features.",
      "module": "builtins"
    },
    "EOFError": {
      "methods": {},
      "doc": "Read beyond end of file.",
      "module": "builtins"
    },
    "EnvironmentError": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "builtins"
    },
    "Exception": {
      "methods": {},
      "doc": "Common base class for all non-exit exceptions.",
      "module": "builtins"
    },
    "FileExistsError": {
      "methods": {},
      "doc": "File already exists.",
      "module": "builtins"
    },
    "FileNotFoundError": {
      "methods": {},
      "doc": "File not found.",
      "module": "builtins"
    },
    "FloatingPointError": {
      "methods": {},
      "doc": "Floating point operation failed.",
      "module": "builtins"
    },
    "FutureWarning": {
      "methods": {},
      "doc": "Base class for warnings about constructs that will change semantically",
      "module": "builtins"
    },
    "GeneratorExit": {
      "methods": {},
      "doc": "Request that a generator exit.",
      "module": "builtins"
    },
    "IOError": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "builtins"
    },
    "ImportError": {
      "methods": {},
      "doc": "Import can't find module, or can't find name in module.",
      "module": "builtins"
    },
    "ImportWarning": {
      "methods": {},
      "doc": "Base class for warnings about probable mistakes in module imports",
      "module": "builtins"
    },
    "IndentationError": {
      "methods": {},
      "doc": "Improper indentation.",
      "module": "builtins"
    },
    "IndexError": {
      "methods": {},
      "doc": "Sequence index out of range.",
      "module": "builtins"
    },
    "InterruptedError": {
      "methods": {},
      "doc": "Interrupted by signal.",
      "module": "builtins"
    },
    "IsADirectoryError": {
      "methods": {},
      "doc": "Operation doesn't work on directories.",
      "module": "builtins"
    },
    "KeyError": {
      "methods": {},
      "doc": "Mapping key not found.",
      "module": "builtins"
    },
    "KeyboardInterrupt": {
      "methods": {},
      "doc": "Program interrupted by user.",
      "module": "builtins"
    },
    "LookupError": {
      "methods": {},
      "doc": "Base class for lookup errors.",
      "module": "builtins"
    },
    "MemoryError": {
      "methods": {},
      "doc": "Out of memory.",
      "module": "builtins"
    },
    "ModuleNotFoundError": {
      "methods": {},
      "doc": "Module not found.",
      "module": "builtins"
    },
    "NameError": {
      "methods": {},
      "doc": "Name not found globally.",
      "module": "builtins"
    },
    "NotADirectoryError": {
      "methods": {},
      "doc": "Operation only works on directories.",
      "module": "builtins"
    },
    "NotImplementedError": {
      "methods": {},
      "doc": "Method or function hasn't been implemented yet.",
      "module": "builtins"
    },
    "OSError": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "builtins"
    },
    "OverflowError": {
      "methods": {},
      "doc": "Result too large to be represented.",
      "module": "builtins"
    },
    "PendingDeprecationWarning": {
      "methods": {},
      "doc": "Base class for warnings about features which will be deprecated",
      "module": "builtins"
    },
    "PermissionError": {
      "methods": {},
      "doc": "Not enough permissions.",
      "module": "builtins"
    },
    "ProcessLookupError": {
      "methods": {},
      "doc": "Process not found.",
      "module": "builtins"
    },
    "RecursionError": {
      "methods": {},
      "doc": "Recursion limit exceeded.",
      "module": "builtins"
    },
    "ReferenceError": {
      "methods": {},
      "doc": "Weak ref proxy used after referent went away.",
      "module": "builtins"
    },
    "ResourceWarning": {
      "methods": {},
      "doc": "Base class for warnings about resource usage.",
      "module": "builtins"
    },
    "RuntimeError": {
      "methods": {},
      "doc": "Unspecified run-time error.",
      "module": "builtins"
    },
    "RuntimeWarning": {
      "methods": {},
      "doc": "Base class for warnings about dubious runtime behavior.",
      "module": "builtins"
    },
    "StopAsyncIteration": {
      "methods": {},
      "doc": "Signal the end from iterator.__anext__().",
      "module": "builtins"
    },
    "StopIteration": {
      "methods": {},
      "doc": "Signal the end from iterator.__next__().",
      "module": "builtins"
    },
    "SyntaxError": {
      "methods": {},
      "doc": "Invalid syntax.",
      "module": "builtins"
    },
    "SyntaxWarning": {
      "methods": {},
      "doc": "Base class for warnings about dubious syntax.",
      "module": "builtins"
    },
    "SystemError": {
      "methods": {},
      "doc": "Internal error in the Python interpreter.",
      "module": "builtins"
    },
    "SystemExit": {
      "methods": {},
      "doc": "Request to exit from the interpreter.",
      "module": "builtins"
    },
    "TabError": {
      "methods": {},
      "doc": "Improper mixture of spaces and tabs.",
      "module": "builtins"
    },
    "TimeoutError": {
      "methods": {},
      "doc": "Timeout expired.",
      "module": "builtins"
    },
    "TypeError": {
      "methods": {},
      "doc": "Inappropriate argument type.",
      "module": "builtins"
    },
    "UnboundLocalError": {
      "methods": {},
      "doc": "Local name referenced but not bound to a value.",
      "module": "builtins"
    },
    "UnicodeDecodeError": {
      "methods": {},
      "doc": "Unicode decoding error.",
      "module": "builtins"
    },
    "UnicodeEncodeError": {
      "methods": {},
      "doc": "Unicode encoding error.",
      "module": "builtins"
    },
    "UnicodeError": {
      "methods": {},
      "doc": "Unicode related error.",
      "module": "builtins"
    },
    "UnicodeTranslateError": {
      "methods": {},
      "doc": "Unicode translation error.",
      "module": "builtins"
    },
    "UnicodeWarning": {
      "methods": {},
      "doc": "Base class for warnings about Unicode related problems, mostly",
      "module": "builtins"
    },
    "UserWarning": {
      "methods": {},
      "doc": "Base class for warnings generated by user code.",
      "module": "builtins"
    },
    "ValueError": {
      "methods": {},
      "doc": "Inappropriate argument value (of correct type).",
      "module": "builtins"
    },
    "Warning": {
      "methods": {},
      "doc": "Base class for warning categories.",
      "module": "builtins"
    },
    "WindowsError": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "builtins"
    },
    "ZeroDivisionError": {
      "methods": {},
      "doc": "Second argument to a division or modulo operation was zero.",
      "module": "builtins"
    },
    "bool": {
      "methods": {},
      "doc": "bool(x) -> bool",
      "module": "builtins"
    },
    "bytearray": {
      "methods": {},
      "doc": "bytearray(iterable_of_ints) -> bytearray",
      "module": "builtins"
    },
    "bytes": {
      "methods": {},
      "doc": "bytes(iterable_of_ints) -> bytes",
      "module": "builtins"
    },
    "classmethod": {
      "methods": {},
      "doc": "classmethod(function) -> method",
      "module": "builtins"
    },
    "complex": {
      "methods": {},
      "doc": "Create a complex number from a real part and an optional imaginary part.",
      "module": "builtins"
    },
    "dict": {
      "methods": {},
      "doc": "dict() -> new empty dictionary",
      "module": "builtins"
    },
    "enumerate": {
      "methods": {},
      "doc": "Return an enumerate object.",
      "module": "builtins"
    },
    "filter": {
      "methods": {},
      "doc": "filter(function or None, iterable) --> filter object",
      "module": "builtins"
    },
    "float": {
      "methods": {},
      "doc": "Convert a string or number to a floating point number, if possible.",
      "module": "builtins"
    },
    "frozenset": {
      "methods": {},
      "doc": "frozenset() -> empty frozenset object",
      "module": "builtins"
    },
    "int": {
      "methods": {},
      "doc": "int([x]) -> integer",
      "module": "builtins"
    },
    "list": {
      "methods": {},
      "doc": "Built-in mutable sequence.",
      "module": "builtins"
    },
    "map": {
      "methods": {},
      "doc": "map(func, *iterables) --> map object",
      "module": "builtins"
    },
    "memoryview": {
      "methods": {},
      "doc": "Create a new memoryview object which references the given object.",
      "module": "builtins"
    },
    "object": {
      "methods": {},
      "doc": "The base class of the class hierarchy.",
      "module": "builtins"
    },
    "property": {
      "methods": {},
      "doc": "Property attribute.",
      "module": "builtins"
    },
    "range": {
      "methods": {},
      "doc": "range(stop) -> range object",
      "module": "builtins"
    },
    "reversed": {
      "methods": {},
      "doc": "Return a reverse iterator over the values of the given sequence.",
      "module": "builtins"
    },
    "set": {
      "methods": {},
      "doc": "set() -> new empty set object",
      "module": "builtins"
    },
    "slice": {
      "methods": {},
      "doc": "slice(stop)",
      "module": "builtins"
    },
    "staticmethod": {
      "methods": {},
      "doc": "staticmethod(function) -> method",
      "module": "builtins"
    },
    "str": {
      "methods": {},
      "doc": "str(object='') -> str",
      "module": "builtins"
    },
    "super": {
      "methods": {},
      "doc": "super() -> same as super(__class__, <first argument>)",
      "module": "builtins"
    },
    "tuple": {
      "methods": {},
      "doc": "Built-in immutable sequence.",
      "module": "builtins"
    },
    "type": {
      "methods": {},
      "doc": "type(object_or_name, bases, dict)",
      "module": "builtins"
    },
    "zip": {
      "methods": {},
      "doc": "zip(*iterables) --> zip object",
      "module": "builtins"
    },
    "DirEntry": {
      "methods": {},
      "doc": "",
      "module": "os"
    },
    "error": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "os"
    },
    "stat_result": {
      "methods": {},
      "doc": "stat_result: Result from stat, fstat, or lstat.",
      "module": "os"
    },
    "statvfs_result": {
      "methods": {},
      "doc": "statvfs_result: Result from statvfs or fstatvfs.",
      "module": "os"
    },
    "terminal_size": {
      "methods": {},
      "doc": "A tuple of (columns, lines) for holding terminal window size",
      "module": "os"
    },
    "times_result": {
      "methods": {},
      "doc": "times_result: Result from os.times().",
      "module": "os"
    },
    "uname_result": {
      "methods": {},
      "doc": "uname_result: Result from os.uname().",
      "module": "os"
    },
    "HKEYType": {
      "methods": {},
      "doc": "PyHKEY Object - A Python object, representing a win32 registry key.",
      "module": "winreg"
    },
    "struct_time": {
      "methods": {},
      "doc": "The time value as returned by gmtime(), localtime(), and strptime(), and",
      "module": "time"
    },
    "ZipImportError": {
      "methods": {},
      "doc": "",
      "module": "zipimport"
    },
    "zipimporter": {
      "methods": {
        "find_loader": {
          "signature": "(self, fullname, path=None)",
          "doc": "find_loader(fullname, path=None) -> self, str or None."
        },
        "find_module": {
          "signature": "(self, fullname, path=None)",
          "doc": "find_module(fullname, path=None) -> self or None."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "get_code(fullname) -> code object."
        },
        "get_data": {
          "signature": "(self, pathname)",
          "doc": "get_data(pathname) -> string with file data."
        },
        "get_filename": {
          "signature": "(self, fullname)",
          "doc": "get_filename(fullname) -> filename string."
        },
        "get_resource_reader": {
          "signature": "(self, fullname)",
          "doc": "Return the ResourceReader for a package in a zip file."
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "get_source(fullname) -> source string."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "is_package(fullname) -> bool."
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": "load_module(fullname) -> module."
        }
      },
      "doc": "zipimporter(archivepath) -> zipimporter object",
      "module": "zipimport"
    },
    "BufferedIncrementalDecoder": {
      "methods": {
        "decode": {
          "signature": "(self, input, final=False)",
          "doc": ""
        },
        "getstate": {
          "signature": "(self)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "setstate": {
          "signature": "(self, state)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "codecs"
    },
    "BufferedIncrementalEncoder": {
      "methods": {
        "encode": {
          "signature": "(self, input, final=False)",
          "doc": ""
        },
        "getstate": {
          "signature": "(self)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "setstate": {
          "signature": "(self, state)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "codecs"
    },
    "Codec": {
      "methods": {},
      "doc": "",
      "module": "encodings.latin_1"
    },
    "CodecInfo": {
      "methods": {},
      "doc": "Codec details when looking up the codec registry",
      "module": "codecs"
    },
    "IncrementalDecoder": {
      "methods": {
        "decode": {
          "signature": "(self, input, final=False)",
          "doc": ""
        },
        "getstate": {
          "signature": "(self)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "setstate": {
          "signature": "(self, state)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "encodings.latin_1"
    },
    "IncrementalEncoder": {
      "methods": {
        "encode": {
          "signature": "(self, input, final=False)",
          "doc": ""
        },
        "getstate": {
          "signature": "(self)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "setstate": {
          "signature": "(self, state)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "encodings.latin_1"
    },
    "StreamReader": {
      "methods": {
        "read": {
          "signature": "(self, size=-1, chars=-1, firstline=False)",
          "doc": " Decodes data from the stream self.stream and returns the"
        },
        "readline": {
          "signature": "(self, size=None, keepends=True)",
          "doc": " Read one line from the input stream and return the"
        },
        "readlines": {
          "signature": "(self, sizehint=None, keepends=True)",
          "doc": " Read all lines available on the input stream"
        },
        "reset": {
          "signature": "(self)",
          "doc": " Resets the codec buffers used for keeping state."
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": " Set the input stream's current position."
        }
      },
      "doc": "",
      "module": "encodings.latin_1"
    },
    "StreamReaderWriter": {
      "methods": {
        "read": {
          "signature": "(self, size=-1)",
          "doc": ""
        },
        "readline": {
          "signature": "(self, size=None)",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, sizehint=None)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": ""
        },
        "write": {
          "signature": "(self, data)",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, list)",
          "doc": ""
        }
      },
      "doc": " StreamReaderWriter instances allow wrapping streams which",
      "module": "codecs"
    },
    "StreamRecoder": {
      "methods": {
        "read": {
          "signature": "(self, size=-1)",
          "doc": ""
        },
        "readline": {
          "signature": "(self, size=None)",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, sizehint=None)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": ""
        },
        "write": {
          "signature": "(self, data)",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, list)",
          "doc": ""
        }
      },
      "doc": " StreamRecoder instances translate data from one encoding to another.",
      "module": "codecs"
    },
    "StreamWriter": {
      "methods": {
        "reset": {
          "signature": "(self)",
          "doc": " Flushes and resets the codec buffers used for keeping state."
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": ""
        },
        "write": {
          "signature": "(self, object)",
          "doc": " Writes the object's contents encoded to self.stream."
        },
        "writelines": {
          "signature": "(self, list)",
          "doc": " Writes the concatenated list of strings to the stream"
        }
      },
      "doc": "",
      "module": "encodings.latin_1"
    },
    "CodecRegistryError": {
      "methods": {},
      "doc": "",
      "module": "encodings"
    },
    "StreamConverter": {
      "methods": {
        "read": {
          "signature": "(self, size=-1, chars=-1, firstline=False)",
          "doc": " Decodes data from the stream self.stream and returns the"
        },
        "readline": {
          "signature": "(self, size=None, keepends=True)",
          "doc": " Read one line from the input stream and return the"
        },
        "readlines": {
          "signature": "(self, sizehint=None, keepends=True)",
          "doc": " Read all lines available on the input stream"
        },
        "reset": {
          "signature": "(self)",
          "doc": " Flushes and resets the codec buffers used for keeping state."
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": ""
        },
        "write": {
          "signature": "(self, object)",
          "doc": " Writes the object's contents encoded to self.stream."
        },
        "writelines": {
          "signature": "(self, list)",
          "doc": " Writes the concatenated list of strings to the stream"
        }
      },
      "doc": "",
      "module": "encodings.latin_1"
    },
    "ABC": {
      "methods": {},
      "doc": "Helper class that provides a standard way to create an ABC using",
      "module": "abc"
    },
    "ABCMeta": {
      "methods": {
        "register": {
          "signature": "(cls, subclass)",
          "doc": "Register a virtual subclass of an ABC."
        }
      },
      "doc": "Metaclass for defining Abstract Base Classes (ABCs).",
      "module": "abc"
    },
    "abstractclassmethod": {
      "methods": {},
      "doc": "A decorator indicating abstract classmethods.",
      "module": "abc"
    },
    "abstractproperty": {
      "methods": {},
      "doc": "A decorator indicating abstract properties.",
      "module": "abc"
    },
    "abstractstaticmethod": {
      "methods": {},
      "doc": "A decorator indicating abstract staticmethods.",
      "module": "abc"
    },
    "BufferedIOBase": {
      "methods": {},
      "doc": "Base class for buffered IO objects.",
      "module": "io"
    },
    "BufferedRWPair": {
      "methods": {},
      "doc": "A buffered reader and writer object together.",
      "module": "io"
    },
    "BufferedRandom": {
      "methods": {},
      "doc": "A buffered interface to random access streams.",
      "module": "io"
    },
    "BufferedReader": {
      "methods": {},
      "doc": "Create a new buffered reader using the given readable raw IO object.",
      "module": "io"
    },
    "BufferedWriter": {
      "methods": {},
      "doc": "A buffer for a writeable sequential RawIO object.",
      "module": "io"
    },
    "BytesIO": {
      "methods": {},
      "doc": "Buffered I/O implementation using an in-memory bytes buffer.",
      "module": "io"
    },
    "FileIO": {
      "methods": {},
      "doc": "Open a file.",
      "module": "io"
    },
    "IOBase": {
      "methods": {},
      "doc": "The abstract base class for all I/O classes, acting on streams of",
      "module": "io"
    },
    "IncrementalNewlineDecoder": {
      "methods": {},
      "doc": "Codec used when reading a file in universal newlines mode.",
      "module": "io"
    },
    "RawIOBase": {
      "methods": {},
      "doc": "Base class for raw binary I/O.",
      "module": "io"
    },
    "StringIO": {
      "methods": {},
      "doc": "Text I/O implementation using an in-memory buffer.",
      "module": "io"
    },
    "TextIOBase": {
      "methods": {},
      "doc": "Base class for text I/O.",
      "module": "io"
    },
    "TextIOWrapper": {
      "methods": {},
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "module": "io"
    },
    "UnsupportedOperation": {
      "methods": {},
      "doc": "",
      "module": "io"
    },
    "MutableMapping": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": "D.clear() -> None.  Remove all items from D."
        },
        "get": {
          "signature": "(self, key, default=None)",
          "doc": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None."
        },
        "items": {
          "signature": "(self)",
          "doc": "D.items() -> a set-like object providing a view on D's items"
        },
        "keys": {
          "signature": "(self)",
          "doc": "D.keys() -> a set-like object providing a view on D's keys"
        },
        "pop": {
          "signature": "(self, key, default=<object object at 0x019F60A8>)",
          "doc": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value."
        },
        "popitem": {
          "signature": "(self)",
          "doc": "D.popitem() -> (k, v), remove and return some (key, value) pair"
        },
        "setdefault": {
          "signature": "(self, key, default=None)",
          "doc": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D"
        },
        "update": {
          "signature": "(self, other=(), /, **kwds)",
          "doc": " D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F."
        },
        "values": {
          "signature": "(self)",
          "doc": "D.values() -> an object providing a view on D's values"
        }
      },
      "doc": "",
      "module": "os"
    },
    "PathLike": {
      "methods": {},
      "doc": "Abstract base class for implementing the file system path protocol.",
      "module": "os"
    },
    "BuiltinImporter": {
      "methods": {
        "module_repr": {
          "signature": "(module)",
          "doc": "Return repr for the module."
        }
      },
      "doc": "Meta path import for built-in modules.",
      "module": "importlib.machinery"
    },
    "FrozenImporter": {
      "methods": {
        "exec_module": {
          "signature": "(module)",
          "doc": ""
        },
        "module_repr": {
          "signature": "(m)",
          "doc": "Return repr for the module."
        }
      },
      "doc": "Meta path import for frozen modules.",
      "module": "importlib.machinery"
    },
    "ModuleSpec": {
      "methods": {},
      "doc": "The specification for a module, used for loading.",
      "module": "importlib.machinery"
    },
    "ExtensionFileLoader": {
      "methods": {
        "contents": {
          "signature": "(self)",
          "doc": ""
        },
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Create an unitialized extension module"
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Initialize an extension module"
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "Return None as an extension module cannot create a code object."
        },
        "get_data": {
          "signature": "(self, path)",
          "doc": "Return the data from path as raw bytes."
        },
        "get_filename": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Return the path to the source file as found by the finder."
        },
        "get_resource_reader": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Return None as extension modules have no source code."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Return True if the extension module is a package."
        },
        "is_resource": {
          "signature": "(self, name)",
          "doc": ""
        },
        "load_module": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Load a module from a file."
        },
        "open_resource": {
          "signature": "(self, resource)",
          "doc": ""
        },
        "resource_path": {
          "signature": "(self, resource)",
          "doc": ""
        }
      },
      "doc": "Loader for extension modules.",
      "module": "importlib.machinery"
    },
    "FileFinder": {
      "methods": {
        "find_loader": {
          "signature": "(self, fullname)",
          "doc": "Try to find a loader for the specified module, or the namespace"
        },
        "find_module": {
          "signature": "(self, fullname)",
          "doc": "Try to find a loader for the specified module by delegating to"
        },
        "find_spec": {
          "signature": "(self, fullname, target=None)",
          "doc": "Try to find a spec for the specified module."
        },
        "invalidate_caches": {
          "signature": "(self)",
          "doc": "Invalidate the directory mtime."
        }
      },
      "doc": "File-based finder.",
      "module": "importlib.machinery"
    },
    "FileLoader": {
      "methods": {
        "contents": {
          "signature": "(self)",
          "doc": ""
        },
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Return a module to initialize and into which to load."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "Method to return the code object for fullname."
        },
        "get_data": {
          "signature": "(self, path)",
          "doc": "Return the data from path as raw bytes."
        },
        "get_filename": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Return the path to the source file as found by the finder."
        },
        "get_resource_reader": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Abstract method which should return the source code for the"
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Optional method which when implemented should return whether the"
        },
        "is_resource": {
          "signature": "(self, name)",
          "doc": ""
        },
        "load_module": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Load a module from a file."
        },
        "module_repr": {
          "signature": "(self, module)",
          "doc": "Return a module's repr."
        },
        "open_resource": {
          "signature": "(self, resource)",
          "doc": ""
        },
        "resource_path": {
          "signature": "(self, resource)",
          "doc": ""
        },
        "source_to_code": {
          "signature": "(data, path='<string>')",
          "doc": "Compile 'data' into a code object."
        }
      },
      "doc": "Abstract base class partially implementing the ResourceLoader and",
      "module": "importlib.abc"
    },
    "PathFinder": {
      "methods": {},
      "doc": "Meta path finder for sys.path and package __path__ attributes.",
      "module": "importlib.machinery"
    },
    "SourceFileLoader": {
      "methods": {
        "contents": {
          "signature": "(self)",
          "doc": ""
        },
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Use default semantics for module creation."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_code."
        },
        "get_data": {
          "signature": "(self, path)",
          "doc": "Return the data from path as raw bytes."
        },
        "get_filename": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Return the path to the source file as found by the finder."
        },
        "get_resource_reader": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_source."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.is_package by checking if"
        },
        "is_resource": {
          "signature": "(self, name)",
          "doc": ""
        },
        "load_module": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Load a module from a file."
        },
        "open_resource": {
          "signature": "(self, resource)",
          "doc": ""
        },
        "path_mtime": {
          "signature": "(self, path)",
          "doc": "Optional method that returns the modification time (an int) for the"
        },
        "path_stats": {
          "signature": "(self, path)",
          "doc": "Return the metadata for the path."
        },
        "resource_path": {
          "signature": "(self, resource)",
          "doc": ""
        },
        "set_data": {
          "signature": "(self, path, data, *, _mode=438)",
          "doc": "Write bytes data to a file."
        },
        "source_to_code": {
          "signature": "(self, data, path, *, _optimize=-1)",
          "doc": "Return the code object compiled from source."
        }
      },
      "doc": "Concrete implementation of SourceLoader using the file system.",
      "module": "importlib.machinery"
    },
    "SourceLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Use default semantics for module creation."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_code."
        },
        "get_data": {
          "signature": "(self, path)",
          "doc": "Abstract method which when implemented should return the bytes for"
        },
        "get_filename": {
          "signature": "(self, fullname)",
          "doc": "Abstract method which should return the value that __file__ is to be"
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_source."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.is_package by checking if"
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": "This module is deprecated."
        },
        "module_repr": {
          "signature": "(self, module)",
          "doc": "Return a module's repr."
        },
        "path_mtime": {
          "signature": "(self, path)",
          "doc": "Return the (int) modification time for the path (str)."
        },
        "path_stats": {
          "signature": "(self, path)",
          "doc": "Return a metadata dict for the source pointed to by the path (str)."
        },
        "set_data": {
          "signature": "(self, path, data)",
          "doc": "Write the bytes to the path (if possible)."
        },
        "source_to_code": {
          "signature": "(self, data, path, *, _optimize=-1)",
          "doc": "Return the code object compiled from source."
        }
      },
      "doc": "Abstract base class for loading source code (and optionally any",
      "module": "importlib.abc"
    },
    "SourcelessFileLoader": {
      "methods": {
        "contents": {
          "signature": "(self)",
          "doc": ""
        },
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Use default semantics for module creation."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": ""
        },
        "get_data": {
          "signature": "(self, path)",
          "doc": "Return the data from path as raw bytes."
        },
        "get_filename": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Return the path to the source file as found by the finder."
        },
        "get_resource_reader": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Return None as there is no source code."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.is_package by checking if"
        },
        "is_resource": {
          "signature": "(self, name)",
          "doc": ""
        },
        "load_module": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Load a module from a file."
        },
        "open_resource": {
          "signature": "(self, resource)",
          "doc": ""
        },
        "resource_path": {
          "signature": "(self, resource)",
          "doc": ""
        }
      },
      "doc": "Loader which handles sourceless file imports.",
      "module": "importlib.machinery"
    },
    "WindowsRegistryFinder": {
      "methods": {},
      "doc": "Meta path finder for modules declared in the Windows registry.",
      "module": "importlib.machinery"
    },
    "AsyncGeneratorType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "BuiltinFunctionType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'builtin_function_or_method' objects>",
      "module": "types"
    },
    "BuiltinMethodType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'builtin_function_or_method' objects>",
      "module": "types"
    },
    "CellType": {
      "methods": {},
      "doc": "Create a new cell object.",
      "module": "types"
    },
    "ClassMethodDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'classmethod_descriptor' objects>",
      "module": "types"
    },
    "CodeType": {
      "methods": {},
      "doc": "code(argcount, posonlyargcount, kwonlyargcount, nlocals, stacksize,",
      "module": "types"
    },
    "CoroutineType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "DynamicClassAttribute": {
      "methods": {
        "deleter": {
          "signature": "(self, fdel)",
          "doc": ""
        },
        "getter": {
          "signature": "(self, fget)",
          "doc": ""
        },
        "setter": {
          "signature": "(self, fset)",
          "doc": ""
        }
      },
      "doc": "Route attribute access on a class to __getattr__.",
      "module": "types"
    },
    "FrameType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "FunctionType": {
      "methods": {},
      "doc": "Create a function object.",
      "module": "types"
    },
    "GeneratorType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "GetSetDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'getset_descriptor' objects>",
      "module": "types"
    },
    "LambdaType": {
      "methods": {},
      "doc": "Create a function object.",
      "module": "types"
    },
    "MappingProxyType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "MemberDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'member_descriptor' objects>",
      "module": "types"
    },
    "MethodDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'method_descriptor' objects>",
      "module": "types"
    },
    "MethodType": {
      "methods": {},
      "doc": "method(function, instance)",
      "module": "contextlib"
    },
    "MethodWrapperType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'method-wrapper' objects>",
      "module": "types"
    },
    "ModuleType": {
      "methods": {},
      "doc": "Create a module object.",
      "module": "types"
    },
    "SimpleNamespace": {
      "methods": {},
      "doc": "A simple attribute-based namespace.",
      "module": "types"
    },
    "TracebackType": {
      "methods": {},
      "doc": "TracebackType(tb_next, tb_frame, tb_lasti, tb_lineno)",
      "module": "types"
    },
    "WrapperDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'wrapper_descriptor' objects>",
      "module": "types"
    },
    "WarningMessage": {
      "methods": {},
      "doc": "",
      "module": "warnings"
    },
    "catch_warnings": {
      "methods": {},
      "doc": "A context manager that copies and restores the warnings filter upon",
      "module": "warnings"
    },
    "ExecutionLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Return a module to initialize and into which to load."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "Method to return the code object for fullname."
        },
        "get_filename": {
          "signature": "(self, fullname)",
          "doc": "Abstract method which should return the value that __file__ is to be"
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Abstract method which should return the source code for the"
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Optional method which when implemented should return whether the"
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": "This module is deprecated."
        },
        "module_repr": {
          "signature": "(self, module)",
          "doc": "Return a module's repr."
        },
        "source_to_code": {
          "signature": "(data, path='<string>')",
          "doc": "Compile 'data' into a code object."
        }
      },
      "doc": "Abstract base class for loaders that wish to support the execution of",
      "module": "importlib.abc"
    },
    "Finder": {
      "methods": {
        "find_module": {
          "signature": "(self, fullname, path=None)",
          "doc": "An abstract method that should find a module."
        }
      },
      "doc": "Legacy abstract base class for import finders.",
      "module": "importlib.abc"
    },
    "InspectLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Return a module to initialize and into which to load."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "Method which returns the code object for the module."
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Abstract method which should return the source code for the"
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Optional method which when implemented should return whether the"
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": "This module is deprecated."
        },
        "module_repr": {
          "signature": "(self, module)",
          "doc": "Return a module's repr."
        },
        "source_to_code": {
          "signature": "(data, path='<string>')",
          "doc": "Compile 'data' into a code object."
        }
      },
      "doc": "Abstract base class for loaders which support inspection about the",
      "module": "importlib.abc"
    },
    "Loader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Return a module to initialize and into which to load."
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": "Return the loaded module."
        },
        "module_repr": {
          "signature": "(self, module)",
          "doc": "Return a module's repr."
        }
      },
      "doc": "Abstract base class for import loaders.",
      "module": "importlib.abc"
    },
    "MetaPathFinder": {
      "methods": {
        "find_module": {
          "signature": "(self, fullname, path)",
          "doc": "Return a loader for the module."
        },
        "invalidate_caches": {
          "signature": "(self)",
          "doc": "An optional method for clearing the finder's cache, if any."
        }
      },
      "doc": "Abstract base class for import finders on sys.meta_path.",
      "module": "importlib.abc"
    },
    "PathEntryFinder": {
      "methods": {
        "find_loader": {
          "signature": "(self, fullname)",
          "doc": "Return (loader, namespace portion) for the path entry."
        },
        "find_module": {
          "signature": "(self, fullname)",
          "doc": "Try to find a loader for the specified module by delegating to"
        },
        "invalidate_caches": {
          "signature": "(self)",
          "doc": "An optional method for clearing the finder's cache, if any."
        }
      },
      "doc": "Abstract base class for path entry finders used by PathFinder.",
      "module": "importlib.abc"
    },
    "ResourceLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Return a module to initialize and into which to load."
        },
        "get_data": {
          "signature": "(self, path)",
          "doc": "Abstract method which when implemented should return the bytes for"
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": "Return the loaded module."
        },
        "module_repr": {
          "signature": "(self, module)",
          "doc": "Return a module's repr."
        }
      },
      "doc": "Abstract base class for loaders which can return data from their",
      "module": "importlib.abc"
    },
    "ResourceReader": {
      "methods": {
        "contents": {
          "signature": "(self)",
          "doc": "Return an iterable of strings over the contents of the package."
        },
        "is_resource": {
          "signature": "(self, name)",
          "doc": "Return True if the named 'name' is consider a resource."
        },
        "open_resource": {
          "signature": "(self, resource)",
          "doc": "Return an opened, file-like object for binary reading."
        },
        "resource_path": {
          "signature": "(self, resource)",
          "doc": "Return the file system path to the specified resource."
        }
      },
      "doc": "Abstract base class to provide resource-reading support.",
      "module": "importlib.abc"
    },
    "attrgetter": {
      "methods": {},
      "doc": "attrgetter(attr, ...) --> attrgetter object",
      "module": "operator"
    },
    "itemgetter": {
      "methods": {},
      "doc": "itemgetter(item, ...) --> itemgetter object",
      "module": "operator"
    },
    "methodcaller": {
      "methods": {},
      "doc": "methodcaller(name, ...) --> methodcaller object",
      "module": "operator"
    },
    "accumulate": {
      "methods": {},
      "doc": "Return series of accumulated sums (or other binary function results).",
      "module": "itertools"
    },
    "chain": {
      "methods": {},
      "doc": "chain(*iterables) --> chain object",
      "module": "itertools"
    },
    "combinations": {
      "methods": {},
      "doc": "Return successive r-length combinations of elements in the iterable.",
      "module": "itertools"
    },
    "combinations_with_replacement": {
      "methods": {},
      "doc": "Return successive r-length combinations of elements in the iterable allowing individual elements to have successive repeats.",
      "module": "itertools"
    },
    "compress": {
      "methods": {},
      "doc": "Return data elements corresponding to true selector elements.",
      "module": "itertools"
    },
    "count": {
      "methods": {},
      "doc": "Return a count object whose .__next__() method returns consecutive values.",
      "module": "itertools"
    },
    "cycle": {
      "methods": {},
      "doc": "Return elements from the iterable until it is exhausted. Then repeat the sequence indefinitely.",
      "module": "itertools"
    },
    "dropwhile": {
      "methods": {},
      "doc": "Drop items from the iterable while predicate(item) is true.",
      "module": "itertools"
    },
    "filterfalse": {
      "methods": {},
      "doc": "Return those items of iterable for which function(item) is false.",
      "module": "itertools"
    },
    "groupby": {
      "methods": {},
      "doc": "make an iterator that returns consecutive keys and groups from the iterable",
      "module": "itertools"
    },
    "islice": {
      "methods": {},
      "doc": "islice(iterable, stop) --> islice object",
      "module": "reprlib"
    },
    "permutations": {
      "methods": {},
      "doc": "Return successive r-length permutations of elements in the iterable.",
      "module": "itertools"
    },
    "product": {
      "methods": {},
      "doc": "product(*iterables, repeat=1) --> product object",
      "module": "itertools"
    },
    "repeat": {
      "methods": {},
      "doc": "repeat(object [,times]) -> create an iterator which returns the object",
      "module": "itertools"
    },
    "starmap": {
      "methods": {},
      "doc": "Return an iterator whose values are returned from the function evaluated with an argument tuple taken from the given sequence.",
      "module": "itertools"
    },
    "takewhile": {
      "methods": {},
      "doc": "Return successive entries from an iterable as long as the predicate evaluates to true for each entry.",
      "module": "itertools"
    },
    "zip_longest": {
      "methods": {},
      "doc": "zip_longest(iter1 [,iter2 [...]], [fillvalue=None]) --> zip_longest object",
      "module": "itertools"
    },
    "Repr": {
      "methods": {
        "repr": {
          "signature": "(self, x)",
          "doc": ""
        },
        "repr1": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_array": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_deque": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_dict": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_frozenset": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_instance": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_int": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_list": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_set": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_str": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_tuple": {
          "signature": "(self, x, level)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "reprlib"
    },
    "ChainMap": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": "Clear maps[0], leaving maps[1:] intact."
        },
        "copy": {
          "signature": "(self)",
          "doc": "New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]"
        },
        "get": {
          "signature": "(self, key, default=None)",
          "doc": ""
        },
        "items": {
          "signature": "(self)",
          "doc": "D.items() -> a set-like object providing a view on D's items"
        },
        "keys": {
          "signature": "(self)",
          "doc": "D.keys() -> a set-like object providing a view on D's keys"
        },
        "new_child": {
          "signature": "(self, m=None)",
          "doc": "New ChainMap with a new map followed by all previous maps."
        },
        "pop": {
          "signature": "(self, key, *args)",
          "doc": "Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0]."
        },
        "popitem": {
          "signature": "(self)",
          "doc": "Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty."
        },
        "setdefault": {
          "signature": "(self, key, default=None)",
          "doc": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D"
        },
        "update": {
          "signature": "(self, other=(), /, **kwds)",
          "doc": " D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F."
        },
        "values": {
          "signature": "(self)",
          "doc": "D.values() -> an object providing a view on D's values"
        }
      },
      "doc": " A ChainMap groups multiple dicts (or other mappings) together",
      "module": "collections"
    },
    "Counter": {
      "methods": {
        "copy": {
          "signature": "(self)",
          "doc": "Return a shallow copy."
        },
        "elements": {
          "signature": "(self)",
          "doc": "Iterator over elements repeating each as many times as its count."
        },
        "most_common": {
          "signature": "(self, n=None)",
          "doc": "List the n most common elements and their counts from the most"
        },
        "subtract": {
          "signature": "(self, iterable=None, /, **kwds)",
          "doc": "Like dict.update() but subtracts counts instead of replacing them."
        },
        "update": {
          "signature": "(self, iterable=None, /, **kwds)",
          "doc": "Like dict.update() but add counts instead of replacing them."
        }
      },
      "doc": "Dict subclass for counting hashable items.  Sometimes called a bag",
      "module": "collections"
    },
    "OrderedDict": {
      "methods": {},
      "doc": "Dictionary that remembers insertion order",
      "module": "collections"
    },
    "UserDict": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": "D.clear() -> None.  Remove all items from D."
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "get": {
          "signature": "(self, key, default=None)",
          "doc": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None."
        },
        "items": {
          "signature": "(self)",
          "doc": "D.items() -> a set-like object providing a view on D's items"
        },
        "keys": {
          "signature": "(self)",
          "doc": "D.keys() -> a set-like object providing a view on D's keys"
        },
        "pop": {
          "signature": "(self, key, default=<object object at 0x019F60A8>)",
          "doc": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value."
        },
        "popitem": {
          "signature": "(self)",
          "doc": "D.popitem() -> (k, v), remove and return some (key, value) pair"
        },
        "setdefault": {
          "signature": "(self, key, default=None)",
          "doc": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D"
        },
        "update": {
          "signature": "(self, other=(), /, **kwds)",
          "doc": " D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F."
        },
        "values": {
          "signature": "(self)",
          "doc": "D.values() -> an object providing a view on D's values"
        }
      },
      "doc": "",
      "module": "collections"
    },
    "UserList": {
      "methods": {
        "append": {
          "signature": "(self, item)",
          "doc": ""
        },
        "clear": {
          "signature": "(self)",
          "doc": ""
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "count": {
          "signature": "(self, item)",
          "doc": ""
        },
        "extend": {
          "signature": "(self, other)",
          "doc": ""
        },
        "index": {
          "signature": "(self, item, *args)",
          "doc": ""
        },
        "insert": {
          "signature": "(self, i, item)",
          "doc": ""
        },
        "pop": {
          "signature": "(self, i=-1)",
          "doc": ""
        },
        "remove": {
          "signature": "(self, item)",
          "doc": ""
        },
        "reverse": {
          "signature": "(self)",
          "doc": ""
        },
        "sort": {
          "signature": "(self, /, *args, **kwds)",
          "doc": ""
        }
      },
      "doc": "A more or less complete user-defined wrapper around list objects.",
      "module": "collections"
    },
    "UserString": {
      "methods": {
        "capitalize": {
          "signature": "(self)",
          "doc": ""
        },
        "casefold": {
          "signature": "(self)",
          "doc": ""
        },
        "center": {
          "signature": "(self, width, *args)",
          "doc": ""
        },
        "count": {
          "signature": "(self, sub, start=0, end=2147483647)",
          "doc": ""
        },
        "encode": {
          "signature": "(self, encoding='utf-8', errors='strict')",
          "doc": ""
        },
        "endswith": {
          "signature": "(self, suffix, start=0, end=2147483647)",
          "doc": ""
        },
        "expandtabs": {
          "signature": "(self, tabsize=8)",
          "doc": ""
        },
        "find": {
          "signature": "(self, sub, start=0, end=2147483647)",
          "doc": ""
        },
        "format": {
          "signature": "(self, /, *args, **kwds)",
          "doc": ""
        },
        "format_map": {
          "signature": "(self, mapping)",
          "doc": ""
        },
        "index": {
          "signature": "(self, sub, start=0, end=2147483647)",
          "doc": ""
        },
        "isalnum": {
          "signature": "(self)",
          "doc": ""
        },
        "isalpha": {
          "signature": "(self)",
          "doc": ""
        },
        "isascii": {
          "signature": "(self)",
          "doc": ""
        },
        "isdecimal": {
          "signature": "(self)",
          "doc": ""
        },
        "isdigit": {
          "signature": "(self)",
          "doc": ""
        },
        "isidentifier": {
          "signature": "(self)",
          "doc": ""
        },
        "islower": {
          "signature": "(self)",
          "doc": ""
        },
        "isnumeric": {
          "signature": "(self)",
          "doc": ""
        },
        "isprintable": {
          "signature": "(self)",
          "doc": ""
        },
        "isspace": {
          "signature": "(self)",
          "doc": ""
        },
        "istitle": {
          "signature": "(self)",
          "doc": ""
        },
        "isupper": {
          "signature": "(self)",
          "doc": ""
        },
        "join": {
          "signature": "(self, seq)",
          "doc": ""
        },
        "ljust": {
          "signature": "(self, width, *args)",
          "doc": ""
        },
        "lower": {
          "signature": "(self)",
          "doc": ""
        },
        "lstrip": {
          "signature": "(self, chars=None)",
          "doc": ""
        },
        "partition": {
          "signature": "(self, sep)",
          "doc": ""
        },
        "replace": {
          "signature": "(self, old, new, maxsplit=-1)",
          "doc": ""
        },
        "rfind": {
          "signature": "(self, sub, start=0, end=2147483647)",
          "doc": ""
        },
        "rindex": {
          "signature": "(self, sub, start=0, end=2147483647)",
          "doc": ""
        },
        "rjust": {
          "signature": "(self, width, *args)",
          "doc": ""
        },
        "rpartition": {
          "signature": "(self, sep)",
          "doc": ""
        },
        "rsplit": {
          "signature": "(self, sep=None, maxsplit=-1)",
          "doc": ""
        },
        "rstrip": {
          "signature": "(self, chars=None)",
          "doc": ""
        },
        "split": {
          "signature": "(self, sep=None, maxsplit=-1)",
          "doc": ""
        },
        "splitlines": {
          "signature": "(self, keepends=False)",
          "doc": ""
        },
        "startswith": {
          "signature": "(self, prefix, start=0, end=2147483647)",
          "doc": ""
        },
        "strip": {
          "signature": "(self, chars=None)",
          "doc": ""
        },
        "swapcase": {
          "signature": "(self)",
          "doc": ""
        },
        "title": {
          "signature": "(self)",
          "doc": ""
        },
        "translate": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "upper": {
          "signature": "(self)",
          "doc": ""
        },
        "zfill": {
          "signature": "(self, width)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "collections"
    },
    "defaultdict": {
      "methods": {},
      "doc": "defaultdict(default_factory[, ...]) --> dict with default factory",
      "module": "collections"
    },
    "deque": {
      "methods": {},
      "doc": "deque([iterable[, maxlen]]) --> deque object",
      "module": "contextlib"
    },
    "RLock": {
      "methods": {},
      "doc": "",
      "module": "functools"
    },
    "cached_property": {
      "methods": {},
      "doc": "",
      "module": "functools"
    },
    "partial": {
      "methods": {},
      "doc": "partial(func, *args, **keywords) - new function with partial application",
      "module": "functools"
    },
    "partialmethod": {
      "methods": {},
      "doc": "Method descriptor with partial application of the given arguments",
      "module": "functools"
    },
    "singledispatchmethod": {
      "methods": {
        "register": {
          "signature": "(self, cls, method=None)",
          "doc": "generic_method.register(cls, func) -> func"
        }
      },
      "doc": "Single-dispatch generic method descriptor.",
      "module": "functools"
    },
    "AbstractAsyncContextManager": {
      "methods": {},
      "doc": "An abstract base class for asynchronous context managers.",
      "module": "contextlib"
    },
    "AbstractContextManager": {
      "methods": {},
      "doc": "An abstract base class for context managers.",
      "module": "contextlib"
    },
    "AsyncExitStack": {
      "methods": {
        "aclose": {
          "signature": "(self)",
          "doc": "Immediately unwind the context stack."
        },
        "callback": {
          "signature": "(self, callback, /, *args, **kwds)",
          "doc": "Registers an arbitrary callback and arguments."
        },
        "enter_async_context": {
          "signature": "(self, cm)",
          "doc": "Enters the supplied async context manager."
        },
        "enter_context": {
          "signature": "(self, cm)",
          "doc": "Enters the supplied context manager."
        },
        "pop_all": {
          "signature": "(self)",
          "doc": "Preserve the context stack by transferring it to a new instance."
        },
        "push": {
          "signature": "(self, exit)",
          "doc": "Registers a callback with the standard __exit__ method signature."
        },
        "push_async_callback": {
          "signature": "(self, callback, /, *args, **kwds)",
          "doc": "Registers an arbitrary coroutine function and arguments."
        },
        "push_async_exit": {
          "signature": "(self, exit)",
          "doc": "Registers a coroutine function with the standard __aexit__ method"
        }
      },
      "doc": "Async context manager for dynamic management of a stack of exit",
      "module": "contextlib"
    },
    "ContextDecorator": {
      "methods": {},
      "doc": "A base class or mixin that enables context managers to work as decorators.",
      "module": "contextlib"
    },
    "ExitStack": {
      "methods": {
        "callback": {
          "signature": "(self, callback, /, *args, **kwds)",
          "doc": "Registers an arbitrary callback and arguments."
        },
        "close": {
          "signature": "(self)",
          "doc": "Immediately unwind the context stack."
        },
        "enter_context": {
          "signature": "(self, cm)",
          "doc": "Enters the supplied context manager."
        },
        "pop_all": {
          "signature": "(self)",
          "doc": "Preserve the context stack by transferring it to a new instance."
        },
        "push": {
          "signature": "(self, exit)",
          "doc": "Registers a callback with the standard __exit__ method signature."
        }
      },
      "doc": "Context manager for dynamic management of a stack of exit callbacks.",
      "module": "contextlib"
    },
    "closing": {
      "methods": {},
      "doc": "Context to automatically close something at the end of a block.",
      "module": "contextlib"
    },
    "nullcontext": {
      "methods": {},
      "doc": "Context manager that does no additional processing.",
      "module": "contextlib"
    },
    "redirect_stderr": {
      "methods": {},
      "doc": "Context manager for temporarily redirecting stderr to another file.",
      "module": "contextlib"
    },
    "redirect_stdout": {
      "methods": {},
      "doc": "Context manager for temporarily redirecting stdout to another file.",
      "module": "contextlib"
    },
    "suppress": {
      "methods": {},
      "doc": "Context manager to suppress specified exceptions",
      "module": "contextlib"
    }
  },
  "vars": {
    "api_version": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sys"
    },
    "argv": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sys"
    },
    "base_exec_prefix": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "base_prefix": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "builtin_module_names": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "sys"
    },
    "byteorder": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "copyright": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "dllhandle": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sys"
    },
    "dont_write_bytecode": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "sys"
    },
    "exec_prefix": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "executable": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "flags": {
      "doc": "sys.flags",
      "type": "flags",
      "module": "sys"
    },
    "float_info": {
      "doc": "sys.float_info",
      "type": "float_info",
      "module": "sys"
    },
    "float_repr_style": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "frozen": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "sys"
    },
    "hash_info": {
      "doc": "hash_info",
      "type": "hash_info",
      "module": "sys"
    },
    "hexversion": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sys"
    },
    "implementation": {
      "doc": "A simple attribute-based namespace.",
      "type": "SimpleNamespace",
      "module": "sys"
    },
    "int_info": {
      "doc": "sys.int_info",
      "type": "int_info",
      "module": "sys"
    },
    "maxsize": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sys"
    },
    "maxunicode": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sys"
    },
    "meta_path": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sys"
    },
    "modules": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sys"
    },
    "path": {
      "doc": "Common pathname manipulations, WindowsNT/95 version.",
      "type": "module",
      "module": "os"
    },
    "path_hooks": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sys"
    },
    "path_importer_cache": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sys"
    },
    "platform": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "prefix": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "pycache_prefix": {
      "doc": "",
      "type": "NoneType",
      "module": "sys"
    },
    "stderr": {
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "type": "TextIOWrapper",
      "module": "sys"
    },
    "stdin": {
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "type": "TextIOWrapper",
      "module": "sys"
    },
    "stdout": {
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "type": "TextIOWrapper",
      "module": "sys"
    },
    "thread_info": {
      "doc": "sys.thread_info",
      "type": "thread_info",
      "module": "sys"
    },
    "version": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "marshal"
    },
    "version_info": {
      "doc": "sys.version_info",
      "type": "version_info",
      "module": "sys"
    },
    "warnoptions": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sys"
    },
    "winver": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "Ellipsis": {
      "doc": "",
      "type": "ellipsis",
      "module": "builtins"
    },
    "False": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "builtins"
    },
    "None": {
      "doc": "",
      "type": "NoneType",
      "module": "builtins"
    },
    "NotImplemented": {
      "doc": "",
      "type": "NotImplementedType",
      "module": "builtins"
    },
    "True": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "builtins"
    },
    "F_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_APPEND": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_BINARY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_CREAT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_EXCL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_NOINHERIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_RANDOM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_RDONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_RDWR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_SEQUENTIAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_SHORT_LIVED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_TEMPORARY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_TEXT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_TRUNC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_WRONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_DETACH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_NOWAIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_NOWAITO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_OVERLAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_WAIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "R_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "TMP_MAX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "W_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "X_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "environ": {
      "doc": "",
      "type": "_Environ",
      "module": "os"
    },
    "HKEY_CLASSES_ROOT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_CURRENT_CONFIG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_CURRENT_USER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_DYN_DATA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_LOCAL_MACHINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_PERFORMANCE_DATA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_USERS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_ALL_ACCESS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_CREATE_LINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_CREATE_SUB_KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_ENUMERATE_SUB_KEYS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_EXECUTE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_NOTIFY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_QUERY_VALUE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_READ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_SET_VALUE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_WOW64_32KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_WOW64_64KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_WRITE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_BINARY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_CREATED_NEW_KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_DWORD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_DWORD_BIG_ENDIAN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_DWORD_LITTLE_ENDIAN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_EXPAND_SZ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_FULL_RESOURCE_DESCRIPTOR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_LEGAL_CHANGE_FILTER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_LEGAL_OPTION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_LINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_MULTI_SZ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NONE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NOTIFY_CHANGE_ATTRIBUTES": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NOTIFY_CHANGE_LAST_SET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NOTIFY_CHANGE_NAME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NOTIFY_CHANGE_SECURITY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NO_LAZY_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPENED_EXISTING_KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_BACKUP_RESTORE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_CREATE_LINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_NON_VOLATILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_OPEN_LINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_RESERVED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_VOLATILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_QWORD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_QWORD_LITTLE_ENDIAN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_REFRESH_HIVE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_RESOURCE_LIST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_RESOURCE_REQUIREMENTS_LIST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_SZ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_WHOLE_HIVE_VOLATILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "altzone": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "time"
    },
    "daylight": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "time"
    },
    "timezone": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "time"
    },
    "tzname": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "time"
    },
    "END_CENTRAL_DIR_SIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipimport"
    },
    "MAX_COMMENT_LEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipimport"
    },
    "STRING_END_ARCHIVE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipimport"
    },
    "alt_path_sep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zipimport"
    },
    "cp437_table": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zipimport"
    },
    "marshal": {
      "doc": "This module contains functions that can read and write Python values in",
      "type": "module",
      "module": "importlib._bootstrap_external"
    },
    "path_sep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "importlib._bootstrap_external"
    },
    "sys": {
      "doc": "This module provides access to some objects used or maintained by the",
      "type": "module",
      "module": "contextlib"
    },
    "time": {
      "doc": "This module provides various functions to manipulate time values.",
      "type": "module",
      "module": "zipimport"
    },
    "DEFLATED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "DEF_BUF_SIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "DEF_MEM_LEVEL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "MAX_WBITS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "ZLIB_RUNTIME_VERSION": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zlib"
    },
    "ZLIB_VERSION": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zlib"
    },
    "Z_BEST_COMPRESSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_BEST_SPEED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_BLOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_DEFAULT_COMPRESSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_DEFAULT_STRATEGY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_FILTERED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_FINISH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_FIXED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_FULL_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_HUFFMAN_ONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_NO_COMPRESSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_NO_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_PARTIAL_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_RLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_SYNC_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_TREES": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "BOM": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM32_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM32_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM64_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM64_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF16": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF16_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF16_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF32": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF32_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF32_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF8": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "builtins": {
      "doc": "Built-in functions, exceptions, and other objects.",
      "type": "module",
      "module": "reprlib"
    },
    "aliases": {
      "doc": " Encoding Aliases Support",
      "type": "module",
      "module": "encodings"
    },
    "codecs": {
      "doc": " codecs -- Python Codec Registry, API and helpers.",
      "type": "module",
      "module": "encodings.latin_1"
    },
    "cp1252": {
      "doc": " Python Character Mapping Codec cp1252 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1252.TXT' with gencodec.py.",
      "type": "module",
      "module": "encodings"
    },
    "cp949": {
      "doc": "",
      "type": "module",
      "module": "encodings"
    },
    "latin_1": {
      "doc": " Python 'latin-1' Codec",
      "type": "module",
      "module": "encodings"
    },
    "utf_8": {
      "doc": " Python 'utf-8' Codec",
      "type": "module",
      "module": "encodings"
    },
    "decoding_table": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "encodings.cp1252"
    },
    "encoding_table": {
      "doc": "",
      "type": "EncodingMap",
      "module": "encodings.cp1252"
    },
    "DEFAULT_BUFFER_SIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "io"
    },
    "SEEK_CUR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "SEEK_END": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "SEEK_SET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "abc": {
      "doc": "Abstract Base Classes (ABCs) according to PEP 3119.",
      "type": "module",
      "module": "contextlib"
    },
    "FILE_ATTRIBUTE_ARCHIVE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_COMPRESSED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_DEVICE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_DIRECTORY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_ENCRYPTED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_HIDDEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_INTEGRITY_STREAM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_NORMAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_NOT_CONTENT_INDEXED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_NO_SCRUB_DATA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_OFFLINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_READONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_REPARSE_POINT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_SPARSE_FILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_SYSTEM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_TEMPORARY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_VIRTUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "IO_REPARSE_TAG_APPEXECLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "IO_REPARSE_TAG_MOUNT_POINT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "IO_REPARSE_TAG_SYMLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_APPEND": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_ARCHIVED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_IMMUTABLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_NOUNLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_SNAPSHOT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_ATIME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_CTIME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_DEV": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_GID": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_INO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_MODE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_MTIME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_NLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_SIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_UID": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_ENFMT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IEXEC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFBLK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFCHR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFDIR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFDOOR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFIFO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFLNK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFREG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFSOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFWHT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IREAD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRGRP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IROTH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRUSR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRWXG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRWXO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRWXU": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_ISGID": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_ISUID": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_ISVTX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IWGRP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IWOTH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IWRITE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IWUSR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IXGRP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IXOTH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IXUSR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_APPEND": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_COMPRESSED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_HIDDEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_IMMUTABLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_NODUMP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_NOUNLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_OPAQUE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "os": {
      "doc": "OS routines for NT or Posix depending on what system we're on.",
      "type": "module",
      "module": "os.path"
    },
    "stat": {
      "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().",
      "type": "module",
      "module": "os.path"
    },
    "altsep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "os"
    },
    "curdir": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "os"
    },
    "defpath": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "os"
    },
    "devnull": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "os"
    },
    "extsep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "os"
    },
    "genericpath": {
      "doc": "",
      "type": "module",
      "module": "os.path"
    },
    "pardir": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "os"
    },
    "pathsep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "os"
    },
    "sep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "os"
    },
    "supports_unicode_filenames": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "os.path"
    },
    "linesep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "os"
    },
    "name": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "os"
    },
    "st": {
      "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().",
      "type": "module",
      "module": "os"
    },
    "supports_bytes_environ": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "os"
    },
    "supports_dir_fd": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "os"
    },
    "supports_effective_ids": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "os"
    },
    "supports_fd": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "os"
    },
    "supports_follow_symlinks": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "os"
    },
    "BYTECODE_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "DEBUG_BYTECODE_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "EXTENSION_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "MAGIC_NUMBER": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "importlib._bootstrap_external"
    },
    "OPTIMIZED_BYTECODE_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "SOURCE_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "path_separators": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "importlib._bootstrap_external"
    },
    "defaultaction": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "warnings"
    },
    "filters": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "warnings"
    },
    "onceregistry": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "warnings"
    },
    "machinery": {
      "doc": "The machinery of importlib: finders, loaders, hooks, etc.",
      "type": "module",
      "module": "importlib.abc"
    },
    "types": {
      "doc": "",
      "type": "module",
      "module": "importlib"
    },
    "util": {
      "doc": "Utility code for constructing importers, etc.",
      "type": "module",
      "module": "importlib"
    },
    "warnings": {
      "doc": "Python part of the warnings subsystem.",
      "type": "module",
      "module": "importlib.abc"
    },
    "kwlist": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "keyword"
    },
    "aRepr": {
      "doc": "",
      "type": "Repr",
      "module": "reprlib"
    },
    "repr": {
      "doc": "",
      "type": "method",
      "module": "reprlib"
    },
    "WRAPPER_ASSIGNMENTS": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "functools"
    },
    "WRAPPER_UPDATES": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "functools"
    }
  }
}