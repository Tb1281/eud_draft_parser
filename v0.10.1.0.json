{
  "built_ins": {
    "clear": {
      "type": "built_in",
      "doc": "D.clear() -> None.  Remove all items from D."
    },
    "copy": {
      "type": "built_in",
      "doc": "D.copy() -> a shallow copy of D"
    },
    "fromkeys": {
      "type": "built_in",
      "doc": "Create a new dictionary with keys from iterable and values set to value."
    },
    "get": {
      "type": "built_in",
      "doc": "Return the value for key if key is in the dictionary, else default."
    },
    "items": {
      "type": "built_in",
      "doc": "D.items() -> a set-like object providing a view on D's items"
    },
    "keys": {
      "type": "built_in",
      "doc": "D.keys() -> a set-like object providing a view on D's keys"
    },
    "pop": {
      "type": "built_in",
      "doc": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value."
    },
    "popitem": {
      "type": "built_in",
      "doc": "Remove and return a (key, value) pair as a 2-tuple."
    },
    "setdefault": {
      "type": "built_in",
      "doc": "Insert key with a value of default if key is not in the dictionary."
    },
    "update": {
      "type": "built_in",
      "doc": "D.update([E, ]**F) -> None.  Update D from dict/iterable E and F."
    },
    "values": {
      "type": "built_in",
      "doc": "D.values() -> an object providing a view on D's values"
    }
  },
  "keywords": {
    "False": {
      "type": "keyword"
    },
    "None": {
      "type": "keyword"
    },
    "True": {
      "type": "keyword"
    },
    "and": {
      "type": "keyword"
    },
    "as": {
      "type": "keyword"
    },
    "assert": {
      "type": "keyword"
    },
    "async": {
      "type": "keyword"
    },
    "await": {
      "type": "keyword"
    },
    "break": {
      "type": "keyword"
    },
    "class": {
      "type": "keyword"
    },
    "continue": {
      "type": "keyword"
    },
    "def": {
      "type": "keyword"
    },
    "del": {
      "type": "keyword"
    },
    "elif": {
      "type": "keyword"
    },
    "else": {
      "type": "keyword"
    },
    "except": {
      "type": "keyword"
    },
    "finally": {
      "type": "keyword"
    },
    "for": {
      "type": "keyword"
    },
    "from": {
      "type": "keyword"
    },
    "global": {
      "type": "keyword"
    },
    "if": {
      "type": "keyword"
    },
    "import": {
      "type": "keyword"
    },
    "in": {
      "type": "keyword"
    },
    "is": {
      "type": "keyword"
    },
    "lambda": {
      "type": "keyword"
    },
    "nonlocal": {
      "type": "keyword"
    },
    "not": {
      "type": "keyword"
    },
    "or": {
      "type": "keyword"
    },
    "pass": {
      "type": "keyword"
    },
    "raise": {
      "type": "keyword"
    },
    "return": {
      "type": "keyword"
    },
    "try": {
      "type": "keyword"
    },
    "while": {
      "type": "keyword"
    },
    "with": {
      "type": "keyword"
    },
    "yield": {
      "type": "keyword"
    }
  },
  "libraries": {
    "sys": {
      "type": "module",
      "doc": "This module provides access to some objects used or maintained by the"
    },
    "builtins": {
      "type": "module",
      "doc": "Built-in functions, types, exceptions, and other objects."
    },
    "winreg": {
      "type": "module",
      "doc": "This module provides access to the Windows registry API."
    },
    "marshal": {
      "type": "module",
      "doc": "This module contains functions that can read and write Python values in"
    },
    "nt": {
      "type": "module",
      "doc": "This module provides access to operating system functionality that is"
    },
    "time": {
      "type": "module",
      "doc": "This module provides various functions to manipulate time values."
    },
    "zipimport": {
      "type": "module",
      "doc": "zipimport provides support for importing Python modules from Zip archives."
    },
    "zlib": {
      "type": "module",
      "doc": "The functions in this module allow compression and decompression using the"
    },
    "codecs": {
      "type": "module",
      "doc": " codecs -- Python Codec Registry, API and helpers."
    },
    "encodings.aliases": {
      "type": "module",
      "doc": ""
    },
    "encodings": {
      "type": "module",
      "doc": ""
    },
    "encodings.utf_8": {
      "type": "module",
      "doc": ""
    },
    "encodings.cp1252": {
      "type": "module",
      "doc": ""
    },
    "abc": {
      "type": "module",
      "doc": "Abstract Base Classes (ABCs) according to PEP 3119."
    },
    "io": {
      "type": "module",
      "doc": "The io module provides the Python interfaces to stream handling. The"
    },
    "stat": {
      "type": "module",
      "doc": "Constants/functions for interpreting results of os.stat() and os.lstat()."
    },
    "genericpath": {
      "type": "module",
      "doc": ""
    },
    "ntpath": {
      "type": "module",
      "doc": "Common pathname manipulations, WindowsNT/95 version."
    },
    "os.path": {
      "type": "module",
      "doc": "Common pathname manipulations, WindowsNT/95 version."
    },
    "os": {
      "type": "module",
      "doc": "OS routines for NT or Posix depending on what system we're on."
    },
    "itertools": {
      "type": "module",
      "doc": "Functional tools for creating and using iterators."
    },
    "keyword": {
      "type": "module",
      "doc": ""
    },
    "operator": {
      "type": "module",
      "doc": "Operator interface."
    },
    "reprlib": {
      "type": "module",
      "doc": ""
    },
    "collections": {
      "type": "module",
      "doc": ""
    },
    "types": {
      "type": "module",
      "doc": ""
    },
    "functools": {
      "type": "module",
      "doc": ""
    },
    "contextlib": {
      "type": "module",
      "doc": ""
    },
    "enum": {
      "type": "module",
      "doc": ""
    },
    "re._constants": {
      "type": "module",
      "doc": ""
    },
    "re._parser": {
      "type": "module",
      "doc": ""
    },
    "re._casefix": {
      "type": "module",
      "doc": ""
    },
    "re._compiler": {
      "type": "module",
      "doc": ""
    },
    "copyreg": {
      "type": "module",
      "doc": ""
    },
    "re": {
      "type": "module",
      "doc": ""
    },
    "string": {
      "type": "module",
      "doc": ""
    },
    "importlib._bootstrap": {
      "type": "module",
      "doc": "Core implementation of import."
    },
    "importlib._bootstrap_external": {
      "type": "module",
      "doc": "Core implementation of path-based import."
    },
    "warnings": {
      "type": "module",
      "doc": ""
    },
    "importlib": {
      "type": "module",
      "doc": ""
    },
    "importlib.machinery": {
      "type": "module",
      "doc": "The machinery of importlib: finders, loaders, hooks, etc."
    },
    "BUILD_CONSTANTS": {
      "type": "module",
      "doc": ""
    },
    "importlib._abc": {
      "type": "module",
      "doc": ""
    },
    "threading": {
      "type": "module",
      "doc": ""
    },
    "importlib.util": {
      "type": "module",
      "doc": "Utility code for constructing importers, etc."
    },
    "signal": {
      "type": "module",
      "doc": ""
    },
    "multiprocessing.process": {
      "type": "module",
      "doc": ""
    },
    "struct": {
      "type": "module",
      "doc": "Functions to convert between Python values and C structs."
    },
    "pickle": {
      "type": "module",
      "doc": ""
    },
    "collections.abc": {
      "type": "module",
      "doc": ""
    },
    "math": {
      "type": "module",
      "doc": "This module provides access to the mathematical functions"
    },
    "select": {
      "type": "module",
      "doc": "This module supports asynchronous I/O on multiple file descriptors."
    },
    "selectors": {
      "type": "module",
      "doc": ""
    },
    "errno": {
      "type": "module",
      "doc": "This module makes available standard errno system symbols."
    },
    "socket": {
      "type": "module",
      "doc": ""
    },
    "multiprocessing.reduction": {
      "type": "module",
      "doc": ""
    },
    "multiprocessing.context": {
      "type": "module",
      "doc": ""
    },
    "multiprocessing": {
      "type": "module",
      "doc": ""
    },
    "typing.io": {
      "type": "module",
      "doc": ""
    },
    "typing.re": {
      "type": "module",
      "doc": ""
    },
    "typing": {
      "type": "module",
      "doc": ""
    },
    "eudplib.bindings": {
      "type": "module",
      "doc": ""
    },
    "eudplib.bindings._rust": {
      "type": "module",
      "doc": ""
    },
    "eudplib.utils.binio": {
      "type": "module",
      "doc": ""
    },
    "gettext": {
      "type": "module",
      "doc": ""
    },
    "locale": {
      "type": "module",
      "doc": ""
    },
    "eudplib.localize": {
      "type": "module",
      "doc": ""
    },
    "eudplib.utils.eperror": {
      "type": "module",
      "doc": ""
    },
    "eudplib.utils.blockstru": {
      "type": "module",
      "doc": ""
    },
    "bisect": {
      "type": "module",
      "doc": ""
    },
    "random": {
      "type": "module",
      "doc": ""
    },
    "eudplib.utils.exprproxy": {
      "type": "module",
      "doc": ""
    },
    "eudplib.utils.etc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.utils.ubconv": {
      "type": "module",
      "doc": ""
    },
    "eudplib.utils": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.allocator.rlocint": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.allocator.constexpr": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.allocator.pbuffer": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.allocator.payload": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.allocator": {
      "type": "module",
      "doc": ""
    },
    "ast": {
      "type": "module",
      "doc": ""
    },
    "opcode": {
      "type": "module",
      "doc": ""
    },
    "dis": {
      "type": "module",
      "doc": ""
    },
    "token": {
      "type": "module",
      "doc": ""
    },
    "tokenize": {
      "type": "module",
      "doc": ""
    },
    "linecache": {
      "type": "module",
      "doc": ""
    },
    "inspect": {
      "type": "module",
      "doc": ""
    },
    "typing_extensions": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.consttype": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.action": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.condition": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.chktok": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.playerinfo": {
      "type": "module",
      "doc": ""
    },
    "ctypes._endian": {
      "type": "module",
      "doc": ""
    },
    "ctypes": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.unitprp": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.proptable": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.tblformat": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.stringmap": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.mapdata": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.constenc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudobj.eudobj": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudobj.bytedump": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudobj": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.triggerscope": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.rawtriggerdef": {
      "type": "module",
      "doc": ""
    },
    "heapq": {
      "type": "module",
      "doc": ""
    },
    "difflib": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.flingy": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.icon": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.image": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.iscript": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.portrait": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.sfxdata": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.sprite": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.stattxt": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.tech": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.trg": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.unitorder": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.upgrade": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.weapon": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strenc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.stockact": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.stockcond": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.variable.vbase": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.variable.eudlv": {
      "type": "module",
      "doc": ""
    },
    "textwrap": {
      "type": "module",
      "doc": ""
    },
    "traceback": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.variable.vbuf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.variable.eudv": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.variable.eudxv": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.variable": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.variable.evcommon": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.trace": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.trace.tracecrypt": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.trace.tracetool": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.eudfuncn": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.eudtypedfuncn": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.eudf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudstruct.selftype": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.curpl": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.inplacecw": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudstruct.vararray": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudstruct.structarr": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudstruct.eudstruct": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudstruct": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.eudfmethod": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.calcf.muldiv": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.calcf.bitwise": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.calcf._eudvsupport": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.calcf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.eudfptr": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.inlinens": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigger.filler": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigger.tpatcher": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigger.branch": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigger.triggerdef": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigger.ptrigger": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigger": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.basicstru": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.cshelper": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.loopblock": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.jumptable": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.swblock": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.breakcont": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.simpleblock": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.logic": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.shortcircuit": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.s": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.modcurpl": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.readtable": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.dwepdio": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.cpmemio": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.bwepdio": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.byterw": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.cpbyterw": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.mblockio": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.memifgen": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.ptrmemio": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.specialized": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.varrayreader": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio": {
      "type": "module",
      "doc": ""
    },
    "eudplib.collections.eudarray": {
      "type": "module",
      "doc": ""
    },
    "eudplib.collections.eudqueue": {
      "type": "module",
      "doc": ""
    },
    "eudplib.collections.eudstack": {
      "type": "module",
      "doc": ""
    },
    "eudplib.collections.playerv": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.rwcommon": {
      "type": "module",
      "doc": ""
    },
    "eudplib.memio.muldiv4table": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.offsetmap.epdoffsetmap": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.offsetmap.memberkind": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.offsetmap.member": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.offsetmap.enummember": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.offsetmap": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.offsetmap.memberimpl": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.csprite": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.player": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.unit": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.cunit": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.flingy": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.image": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.sprite": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.tech": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.unitorder": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.upgrade": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata.weapon": {
      "type": "module",
      "doc": ""
    },
    "eudplib.scdata": {
      "type": "module",
      "doc": ""
    },
    "eudplib.collections.unitgroup": {
      "type": "module",
      "doc": ""
    },
    "eudplib.collections": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.locf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.locf.locf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.mathf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.mathf.atan2": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.mathf.div": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.mathf.lengthdir": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.mathf.pow": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.mathf.sqrt": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.binsearch": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.gametick": {
      "type": "module",
      "doc": ""
    },
    "weakref": {
      "type": "module",
      "doc": ""
    },
    "copy": {
      "type": "module",
      "doc": ""
    },
    "dataclasses": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.unlimiterflag": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.listloop": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.pexist": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.random": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.userpl": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.wireframe": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.injector": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigtrg.runtrigtrg": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigtrg.trigtrg": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigtrg": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.inlinecode": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.inlinecode.btinliner": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.inlinecode.ilccompile": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.inlinecode.ilcprocesstrig": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.injector.inj_finalizer": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.injector.payload_init": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.injector.payload_reloc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.injector.vector_reloc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.injector.apply_injector": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.cpstr": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.strcommon": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.dbstr": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.cpprint": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.cp949_table": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.cputf8": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.eudprint": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.fmtprint": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.locale": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.parse": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.strfunc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.pname": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.texteffect": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.strbuffer": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.strall": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string.tblprint": {
      "type": "module",
      "doc": ""
    },
    "eudplib.string": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.injector.mainloop": {
      "type": "module",
      "doc": ""
    },
    "posixpath": {
      "type": "module",
      "doc": "Common operations on Posix pathnames."
    },
    "fnmatch": {
      "type": "module",
      "doc": ""
    },
    "bz2": {
      "type": "module",
      "doc": ""
    },
    "lzma": {
      "type": "module",
      "doc": ""
    },
    "shutil": {
      "type": "module",
      "doc": ""
    },
    "tempfile": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.mpqadd": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.loadmap": {
      "type": "module",
      "doc": ""
    },
    "binascii": {
      "type": "module",
      "doc": "Conversion between binary data and ASCII"
    },
    "eudplib.core.mapdata.fixmapdata": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.savemap": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.wireframe.wiredata": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.wireframe.wireframe": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib": {
      "type": "module",
      "doc": ""
    },
    "eudplib.prelude": {
      "type": "module",
      "doc": ""
    },
    "platform": {
      "type": "module",
      "doc": ""
    },
    "msvcrt": {
      "type": "module",
      "doc": ""
    },
    "subprocess": {
      "type": "module",
      "doc": ""
    },
    "eudplib.epscript.epscompile": {
      "type": "module",
      "doc": ""
    },
    "eudplib.epscript.linetable_calculator": {
      "type": "module",
      "doc": ""
    },
    "eudplib.epscript.epsimp": {
      "type": "module",
      "doc": ""
    },
    "eudplib.epscript": {
      "type": "module",
      "doc": ""
    },
    "eudplib.qgc.qgc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.qgc": {
      "type": "module",
      "doc": ""
    },
    "encodings.cp949": {
      "type": "module",
      "doc": ""
    },
    "eudplib": {
      "type": "module",
      "doc": ""
    },
    "atexit": {
      "type": "module",
      "doc": "allow programmer to define multiple exit functions to be executed"
    },
    "urllib": {
      "type": "module",
      "doc": ""
    },
    "ipaddress": {
      "type": "module",
      "doc": ""
    },
    "urllib.parse": {
      "type": "module",
      "doc": ""
    },
    "pathlib": {
      "type": "module",
      "doc": ""
    },
    "zipfile": {
      "type": "module",
      "doc": ""
    },
    "urllib.response": {
      "type": "module",
      "doc": ""
    },
    "urllib.error": {
      "type": "module",
      "doc": ""
    },
    "base64": {
      "type": "module",
      "doc": ""
    },
    "email": {
      "type": "module",
      "doc": ""
    },
    "hashlib": {
      "type": "module",
      "doc": "hashlib module - A common interface to many hash functions."
    },
    "http": {
      "type": "module",
      "doc": ""
    },
    "email.errors": {
      "type": "module",
      "doc": ""
    },
    "email.quoprimime": {
      "type": "module",
      "doc": ""
    },
    "email.base64mime": {
      "type": "module",
      "doc": ""
    },
    "quopri": {
      "type": "module",
      "doc": ""
    },
    "email.encoders": {
      "type": "module",
      "doc": ""
    },
    "email.charset": {
      "type": "module",
      "doc": ""
    },
    "email.header": {
      "type": "module",
      "doc": ""
    },
    "datetime": {
      "type": "module",
      "doc": "Fast implementation of the datetime type."
    },
    "calendar": {
      "type": "module",
      "doc": ""
    },
    "email._parseaddr": {
      "type": "module",
      "doc": ""
    },
    "email.utils": {
      "type": "module",
      "doc": ""
    },
    "email._policybase": {
      "type": "module",
      "doc": ""
    },
    "email.feedparser": {
      "type": "module",
      "doc": ""
    },
    "email.parser": {
      "type": "module",
      "doc": ""
    },
    "email._encoded_words": {
      "type": "module",
      "doc": ""
    },
    "email.iterators": {
      "type": "module",
      "doc": ""
    },
    "email.message": {
      "type": "module",
      "doc": ""
    },
    "ssl": {
      "type": "module",
      "doc": ""
    },
    "http.client": {
      "type": "module",
      "doc": ""
    },
    "nturl2path": {
      "type": "module",
      "doc": ""
    },
    "urllib.request": {
      "type": "module",
      "doc": ""
    },
    "winsound": {
      "type": "module",
      "doc": "PlaySound(sound, flags) - play a sound"
    },
    "ctypes.wintypes": {
      "type": "module",
      "doc": ""
    },
    "msgbox": {
      "type": "module",
      "doc": ""
    },
    "autoupdate": {
      "type": "module",
      "doc": ""
    },
    "pluginLoader": {
      "type": "module",
      "doc": ""
    },
    "readconfig": {
      "type": "module",
      "doc": ""
    },
    "runpy": {
      "type": "module",
      "doc": "runpy.py - locating and running Python code using the module namespace"
    },
    "multiprocessing.util": {
      "type": "module",
      "doc": ""
    },
    "multiprocessing.spawn": {
      "type": "module",
      "doc": ""
    },
    "euddraft": {
      "type": "module",
      "doc": ""
    },
    "freezeMpq": {
      "type": "module",
      "doc": ""
    },
    "scbank_core": {
      "type": "module",
      "doc": ""
    },
    "freeze.pdefault": {
      "type": "module",
      "doc": ""
    },
    "freeze.trigutils": {
      "type": "module",
      "doc": ""
    },
    "freeze.crypt": {
      "type": "module",
      "doc": ""
    },
    "freeze.mpqh": {
      "type": "module",
      "doc": ""
    },
    "freeze.keycalc": {
      "type": "module",
      "doc": ""
    },
    "freeze.utils": {
      "type": "module",
      "doc": ""
    },
    "freeze.obfjump": {
      "type": "module",
      "doc": ""
    },
    "freeze.obfpatch": {
      "type": "module",
      "doc": ""
    },
    "freeze.trigcrypt": {
      "type": "module",
      "doc": ""
    },
    "freeze.freeze": {
      "type": "module",
      "doc": ""
    },
    "freeze": {
      "type": "module",
      "doc": ""
    },
    "applyeuddraft": {
      "type": "module",
      "doc": ""
    },
    "eudplib.collections.objpool": {
      "type": "module",
      "doc": ""
    },
    "main": {
      "type": "module",
      "doc": ""
    },
    "json.scanner": {
      "type": "module",
      "doc": ""
    },
    "json.decoder": {
      "type": "module",
      "doc": ""
    },
    "json.encoder": {
      "type": "module",
      "doc": ""
    },
    "json": {
      "type": "module",
      "doc": ""
    },
    "pkgutil": {
      "type": "module",
      "doc": ""
    }
  },
  "functions": {
    "excepthook": {
      "signature": "(type_: type[BaseException], value: BaseException, traceback: traceback | None) -> None",
      "doc": "",
      "module": "eudplib.localize"
    },
    "unraisablehook": {
      "signature": "(unraisable: Any) -> None",
      "doc": "",
      "module": "eudplib.localize"
    },
    "EncodedFile": {
      "signature": "(file, data_encoding, file_encoding=None, errors='strict')",
      "doc": " Return a wrapped version of file which provides transparent",
      "module": "codecs"
    },
    "getdecoder": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getencoder": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getincrementaldecoder": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getincrementalencoder": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getreader": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getwriter": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "iterdecode": {
      "signature": "(iterator, encoding, errors='strict', **kwargs)",
      "doc": "",
      "module": "codecs"
    },
    "iterencode": {
      "signature": "(iterator, encoding, errors='strict', **kwargs)",
      "doc": "",
      "module": "codecs"
    },
    "make_encoding_map": {
      "signature": "(decoding_map)",
      "doc": " Creates an encoding map from a decoding map.",
      "module": "codecs"
    },
    "make_identity_dict": {
      "signature": "(rng)",
      "doc": " make_identity_dict(rng) -> dict",
      "module": "codecs"
    },
    "open": {
      "signature": "(filename, mode='rb', *, format=None, check=-1, preset=None, filters=None, encoding=None, errors=None, newline=None)",
      "doc": "",
      "module": "lzma"
    },
    "normalize_encoding": {
      "signature": "(encoding)",
      "doc": "",
      "module": "encodings"
    },
    "search_function": {
      "signature": "(encoding)",
      "doc": "",
      "module": "encodings"
    },
    "decode": {
      "signature": "(ew)",
      "doc": "",
      "module": "email._encoded_words"
    },
    "getregentry": {
      "signature": "()",
      "doc": "",
      "module": "encodings.cp949"
    },
    "abstractmethod": {
      "signature": "(funcobj)",
      "doc": "A decorator indicating abstract methods.",
      "module": "eudplib.scdata.offsetmap.member"
    },
    "update_abstractmethods": {
      "signature": "(cls)",
      "doc": "Recalculate the set of abstract methods of an abstract class.",
      "module": "abc"
    },
    "commonprefix": {
      "signature": "(m)",
      "doc": "Given a list of pathnames, returns the longest common leading component",
      "module": "posixpath"
    },
    "exists": {
      "signature": "(path)",
      "doc": "Test whether a path exists.  Returns False for broken symbolic links",
      "module": "posixpath"
    },
    "getatime": {
      "signature": "(filename)",
      "doc": "Return the last access time of a file, reported by os.stat().",
      "module": "posixpath"
    },
    "getctime": {
      "signature": "(filename)",
      "doc": "Return the metadata change time of a file, reported by os.stat().",
      "module": "posixpath"
    },
    "getmtime": {
      "signature": "(filename)",
      "doc": "Return the last modification time of a file, reported by os.stat().",
      "module": "posixpath"
    },
    "getsize": {
      "signature": "(filename)",
      "doc": "Return the size of a file, reported by os.stat().",
      "module": "posixpath"
    },
    "isdir": {
      "signature": "(s)",
      "doc": "Return true if the pathname refers to an existing directory.",
      "module": "posixpath"
    },
    "isfile": {
      "signature": "(path)",
      "doc": "Test whether a path is a regular file",
      "module": "posixpath"
    },
    "samefile": {
      "signature": "(f1, f2)",
      "doc": "Test whether two pathnames reference the same actual file or directory",
      "module": "posixpath"
    },
    "sameopenfile": {
      "signature": "(fp1, fp2)",
      "doc": "Test whether two open file objects reference the same file",
      "module": "posixpath"
    },
    "samestat": {
      "signature": "(s1, s2)",
      "doc": "Test whether two stat buffers reference the same file",
      "module": "posixpath"
    },
    "abspath": {
      "signature": "(path)",
      "doc": "Return an absolute path.",
      "module": "posixpath"
    },
    "basename": {
      "signature": "(p)",
      "doc": "Returns the final component of a pathname",
      "module": "posixpath"
    },
    "commonpath": {
      "signature": "(paths)",
      "doc": "Given a sequence of path names, returns the longest common sub-path.",
      "module": "posixpath"
    },
    "dirname": {
      "signature": "(p)",
      "doc": "Returns the directory component of a pathname",
      "module": "posixpath"
    },
    "expanduser": {
      "signature": "(path)",
      "doc": "Expand ~ and ~user constructions.  If user or $HOME is unknown,",
      "module": "posixpath"
    },
    "expandvars": {
      "signature": "(path)",
      "doc": "Expand shell variables of form $var and ${var}.  Unknown variables",
      "module": "posixpath"
    },
    "isabs": {
      "signature": "(s)",
      "doc": "Test whether a path is absolute",
      "module": "posixpath"
    },
    "islink": {
      "signature": "(path)",
      "doc": "Test whether a path is a symbolic link",
      "module": "posixpath"
    },
    "ismount": {
      "signature": "(path)",
      "doc": "Test whether a path is a mount point",
      "module": "posixpath"
    },
    "join": {
      "signature": "(a, *p)",
      "doc": "Join two or more pathname components, inserting '/' as needed.",
      "module": "posixpath"
    },
    "lexists": {
      "signature": "(path)",
      "doc": "Test whether a path exists.  Returns True for broken symbolic links",
      "module": "posixpath"
    },
    "normcase": {
      "signature": "(s)",
      "doc": "Normalize case of pathname.  Has no effect under Posix",
      "module": "posixpath"
    },
    "normpath": {
      "signature": "(path)",
      "doc": "Normalize path, eliminating double slashes, etc.",
      "module": "posixpath"
    },
    "realpath": {
      "signature": "(filename, *, strict=False)",
      "doc": "Return the canonical path of the specified filename, eliminating any",
      "module": "posixpath"
    },
    "relpath": {
      "signature": "(path, start=None)",
      "doc": "Return a relative version of a path",
      "module": "posixpath"
    },
    "split": {
      "signature": "(p)",
      "doc": "Split a pathname.  Returns tuple \"(head, tail)\" where \"tail\" is",
      "module": "posixpath"
    },
    "splitdrive": {
      "signature": "(p)",
      "doc": "Split a pathname into drive and path. On Posix, drive is always",
      "module": "posixpath"
    },
    "splitext": {
      "signature": "(p)",
      "doc": "Split the extension from a pathname.",
      "module": "posixpath"
    },
    "add_dll_directory": {
      "signature": "(path)",
      "doc": "Add a path to the DLL search path.",
      "module": "os"
    },
    "execl": {
      "signature": "(file, *args)",
      "doc": "execl(file, *args)",
      "module": "os"
    },
    "execle": {
      "signature": "(file, *args)",
      "doc": "execle(file, *args, env)",
      "module": "os"
    },
    "execlp": {
      "signature": "(file, *args)",
      "doc": "execlp(file, *args)",
      "module": "os"
    },
    "execlpe": {
      "signature": "(file, *args)",
      "doc": "execlpe(file, *args, env)",
      "module": "os"
    },
    "execvp": {
      "signature": "(file, args)",
      "doc": "execvp(file, args)",
      "module": "os"
    },
    "execvpe": {
      "signature": "(file, args, env)",
      "doc": "execvpe(file, args, env)",
      "module": "os"
    },
    "fdopen": {
      "signature": "(fd, mode='r', buffering=-1, encoding=None, *args, **kwargs)",
      "doc": "",
      "module": "os"
    },
    "fsdecode": {
      "signature": "(filename)",
      "doc": "Decode filename (an os.PathLike, bytes, or str) from the filesystem",
      "module": "os"
    },
    "fsencode": {
      "signature": "(filename)",
      "doc": "Encode filename (an os.PathLike, bytes, or str) to the filesystem",
      "module": "os"
    },
    "get_exec_path": {
      "signature": "(env=None)",
      "doc": "Returns the sequence of directories that will be searched for the",
      "module": "os"
    },
    "getenv": {
      "signature": "(key, default=None)",
      "doc": "Get an environment variable, return None if it doesn't exist.",
      "module": "os"
    },
    "makedirs": {
      "signature": "(name, mode=511, exist_ok=False)",
      "doc": "makedirs(name [, mode=0o777][, exist_ok=False])",
      "module": "os"
    },
    "popen": {
      "signature": "(cmd, mode='r', buffering=-1)",
      "doc": "",
      "module": "os"
    },
    "removedirs": {
      "signature": "(name)",
      "doc": "removedirs(name)",
      "module": "os"
    },
    "renames": {
      "signature": "(old, new)",
      "doc": "renames(old, new)",
      "module": "os"
    },
    "spawnl": {
      "signature": "(mode, file, *args)",
      "doc": "spawnl(mode, file, *args) -> integer",
      "module": "os"
    },
    "spawnle": {
      "signature": "(mode, file, *args)",
      "doc": "spawnle(mode, file, *args, env) -> integer",
      "module": "os"
    },
    "walk": {
      "signature": "(self)",
      "doc": "",
      "module": "email.iterators"
    },
    "recursive_repr": {
      "signature": "(fillvalue='...')",
      "doc": "",
      "module": "functools"
    },
    "namedtuple": {
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "doc": "",
      "module": "pkgutil"
    },
    "coroutine": {
      "signature": "(func)",
      "doc": "",
      "module": "types"
    },
    "new_class": {
      "signature": "(name, bases=(), kwds=None, exec_body=None)",
      "doc": "",
      "module": "types"
    },
    "prepare_class": {
      "signature": "(name, bases=(), kwds=None)",
      "doc": "",
      "module": "types"
    },
    "resolve_bases": {
      "signature": "(bases)",
      "doc": "",
      "module": "types"
    },
    "cache": {
      "signature": "(user_function, /)",
      "doc": "",
      "module": "functools"
    },
    "lru_cache": {
      "signature": "(maxsize=128, typed=False)",
      "doc": "",
      "module": "functools"
    },
    "singledispatch": {
      "signature": "(func)",
      "doc": "",
      "module": "functools"
    },
    "total_ordering": {
      "signature": "(cls)",
      "doc": "",
      "module": "functools"
    },
    "update_wrapper": {
      "signature": "(wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))",
      "doc": "",
      "module": "functools"
    },
    "wraps": {
      "signature": "(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))",
      "doc": "",
      "module": "contextlib"
    },
    "asynccontextmanager": {
      "signature": "(func)",
      "doc": "",
      "module": "contextlib"
    },
    "contextmanager": {
      "signature": "(func)",
      "doc": "",
      "module": "ast"
    },
    "bin": {
      "signature": "(num, max_bits=None)",
      "doc": "",
      "module": "enum"
    },
    "global_enum": {
      "signature": "(cls, update_str=False)",
      "doc": "",
      "module": "enum"
    },
    "global_enum_repr": {
      "signature": "(self)",
      "doc": "",
      "module": "enum"
    },
    "global_flag_repr": {
      "signature": "(self)",
      "doc": "",
      "module": "enum"
    },
    "global_str": {
      "signature": "(self)",
      "doc": "",
      "module": "enum"
    },
    "pickle_by_enum_name": {
      "signature": "(self, proto)",
      "doc": "",
      "module": "enum"
    },
    "pickle_by_global_name": {
      "signature": "(self, proto)",
      "doc": "",
      "module": "enum"
    },
    "show_flag_values": {
      "signature": "(value)",
      "doc": "",
      "module": "enum"
    },
    "unique": {
      "signature": "(enumeration)",
      "doc": "",
      "module": "enum"
    },
    "expand_template": {
      "signature": "(template, match)",
      "doc": "",
      "module": "re._parser"
    },
    "fix_flags": {
      "signature": "(src, flags)",
      "doc": "",
      "module": "re._parser"
    },
    "parse": {
      "signature": "(source, filename='<unknown>', mode='exec', *, type_comments=False, feature_version=None)",
      "doc": "",
      "module": "ast"
    },
    "parse_template": {
      "signature": "(source, state)",
      "doc": "",
      "module": "re._parser"
    },
    "compile": {
      "signature": "(pattern, flags=0)",
      "doc": "",
      "module": "re"
    },
    "dis": {
      "signature": "(x=None, *, file=None, depth=None, show_caches=False, adaptive=False)",
      "doc": "",
      "module": "dis"
    },
    "isstring": {
      "signature": "(obj)",
      "doc": "",
      "module": "re._compiler"
    },
    "add_extension": {
      "signature": "(module, name, code)",
      "doc": "",
      "module": "copyreg"
    },
    "clear_extension_cache": {
      "signature": "()",
      "doc": "",
      "module": "copyreg"
    },
    "constructor": {
      "signature": "(object)",
      "doc": "",
      "module": "copyreg"
    },
    "pickle": {
      "signature": "(ob_type, pickle_function, constructor_ob=None)",
      "doc": "",
      "module": "copyreg"
    },
    "pickle_complex": {
      "signature": "(c)",
      "doc": "",
      "module": "copyreg"
    },
    "pickle_union": {
      "signature": "(obj)",
      "doc": "",
      "module": "copyreg"
    },
    "remove_extension": {
      "signature": "(module, name, code)",
      "doc": "",
      "module": "copyreg"
    },
    "escape": {
      "signature": "(pattern)",
      "doc": "",
      "module": "re"
    },
    "findall": {
      "signature": "(pattern, string, flags=0)",
      "doc": "",
      "module": "re"
    },
    "finditer": {
      "signature": "(pattern, string, flags=0)",
      "doc": "",
      "module": "re"
    },
    "fullmatch": {
      "signature": "(pattern, string, flags=0)",
      "doc": "",
      "module": "re"
    },
    "match": {
      "signature": "(pattern, string, flags=0)",
      "doc": "",
      "module": "re"
    },
    "purge": {
      "signature": "()",
      "doc": "",
      "module": "re"
    },
    "search": {
      "signature": "(pattern, string, flags=0)",
      "doc": "",
      "module": "re"
    },
    "sub": {
      "signature": "(pattern, repl, string, count=0, flags=0)",
      "doc": "",
      "module": "re"
    },
    "subn": {
      "signature": "(pattern, repl, string, count=0, flags=0)",
      "doc": "",
      "module": "re"
    },
    "template": {
      "signature": "(pattern, flags=0)",
      "doc": "",
      "module": "re"
    },
    "capwords": {
      "signature": "(s, sep=None)",
      "doc": "",
      "module": "string"
    },
    "module_from_spec": {
      "signature": "(spec)",
      "doc": "Create a module based on the provided spec.",
      "module": "importlib.util"
    },
    "spec_from_loader": {
      "signature": "(name, loader, *, origin=None, is_package=None)",
      "doc": "Return a module spec based on various loader methods.",
      "module": "importlib.util"
    },
    "cache_from_source": {
      "signature": "(path, debug_override=None, *, optimization=None)",
      "doc": "Given the path to a .py file, return the path to its .pyc file.",
      "module": "importlib.util"
    },
    "decode_source": {
      "signature": "(source_bytes)",
      "doc": "Decode bytes representing source code and return the string.",
      "module": "importlib.util"
    },
    "source_from_cache": {
      "signature": "(path)",
      "doc": "Given the path to a .pyc. file, return the path to its .py file.",
      "module": "importlib.util"
    },
    "spec_from_file_location": {
      "signature": "(name, location=None, *, loader=None, submodule_search_locations=<object object at 0x0000014D00B040F0>)",
      "doc": "Return a module spec based on a file location.",
      "module": "importlib.util"
    },
    "filterwarnings": {
      "signature": "(action, message='', category=<class 'Warning'>, module='', lineno=0, append=False)",
      "doc": "",
      "module": "warnings"
    },
    "formatwarning": {
      "signature": "(message, category, filename, lineno, line=None)",
      "doc": "",
      "module": "warnings"
    },
    "resetwarnings": {
      "signature": "()",
      "doc": "",
      "module": "warnings"
    },
    "showwarning": {
      "signature": "(message, category, filename, lineno, file=None, line=None)",
      "doc": "",
      "module": "warnings"
    },
    "simplefilter": {
      "signature": "(action, category=<class 'Warning'>, lineno=0, append=False)",
      "doc": "",
      "module": "warnings"
    },
    "find_loader": {
      "signature": "(fullname)",
      "doc": "",
      "module": "pkgutil"
    },
    "import_module": {
      "signature": "(name, package=None)",
      "doc": "",
      "module": "importlib"
    },
    "invalidate_caches": {
      "signature": "()",
      "doc": "",
      "module": "importlib"
    },
    "reload": {
      "signature": "(module)",
      "doc": "",
      "module": "importlib"
    },
    "all_suffixes": {
      "signature": "()",
      "doc": "Returns a list of all recognized module suffixes for this process",
      "module": "importlib.machinery"
    },
    "RLock": {
      "signature": "(*args, **kwargs)",
      "doc": "",
      "module": "threading"
    },
    "activeCount": {
      "signature": "()",
      "doc": "",
      "module": "threading"
    },
    "active_count": {
      "signature": "()",
      "doc": "",
      "module": "threading"
    },
    "currentThread": {
      "signature": "()",
      "doc": "",
      "module": "threading"
    },
    "current_thread": {
      "signature": "()",
      "doc": "",
      "module": "threading"
    },
    "enumerate": {
      "signature": "()",
      "doc": "",
      "module": "threading"
    },
    "getprofile": {
      "signature": "()",
      "doc": "",
      "module": "threading"
    },
    "gettrace": {
      "signature": "()",
      "doc": "",
      "module": "threading"
    },
    "main_thread": {
      "signature": "()",
      "doc": "",
      "module": "threading"
    },
    "setprofile": {
      "signature": "(func)",
      "doc": "",
      "module": "threading"
    },
    "settrace": {
      "signature": "(func)",
      "doc": "",
      "module": "threading"
    },
    "find_spec": {
      "signature": "(name, package=None)",
      "doc": "Return the spec for the specified module.",
      "module": "importlib.util"
    },
    "module_for_loader": {
      "signature": "(fxn)",
      "doc": "Decorator to handle selecting the proper module for loaders.",
      "module": "importlib.util"
    },
    "resolve_name": {
      "signature": "(name)",
      "doc": "",
      "module": "pkgutil"
    },
    "set_loader": {
      "signature": "(fxn)",
      "doc": "Set __loader__ on the returned module.",
      "module": "importlib.util"
    },
    "set_package": {
      "signature": "(fxn)",
      "doc": "Set __package__ on the returned module.",
      "module": "importlib.util"
    },
    "source_hash": {
      "signature": "(source_bytes)",
      "doc": "Return the hash of *source_bytes* as used in hash-based pyc files.",
      "module": "importlib.util"
    },
    "getsignal": {
      "signature": "(signalnum)",
      "doc": "Return the current action for the given signal.",
      "module": "signal"
    },
    "signal": {
      "signature": "(signalnum, handler)",
      "doc": "Set the action for the given signal.",
      "module": "signal"
    },
    "valid_signals": {
      "signature": "()",
      "doc": "Return a set of valid signal numbers on this platform.",
      "module": "signal"
    },
    "active_children": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing"
    },
    "current_process": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing"
    },
    "parent_process": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing"
    },
    "decode_long": {
      "signature": "(data)",
      "doc": "",
      "module": "pickle"
    },
    "encode_long": {
      "signature": "(x)",
      "doc": "",
      "module": "pickle"
    },
    "whichmodule": {
      "signature": "(obj, name)",
      "doc": "",
      "module": "pickle"
    },
    "create_connection": {
      "signature": "(address, timeout=<object object at 0x0000014D00B04400>, source_address=None, *, all_errors=False)",
      "doc": "",
      "module": "ssl"
    },
    "create_server": {
      "signature": "(address, *, family=<AddressFamily.AF_INET: 2>, backlog=None, reuse_port=False, dualstack_ipv6=False)",
      "doc": "",
      "module": "socket"
    },
    "fromfd": {
      "signature": "(fd, family, type, proto=0)",
      "doc": "",
      "module": "socket"
    },
    "fromshare": {
      "signature": "(info)",
      "doc": "",
      "module": "socket"
    },
    "getaddrinfo": {
      "signature": "(host, port, family=0, type=0, proto=0, flags=0)",
      "doc": "",
      "module": "socket"
    },
    "getfqdn": {
      "signature": "(name='')",
      "doc": "",
      "module": "socket"
    },
    "has_dualstack_ipv6": {
      "signature": "()",
      "doc": "",
      "module": "socket"
    },
    "socketpair": {
      "signature": "(family=<AddressFamily.AF_INET: 2>, type=<SocketKind.SOCK_STREAM: 1>, proto=0)",
      "doc": "socketpair([family[, type[, proto]]]) -> (socket object, socket object)",
      "module": "socket"
    },
    "dump": {
      "signature": "(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)",
      "doc": "",
      "module": "json"
    },
    "duplicate": {
      "signature": "(handle, target_process=None, inheritable=False, *, source_process=None)",
      "doc": "",
      "module": "multiprocessing.reduction"
    },
    "recv_handle": {
      "signature": "(conn)",
      "doc": "",
      "module": "multiprocessing.reduction"
    },
    "send_handle": {
      "signature": "(conn, handle, destination_pid)",
      "doc": "",
      "module": "multiprocessing.reduction"
    },
    "steal_handle": {
      "signature": "(source_pid, handle)",
      "doc": "",
      "module": "multiprocessing.reduction"
    },
    "assert_spawning": {
      "signature": "(obj)",
      "doc": "",
      "module": "multiprocessing.context"
    },
    "get_spawning_popen": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing.context"
    },
    "set_spawning_popen": {
      "signature": "(popen)",
      "doc": "",
      "module": "multiprocessing.context"
    },
    "NamedTuple": {
      "signature": "(typename, fields=<sentinel>, /, **kwargs)",
      "doc": "",
      "module": "typing_extensions"
    },
    "TypedDict": {
      "signature": "(typename, fields=None, /, *, total=True, **kwargs)",
      "doc": "",
      "module": "eudplib.ctrlstru.simpleblock"
    },
    "assert_never": {
      "signature": "(arg: Never, /) -> Never",
      "doc": "",
      "module": "typing_extensions"
    },
    "assert_type": {
      "signature": "(val, typ, /)",
      "doc": "",
      "module": "typing_extensions"
    },
    "cast": {
      "signature": "(typ, val)",
      "doc": "",
      "module": "eudplib.scdata.cunit"
    },
    "clear_overloads": {
      "signature": "()",
      "doc": "",
      "module": "typing_extensions"
    },
    "dataclass_transform": {
      "signature": "(*, eq_default: bool = True, order_default: bool = False, kw_only_default: bool = False, frozen_default: bool = False, field_specifiers: Tuple[Union[Type[Any], Callable[..., Any]], ...] = (), **kwargs: Any) -> Callable[[~T], ~T]",
      "doc": "",
      "module": "typing_extensions"
    },
    "final": {
      "signature": "(f)",
      "doc": "",
      "module": "typing_extensions"
    },
    "get_args": {
      "signature": "(tp)",
      "doc": "",
      "module": "typing_extensions"
    },
    "get_origin": {
      "signature": "(tp)",
      "doc": "",
      "module": "typing_extensions"
    },
    "get_overloads": {
      "signature": "(func)",
      "doc": "",
      "module": "typing_extensions"
    },
    "get_type_hints": {
      "signature": "(obj, globalns=None, localns=None, include_extras=False)",
      "doc": "",
      "module": "typing_extensions"
    },
    "is_typeddict": {
      "signature": "(tp)",
      "doc": "",
      "module": "typing_extensions"
    },
    "no_type_check": {
      "signature": "(arg)",
      "doc": "",
      "module": "typing_extensions"
    },
    "no_type_check_decorator": {
      "signature": "(decorator)",
      "doc": "",
      "module": "typing_extensions"
    },
    "overload": {
      "signature": "(func)",
      "doc": "",
      "module": "eudplib.eudlib.locf.locf"
    },
    "reveal_type": {
      "signature": "(obj: ~T, /) -> ~T",
      "doc": "",
      "module": "typing_extensions"
    },
    "runtime_checkable": {
      "signature": "(cls)",
      "doc": "",
      "module": "typing_extensions"
    },
    "b2i1": {
      "signature": "(b: collections.abc.Sequence[int], index: int = 0) -> int",
      "doc": "",
      "module": "freeze.freeze"
    },
    "b2i2": {
      "signature": "(b: collections.abc.Sequence[int], index: int = 0) -> int",
      "doc": "",
      "module": "freeze.freeze"
    },
    "b2i4": {
      "signature": "(b: collections.abc.Sequence[int], index: int = 0) -> int",
      "doc": "",
      "module": "freeze.freeze"
    },
    "bits": {
      "signature": "(n: int) -> collections.abc.Iterator[int]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "i2b1": {
      "signature": "(i: int) -> bytes",
      "doc": "",
      "module": "freeze.freeze"
    },
    "i2b2": {
      "signature": "(i: int) -> bytes",
      "doc": "",
      "module": "freeze.freeze"
    },
    "i2b4": {
      "signature": "(i: int) -> bytes",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Catalog": {
      "signature": "(domain, localedir=None, languages=None, class_=None, fallback=False)",
      "doc": "",
      "module": "gettext"
    },
    "bindtextdomain": {
      "signature": "(domain, localedir=None)",
      "doc": "",
      "module": "gettext"
    },
    "c2py": {
      "signature": "(plural)",
      "doc": "",
      "module": "gettext"
    },
    "dgettext": {
      "signature": "(domain, message)",
      "doc": "",
      "module": "gettext"
    },
    "dngettext": {
      "signature": "(domain, msgid1, msgid2, n)",
      "doc": "",
      "module": "gettext"
    },
    "dnpgettext": {
      "signature": "(domain, context, msgid1, msgid2, n)",
      "doc": "",
      "module": "gettext"
    },
    "dpgettext": {
      "signature": "(domain, context, message)",
      "doc": "",
      "module": "gettext"
    },
    "find": {
      "signature": "(domain, localedir=None, languages=None, all=False)",
      "doc": "",
      "module": "gettext"
    },
    "gettext": {
      "signature": "(message)",
      "doc": "",
      "module": "gettext"
    },
    "install": {
      "signature": "(domain, localedir=None, *, names=None)",
      "doc": "",
      "module": "gettext"
    },
    "ngettext": {
      "signature": "(msgid1, msgid2, n)",
      "doc": "",
      "module": "gettext"
    },
    "npgettext": {
      "signature": "(context, msgid1, msgid2, n)",
      "doc": "",
      "module": "gettext"
    },
    "pgettext": {
      "signature": "(context, message)",
      "doc": "",
      "module": "gettext"
    },
    "textdomain": {
      "signature": "(domain=None)",
      "doc": "",
      "module": "gettext"
    },
    "translation": {
      "signature": "(domain, localedir=None, languages=None, class_=None, fallback=False)",
      "doc": "",
      "module": "gettext"
    },
    "atof": {
      "signature": "(string, func=<class 'float'>)",
      "doc": "",
      "module": "locale"
    },
    "atoi": {
      "signature": "(string)",
      "doc": "",
      "module": "locale"
    },
    "currency": {
      "signature": "(val, symbol=True, grouping=False, international=False)",
      "doc": "",
      "module": "locale"
    },
    "delocalize": {
      "signature": "(string)",
      "doc": "",
      "module": "locale"
    },
    "format": {
      "signature": "(cols, colwidth=20, spacing=6)",
      "doc": "",
      "module": "calendar"
    },
    "format_string": {
      "signature": "(f, val, grouping=False, monetary=False)",
      "doc": "",
      "module": "locale"
    },
    "getdefaultlocale": {
      "signature": "(envvars=('LC_ALL', 'LC_CTYPE', 'LANG', 'LANGUAGE'))",
      "doc": "",
      "module": "locale"
    },
    "getlocale": {
      "signature": "(category=2)",
      "doc": "",
      "module": "locale"
    },
    "getpreferredencoding": {
      "signature": "(do_setlocale=True)",
      "doc": "",
      "module": "locale"
    },
    "localeconv": {
      "signature": "()",
      "doc": "Returns numeric and monetary locale-specific parameters.",
      "module": "locale"
    },
    "localize": {
      "signature": "(string, grouping=False, monetary=False)",
      "doc": "",
      "module": "locale"
    },
    "normalize": {
      "signature": "(localename)",
      "doc": "",
      "module": "locale"
    },
    "resetlocale": {
      "signature": "(category=0)",
      "doc": "",
      "module": "locale"
    },
    "setlocale": {
      "signature": "(category, locale=None)",
      "doc": "",
      "module": "locale"
    },
    "str": {
      "signature": "(val)",
      "doc": "",
      "module": "locale"
    },
    "ep_assert": {
      "signature": "(statement: object, message: object = 'Assertion failed') -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "ep_eprint": {
      "signature": "(*args: object, **kwargs) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "ep_warn": {
      "signature": "(message: str) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDCreateBlock": {
      "signature": "(name: str, userdata: Any) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDGetBlockList": {
      "signature": "() -> list[tuple[str, typing.Any]]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDGetLastBlock": {
      "signature": "() -> tuple[str, typing.Any]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDGetLastBlockOfName": {
      "signature": "(name: str) -> tuple[str, typing.Any]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDPeekBlock": {
      "signature": "(name: str) -> tuple[str, typing.Any]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDPopBlock": {
      "signature": "(name: str) -> tuple[str, typing.Any]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "set_blockstru_manager": {
      "signature": "(bsm: eudplib.utils.blockstru.BlockStruManager) -> eudplib.utils.blockstru.BlockStruManager",
      "doc": "",
      "module": "eudplib.maprw.injector.apply_injector"
    },
    "isUnproxyInstance": {
      "signature": "(x: object, cls: type | types.UnionType | tuple['_ClassInfo', ...]) -> bool",
      "doc": "",
      "module": "freeze.freeze"
    },
    "unProxy": {
      "signature": "(x)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Assignable2List": {
      "signature": "(a: Any) -> list",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EPD": {
      "signature": "(p: Any, **kwargs) -> Any",
      "doc": "",
      "module": "freeze.freeze"
    },
    "FlattenIter": {
      "signature": "(lst: Any) -> collections.abc.Iterator",
      "doc": "",
      "module": "freeze.freeze"
    },
    "FlattenList": {
      "signature": "(lst: Any, ret=None) -> list",
      "doc": "",
      "module": "freeze.freeze"
    },
    "List2Assignable": {
      "signature": "(lst: collections.abc.Sequence[~T]) -> Union[~T, collections.abc.Sequence[~T]]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SCMD2Text": {
      "signature": "(s: str) -> str",
      "doc": "",
      "module": "freeze.freeze"
    },
    "cachedfunc": {
      "signature": "(user_function, /)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "find_data_file": {
      "signature": "(filename, file) -> str | bytes",
      "doc": "",
      "module": "freeze.freeze"
    },
    "b2u": {
      "signature": "(b: str | bytes) -> str",
      "doc": "",
      "module": "freeze.freeze"
    },
    "b2utf8": {
      "signature": "(b: str | bytes) -> str",
      "doc": "",
      "module": "freeze.freeze"
    },
    "u2b": {
      "signature": "(s: str | bytes) -> bytes",
      "doc": "",
      "module": "freeze.freeze"
    },
    "u2utf8": {
      "signature": "(s: str | bytes) -> bytes",
      "doc": "",
      "module": "freeze.freeze"
    },
    "CompressPayload": {
      "signature": "(mode: 'bool') -> 'None'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "CreatePayload": {
      "signature": "(root: 'EUDObject | Forward') -> 'Payload'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "GetObjectAddr": {
      "signature": "(obj: 'EUDObject') -> 'RlocInt_C'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "ShufflePayload": {
      "signature": "(mode: 'bool') -> 'None'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "lprint": {
      "signature": "(text: 'str', flush: 'bool' = False)",
      "doc": "",
      "module": "eudplib.core.allocator.payload"
    },
    "copy_location": {
      "signature": "(new_node, old_node)",
      "doc": "",
      "module": "ast"
    },
    "fix_missing_locations": {
      "signature": "(node)",
      "doc": "",
      "module": "ast"
    },
    "get_docstring": {
      "signature": "(node, clean=True)",
      "doc": "",
      "module": "ast"
    },
    "get_source_segment": {
      "signature": "(source, node, *, padded=False)",
      "doc": "",
      "module": "ast"
    },
    "increment_lineno": {
      "signature": "(node, n=1)",
      "doc": "",
      "module": "ast"
    },
    "iter_child_nodes": {
      "signature": "(node)",
      "doc": "",
      "module": "ast"
    },
    "iter_fields": {
      "signature": "(node)",
      "doc": "",
      "module": "ast"
    },
    "literal_eval": {
      "signature": "(node_or_string)",
      "doc": "",
      "module": "ast"
    },
    "main": {
      "signature": "()",
      "doc": "",
      "module": "main"
    },
    "unparse": {
      "signature": "(ast_obj)",
      "doc": "",
      "module": "ast"
    },
    "code_info": {
      "signature": "(x)",
      "doc": "",
      "module": "dis"
    },
    "disassemble": {
      "signature": "(co, lasti=-1, *, file=None, show_caches=False, adaptive=False)",
      "doc": "",
      "module": "dis"
    },
    "disco": {
      "signature": "(co, lasti=-1, *, file=None, show_caches=False, adaptive=False)",
      "doc": "",
      "module": "dis"
    },
    "distb": {
      "signature": "(tb=None, *, file=None, show_caches=False, adaptive=False)",
      "doc": "",
      "module": "dis"
    },
    "findlabels": {
      "signature": "(code)",
      "doc": "",
      "module": "dis"
    },
    "findlinestarts": {
      "signature": "(code)",
      "doc": "",
      "module": "dis"
    },
    "get_instructions": {
      "signature": "(x, *, first_line=None, show_caches=False, adaptive=False)",
      "doc": "",
      "module": "eudplib.epscript.linetable_calculator"
    },
    "pretty_flags": {
      "signature": "(flags)",
      "doc": "",
      "module": "dis"
    },
    "show_code": {
      "signature": "(co, *, file=None)",
      "doc": "",
      "module": "dis"
    },
    "ISEOF": {
      "signature": "(x)",
      "doc": "",
      "module": "tokenize"
    },
    "ISNONTERMINAL": {
      "signature": "(x)",
      "doc": "",
      "module": "tokenize"
    },
    "ISTERMINAL": {
      "signature": "(x)",
      "doc": "",
      "module": "tokenize"
    },
    "any": {
      "signature": "(*choices)",
      "doc": "",
      "module": "tokenize"
    },
    "detect_encoding": {
      "signature": "(b)",
      "doc": "",
      "module": "json"
    },
    "generate_tokens": {
      "signature": "(readline)",
      "doc": "",
      "module": "tokenize"
    },
    "group": {
      "signature": "(*choices)",
      "doc": "",
      "module": "tokenize"
    },
    "maybe": {
      "signature": "(*choices)",
      "doc": "",
      "module": "tokenize"
    },
    "tokenize": {
      "signature": "(readline)",
      "doc": "",
      "module": "tokenize"
    },
    "untokenize": {
      "signature": "(iterable)",
      "doc": "",
      "module": "tokenize"
    },
    "checkcache": {
      "signature": "(filename=None)",
      "doc": "",
      "module": "linecache"
    },
    "clearcache": {
      "signature": "()",
      "doc": "",
      "module": "linecache"
    },
    "getline": {
      "signature": "(filename, lineno, module_globals=None)",
      "doc": "",
      "module": "linecache"
    },
    "getlines": {
      "signature": "(filename, module_globals=None)",
      "doc": "",
      "module": "linecache"
    },
    "lazycache": {
      "signature": "(filename, module_globals)",
      "doc": "",
      "module": "linecache"
    },
    "updatecache": {
      "signature": "(filename, module_globals=None)",
      "doc": "",
      "module": "linecache"
    },
    "classify_class_attrs": {
      "signature": "(cls)",
      "doc": "",
      "module": "inspect"
    },
    "cleandoc": {
      "signature": "(doc)",
      "doc": "",
      "module": "inspect"
    },
    "currentframe": {
      "signature": "()",
      "doc": "",
      "module": "inspect"
    },
    "findsource": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "formatannotation": {
      "signature": "(annotation, base_module=None)",
      "doc": "",
      "module": "inspect"
    },
    "formatannotationrelativeto": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "formatargvalues": {
      "signature": "(args, varargs, varkw, locals, formatarg=<class 'str'>, formatvarargs=<function <lambda> at 0x0000014D02C69080>, formatvarkw=<function <lambda> at 0x0000014D02C69120>, formatvalue=<function <lambda> at 0x0000014D02C691C0>)",
      "doc": "",
      "module": "inspect"
    },
    "get_annotations": {
      "signature": "(obj, *, globals=None, locals=None, eval_str=False)",
      "doc": "",
      "module": "inspect"
    },
    "getabsfile": {
      "signature": "(object, _filename=None)",
      "doc": "",
      "module": "inspect"
    },
    "getargs": {
      "signature": "(co)",
      "doc": "",
      "module": "inspect"
    },
    "getargvalues": {
      "signature": "(frame)",
      "doc": "",
      "module": "inspect"
    },
    "getattr_static": {
      "signature": "(obj, attr, default=<object object at 0x0000014D00B047B0>)",
      "doc": "",
      "module": "inspect"
    },
    "getblock": {
      "signature": "(lines)",
      "doc": "",
      "module": "inspect"
    },
    "getcallargs": {
      "signature": "(func, /, *positional, **named)",
      "doc": "",
      "module": "inspect"
    },
    "getclasstree": {
      "signature": "(classes, unique=False)",
      "doc": "",
      "module": "inspect"
    },
    "getclosurevars": {
      "signature": "(func)",
      "doc": "",
      "module": "inspect"
    },
    "getcomments": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "getcoroutinelocals": {
      "signature": "(coroutine)",
      "doc": "",
      "module": "inspect"
    },
    "getcoroutinestate": {
      "signature": "(coroutine)",
      "doc": "",
      "module": "inspect"
    },
    "getdoc": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "getfile": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "getframeinfo": {
      "signature": "(frame, context=1)",
      "doc": "",
      "module": "inspect"
    },
    "getfullargspec": {
      "signature": "(func)",
      "doc": "",
      "module": "inspect"
    },
    "getgeneratorlocals": {
      "signature": "(generator)",
      "doc": "",
      "module": "inspect"
    },
    "getgeneratorstate": {
      "signature": "(generator)",
      "doc": "",
      "module": "inspect"
    },
    "getinnerframes": {
      "signature": "(tb, context=1)",
      "doc": "",
      "module": "inspect"
    },
    "getlineno": {
      "signature": "(frame)",
      "doc": "",
      "module": "inspect"
    },
    "getmembers": {
      "signature": "(object, predicate=None)",
      "doc": "",
      "module": "inspect"
    },
    "getmembers_static": {
      "signature": "(object, predicate=None)",
      "doc": "",
      "module": "inspect"
    },
    "getmodule": {
      "signature": "(object, _filename=None)",
      "doc": "",
      "module": "inspect"
    },
    "getmodulename": {
      "signature": "(path)",
      "doc": "",
      "module": "inspect"
    },
    "getmro": {
      "signature": "(cls)",
      "doc": "",
      "module": "inspect"
    },
    "getouterframes": {
      "signature": "(frame, context=1)",
      "doc": "",
      "module": "inspect"
    },
    "getsource": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "getsourcefile": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "getsourcelines": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "indentsize": {
      "signature": "(line)",
      "doc": "",
      "module": "inspect"
    },
    "isabstract": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "isasyncgen": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "isasyncgenfunction": {
      "signature": "(obj)",
      "doc": "",
      "module": "inspect"
    },
    "isawaitable": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "isbuiltin": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "isclass": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "iscode": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "iscoroutine": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "iscoroutinefunction": {
      "signature": "(obj)",
      "doc": "",
      "module": "inspect"
    },
    "isdatadescriptor": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "isframe": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "isfunction": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "isgenerator": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "isgeneratorfunction": {
      "signature": "(obj)",
      "doc": "",
      "module": "inspect"
    },
    "isgetsetdescriptor": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "ismemberdescriptor": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "ismethod": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "ismethoddescriptor": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "ismethodwrapper": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "ismodule": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "isroutine": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "istraceback": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "signature": {
      "signature": "(obj, *, follow_wrapped=True, globals=None, locals=None, eval_str=False)",
      "doc": "",
      "module": "inspect"
    },
    "stack": {
      "signature": "(context=1)",
      "doc": "",
      "module": "inspect"
    },
    "trace": {
      "signature": "(context=1)",
      "doc": "",
      "module": "inspect"
    },
    "unwrap": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.request"
    },
    "walktree": {
      "signature": "(classes, children, parent)",
      "doc": "",
      "module": "inspect"
    },
    "IntVar": {
      "signature": "(name)",
      "doc": "",
      "module": "typing_extensions"
    },
    "get_original_bases": {
      "signature": "(cls, /)",
      "doc": "",
      "module": "typing_extensions"
    },
    "get_protocol_members": {
      "signature": "(tp: type, /) -> FrozenSet[str]",
      "doc": "",
      "module": "typing_extensions"
    },
    "is_protocol": {
      "signature": "(tp: type, /) -> bool",
      "doc": "",
      "module": "typing_extensions"
    },
    "override": {
      "signature": "(arg: ~_F, /) -> ~_F",
      "doc": "",
      "module": "typing_extensions"
    },
    "runtime": {
      "signature": "(cls)",
      "doc": "",
      "module": "typing_extensions"
    },
    "sectionname_format": {
      "signature": "(sn: 'str | bytes') -> 'bytes'",
      "doc": "",
      "module": "eudplib.core.mapdata.chktok"
    },
    "GetPlayerInfo": {
      "signature": "(player) -> eudplib.core.mapdata.playerinfo.PlayerInfo",
      "doc": "",
      "module": "freeze.freeze"
    },
    "init_player_info": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "ARRAY": {
      "signature": "(typ, len)",
      "doc": "",
      "module": "ctypes"
    },
    "CFUNCTYPE": {
      "signature": "(restype, *argtypes, **kw)",
      "doc": "",
      "module": "ctypes"
    },
    "DllCanUnloadNow": {
      "signature": "()",
      "doc": "",
      "module": "ctypes"
    },
    "DllGetClassObject": {
      "signature": "(rclsid, riid, ppv)",
      "doc": "",
      "module": "ctypes"
    },
    "PYFUNCTYPE": {
      "signature": "(restype, *argtypes)",
      "doc": "",
      "module": "ctypes"
    },
    "SetPointerType": {
      "signature": "(pointer, cls)",
      "doc": "",
      "module": "ctypes"
    },
    "WINFUNCTYPE": {
      "signature": "(restype, *argtypes, **kw)",
      "doc": "",
      "module": "msgbox"
    },
    "WinError": {
      "signature": "(code=None, descr=None)",
      "doc": "",
      "module": "ctypes"
    },
    "c_buffer": {
      "signature": "(init, size=None)",
      "doc": "",
      "module": "ctypes"
    },
    "create_string_buffer": {
      "signature": "(init, size=None)",
      "doc": "",
      "module": "ctypes"
    },
    "create_unicode_buffer": {
      "signature": "(init, size=None)",
      "doc": "",
      "module": "ctypes"
    },
    "string_at": {
      "signature": "(ptr, size=-1)",
      "doc": "",
      "module": "ctypes"
    },
    "wstring_at": {
      "signature": "(ptr, size=-1)",
      "doc": "",
      "module": "ctypes"
    },
    "property_key": {
      "signature": "(b: bytes, index: int = 0) -> bytes",
      "doc": "",
      "module": "eudplib.core.mapdata.proptable"
    },
    "GetPropertyIndex": {
      "signature": "(prop: eudplib.core.mapdata.unitprp.UnitProperty | bytes) -> int",
      "doc": "",
      "module": "freeze.freeze"
    },
    "apply_property_map": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "init_property_map": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "DecodeUnitNameAs": {
      "signature": "(e: 'str') -> 'None'",
      "doc": "",
      "module": "eudplib.core.mapdata.tblformat"
    },
    "ForceAddString": {
      "signature": "(s: str | bytes) -> int",
      "doc": "",
      "module": "eudplib.string.strbuffer"
    },
    "GetLocationIndex": {
      "signature": "(loc: str | bytes) -> int",
      "doc": "",
      "module": "freeze.freeze"
    },
    "GetStringIndex": {
      "signature": "(s: str | bytes) -> int",
      "doc": "",
      "module": "freeze.freeze"
    },
    "GetSwitchIndex": {
      "signature": "(s: str | bytes) -> int",
      "doc": "",
      "module": "freeze.freeze"
    },
    "GetUnitIndex": {
      "signature": "(u: str | bytes) -> int",
      "doc": "",
      "module": "freeze.freeze"
    },
    "apply_string_map": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "get_string_map": {
      "signature": "() -> eudplib.core.mapdata.tblformat.TBL",
      "doc": "",
      "module": "eudplib.maprw.injector.vector_reloc"
    },
    "get_string_section_name": {
      "signature": "() -> str",
      "doc": "",
      "module": "eudplib.string.cpstr"
    },
    "init_stringmaps": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "GetChkTokenized": {
      "signature": "() -> eudplib.core.mapdata.chktok.CHK",
      "doc": "",
      "module": "freeze.freeze"
    },
    "GetOriginalChkTokenized": {
      "signature": "() -> eudplib.core.mapdata.chktok.CHK",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "GetRawFile": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "IsMapdataInitialized": {
      "signature": "() -> bool",
      "doc": "",
      "module": "freeze.freeze"
    },
    "init_map_data": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK, rawfile: bytes) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "update_map_data": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "EncodeAllyStatus": {
      "signature": "(s: 'ConstType | int | EUDVariable | ExprProxy[ConstType | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeComparison": {
      "signature": "(s: 'ConstType | int | EUDVariable | ExprProxy[ConstType | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeCount": {
      "signature": "(s: 'ConstType | int | EUDVariable | ExprProxy[ConstType | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeModifier": {
      "signature": "(s: 'ConstType | int | EUDVariable | ExprProxy[ConstType | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeOrder": {
      "signature": "(s: 'ConstType | int | EUDVariable | ExprProxy[ConstType | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodePlayer": {
      "signature": "(s: 'ConstType | int | EUDVariable | ConstExpr | ExprProxy[ConstType | int | EUDVariable | ConstExpr | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable | ConstExpr'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodePropState": {
      "signature": "(s: 'ConstType | int | EUDVariable | ExprProxy[ConstType | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeProperty": {
      "signature": "(prop: Union[eudplib.core.mapdata.unitprp.UnitProperty, bytes, eudplib.utils.exprproxy.ExprProxy[eudplib.core.mapdata.unitprp.UnitProperty | bytes]], issueError: bool = False) -> int",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeResource": {
      "signature": "(s: 'ConstType | int | EUDVariable | ExprProxy[ConstType | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeScore": {
      "signature": "(s: 'ConstType | int | EUDVariable | ExprProxy[ConstType | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeSwitchAction": {
      "signature": "(s: 'ConstType | int | EUDVariable | ExprProxy[ConstType | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeSwitchState": {
      "signature": "(s: 'ConstType | int | EUDVariable | ExprProxy[ConstType | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "NextTrigger": {
      "signature": "() -> eudplib.core.allocator.Forward",
      "doc": "",
      "module": "freeze.freeze"
    },
    "PopTriggerScope": {
      "signature": "() -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "PushTriggerScope": {
      "signature": "() -> Literal[True]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetNextTrigger": {
      "signature": "(trg: eudplib.core.allocator.ConstExpr) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Disabled": {
      "signature": "(arg: eudplib.core.rawtrigger.condition.Condition | eudplib.core.rawtrigger.action.Action) -> eudplib.core.rawtrigger.condition.Condition | eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "GetTriggerCounter": {
      "signature": "() -> int",
      "doc": "",
      "module": "freeze.freeze"
    },
    "merge": {
      "signature": "(*iterables, key=None, reverse=False)",
      "doc": "",
      "module": "heapq"
    },
    "nlargest": {
      "signature": "(n, iterable, key=None)",
      "doc": "",
      "module": "heapq"
    },
    "nsmallest": {
      "signature": "(n, iterable, key=None)",
      "doc": "",
      "module": "heapq"
    },
    "IS_CHARACTER_JUNK": {
      "signature": "(ch, ws=' \\t')",
      "doc": "",
      "module": "difflib"
    },
    "IS_LINE_JUNK": {
      "signature": "(line, pat=<built-in method match of re.Pattern object at 0x0000014D013A1C40>)",
      "doc": "",
      "module": "difflib"
    },
    "context_diff": {
      "signature": "(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\\n')",
      "doc": "",
      "module": "difflib"
    },
    "diff_bytes": {
      "signature": "(dfunc, a, b, fromfile=b'', tofile=b'', fromfiledate=b'', tofiledate=b'', n=3, lineterm=b'\\n')",
      "doc": "",
      "module": "difflib"
    },
    "get_close_matches": {
      "signature": "(word, possibilities, n=3, cutoff=0.6)",
      "doc": "",
      "module": "difflib"
    },
    "ndiff": {
      "signature": "(a, b, linejunk=None, charjunk=<function IS_CHARACTER_JUNK at 0x0000014D02D00F40>)",
      "doc": "",
      "module": "difflib"
    },
    "restore": {
      "signature": "(delta, which)",
      "doc": "",
      "module": "difflib"
    },
    "unified_diff": {
      "signature": "(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\\n')",
      "doc": "",
      "module": "difflib"
    },
    "EncodeAIScript": {
      "signature": "(ais: 'str | bytes | int | EUDVariable | ConstExpr | ExprProxy[str | bytes | int | EUDVariable | ConstExpr | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable | ConstExpr'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeFlingy": {
      "signature": "(flingy: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeIcon": {
      "signature": "(icon: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeImage": {
      "signature": "(image: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeIscript": {
      "signature": "(iscript: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeLocation": {
      "signature": "(loc: 'str | bytes | int | EUDVariable | ConstExpr | ExprProxy[str | bytes | int | EUDVariable | ConstExpr | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable | ConstExpr'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodePortrait": {
      "signature": "(portrait: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeSprite": {
      "signature": "(sprite: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeString": {
      "signature": "(s: 'str | bytes | int | EUDVariable | ConstExpr | ExprProxy[str | bytes | int | EUDVariable | ConstExpr | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable | ConstExpr'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeSwitch": {
      "signature": "(sw: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeTBL": {
      "signature": "(t: 'str | bytes | int | EUDVariable | ConstExpr | ExprProxy[str | bytes | int | EUDVariable | ConstExpr | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable | ConstExpr'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeTech": {
      "signature": "(tech: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeUnit": {
      "signature": "(u: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeUnitOrder": {
      "signature": "(order: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeUpgrade": {
      "signature": "(upgrade: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EncodeWeapon": {
      "signature": "(weapon: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "CenterView": {
      "signature": "(where: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Comment": {
      "signature": "(text: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "CreateUnit": {
      "signature": "(number: 'int | EUDVariable | ExprProxy[int] | ExprProxy[EUDVariable]', unit: 'str | Word | bytes', where: 'str | Dword | bytes', for_player: '_Player | Dword') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "CreateUnitWithProperties": {
      "signature": "(count: 'int | EUDVariable | ExprProxy[int] | ExprProxy[EUDVariable]', unit: 'str | Word | bytes', where: 'str | Dword | bytes', player: '_Player | Dword', properties: eudplib.core.mapdata.unitprp.UnitProperty | bytes) -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Defeat": {
      "signature": "() -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "DisplayText": {
      "signature": "(text: 'str | Dword | bytes', AlwaysDisplay: 'int | EUDVariable | ExprProxy[int] | ExprProxy[EUDVariable]' = 4) -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Draw": {
      "signature": "() -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "GiveUnits": {
      "signature": "(count: 'TrgCount | Byte', unit: 'str | Word | bytes', owner: '_Player | Dword', where: 'str | Dword | bytes', new_owner: '_Player | Dword') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "KillUnit": {
      "signature": "(unit: 'str | Word | bytes', player: '_Player | Dword') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "KillUnitAt": {
      "signature": "(count: 'TrgCount | Byte', unit: 'str | Word | bytes', where: 'str | Dword | bytes', for_player: '_Player | Dword') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LeaderBoardComputerPlayers": {
      "signature": "(state: 'TrgPropState | Byte') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LeaderBoardControl": {
      "signature": "(unit: 'str | Word | bytes', label: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LeaderBoardControlAt": {
      "signature": "(unit: 'str | Word | bytes', location: 'str | Dword | bytes', label: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LeaderBoardGoalControl": {
      "signature": "(goal: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', unit: 'str | Word | bytes', label: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LeaderBoardGoalControlAt": {
      "signature": "(goal: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', unit: 'str | Word | bytes', location: 'str | Dword | bytes', label: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LeaderBoardGoalKills": {
      "signature": "(goal: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', unit: 'str | Word | bytes', label: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LeaderBoardGoalResources": {
      "signature": "(goal: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', resource_type: 'TrgResource | Byte', label: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LeaderBoardGoalScore": {
      "signature": "(goal: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', ScoreType: 'TrgScore | Byte', label: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LeaderBoardGreed": {
      "signature": "(goal: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LeaderBoardKills": {
      "signature": "(unit: 'str | Word | bytes', label: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LeaderBoardResources": {
      "signature": "(resource_type: 'TrgResource | Byte', label: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LeaderBoardScore": {
      "signature": "(ScoreType: 'TrgScore | Byte', label: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "MinimapPing": {
      "signature": "(where: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "ModifyUnitEnergy": {
      "signature": "(count: 'TrgCount | Byte', unit: 'str | Word | bytes', owner: '_Player | Dword', where: 'str | Dword | bytes', percent: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "ModifyUnitHangarCount": {
      "signature": "(add: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', count: 'TrgCount | Byte', unit: 'str | Word | bytes', owner: '_Player | Dword', where: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "ModifyUnitHitPoints": {
      "signature": "(count: 'TrgCount | Byte', unit: 'str | Word | bytes', owner: '_Player | Dword', where: 'str | Dword | bytes', percent: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "ModifyUnitResourceAmount": {
      "signature": "(count: 'TrgCount | Byte', owner: '_Player | Dword', where: 'str | Dword | bytes', new_value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "ModifyUnitShields": {
      "signature": "(count: 'TrgCount | Byte', unit: 'str | Word | bytes', owner: '_Player | Dword', where: 'str | Dword | bytes', percent: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "MoveLocation": {
      "signature": "(location: 'str | Dword | bytes', on_unit: 'str | Word | bytes', owner: '_Player | Dword', dest_location: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "MoveUnit": {
      "signature": "(count: 'TrgCount | Byte', unit_type: 'str | Word | bytes', owner: '_Player | Dword', start_location: 'str | Dword | bytes', dest_location: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "MuteUnitSpeech": {
      "signature": "() -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Order": {
      "signature": "(unit: 'str | Word | bytes', owner: '_Player | Dword', start_location: 'str | Dword | bytes', order_type: 'TrgOrder | Byte', dest_location: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "PauseGame": {
      "signature": "() -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "PauseTimer": {
      "signature": "() -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "PlayWAV": {
      "signature": "(sound_name: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "PreserveTrigger": {
      "signature": "() -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "RemoveUnit": {
      "signature": "(unit: 'str | Word | bytes', player: '_Player | Dword') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "RemoveUnitAt": {
      "signature": "(count: 'TrgCount | Byte', unit: 'str | Word | bytes', where: 'str | Dword | bytes', for_player: '_Player | Dword') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "RunAIScript": {
      "signature": "(script: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "RunAIScriptAt": {
      "signature": "(script: 'str | Dword | bytes', where: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetAllianceStatus": {
      "signature": "(player: '_Player | Dword', status: 'TrgAllyStatus | Byte') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetCountdownTimer": {
      "signature": "(time_modifier: 'TrgModifier | Byte', time: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetDeaths": {
      "signature": "(player: '_Player | Dword', modifier: 'TrgModifier | Byte', number: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', unit: 'str | Word | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetDeathsX": {
      "signature": "(player: '_Player | Dword', modifier: 'TrgModifier | Byte', number: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', unit: 'str | Word | bytes', mask: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetDoodadState": {
      "signature": "(state: 'TrgPropState | Byte', unit: 'str | Word | bytes', owner: '_Player | Dword', where: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetInvincibility": {
      "signature": "(state: 'TrgPropState | Byte', unit: 'str | Word | bytes', owner: '_Player | Dword', where: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetKills": {
      "signature": "(player: '_Player | Dword', modifier: 'TrgModifier | Byte', number: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', unit: 'str | Word | bytes') -> eudplib.core.rawtrigger.action.Action | tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetMemory": {
      "signature": "(dest: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', modtype: 'TrgModifier | Byte', value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetMemoryEPD": {
      "signature": "(dest: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', modtype: 'TrgModifier | Byte', value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetMemoryX": {
      "signature": "(dest: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', modtype: 'TrgModifier | Byte', value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', mask: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetMemoryXEPD": {
      "signature": "(epd: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', modtype: 'TrgModifier | Byte', value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', mask: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetMissionObjectives": {
      "signature": "(text: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetNextPtr": {
      "signature": "(trg: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', dest: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetNextScenario": {
      "signature": "(scenario_name: 'str | Dword | bytes') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetResources": {
      "signature": "(player: '_Player | Dword', modifier: 'TrgModifier | Byte', amount: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', resource_type: 'TrgResource | Byte') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetScore": {
      "signature": "(player: '_Player | Dword', modifier: 'TrgModifier | Byte', amount: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', ScoreType: 'TrgScore | Byte') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetSwitch": {
      "signature": "(switch: 'str | Byte | bytes', state: 'TrgSwitchAction | Byte') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "TalkingPortrait": {
      "signature": "(unit: 'str | Word | bytes', time: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Transmission": {
      "signature": "(unit: 'str | Word | bytes', where: 'str | Dword | bytes', sound_name: 'str | Dword | bytes', time_modifier: 'TrgModifier | Byte', time: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', text: 'str | Dword | bytes', AlwaysDisplay: 'int | EUDVariable | ExprProxy[int] | ExprProxy[EUDVariable]' = 4) -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "UnMuteUnitSpeech": {
      "signature": "() -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "UnpauseGame": {
      "signature": "() -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "UnpauseTimer": {
      "signature": "() -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Victory": {
      "signature": "() -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Wait": {
      "signature": "(time: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Accumulate": {
      "signature": "(player: '_Player | Dword', comparison: 'TrgComparison | Byte', number: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', resource_type: 'TrgResource | Byte') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Always": {
      "signature": "() -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Bring": {
      "signature": "(player: '_Player | Dword', comparison: 'TrgComparison | Byte', number: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', unit: 'str | Word | bytes', location: 'str | Dword | bytes') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Command": {
      "signature": "(player: '_Player | Dword', comparison: 'TrgComparison | Byte', number: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', unit: 'str | Word | bytes') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "CommandLeast": {
      "signature": "(unit: 'str | Word | bytes') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "CommandLeastAt": {
      "signature": "(unit: 'str | Word | bytes', location: 'str | Dword | bytes') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "CommandMost": {
      "signature": "(unit: 'str | Word | bytes') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "CommandMostAt": {
      "signature": "(unit: 'str | Word | bytes', location: 'str | Dword | bytes') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "CountdownTimer": {
      "signature": "(comparison: 'TrgComparison | Byte', time: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Deaths": {
      "signature": "(player: '_Player | Dword', comparison: 'TrgComparison | Byte', number: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', unit: 'str | Word | bytes') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "DeathsX": {
      "signature": "(player: '_Player | Dword', comparison: 'TrgComparison | Byte', number: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', unit: 'str | Word | bytes', mask: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "ElapsedTime": {
      "signature": "(comparison: 'TrgComparison | Byte', time: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "HighestScore": {
      "signature": "(ScoreType: 'TrgScore | Byte') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LeastKills": {
      "signature": "(unit: 'str | Word | bytes') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LeastResources": {
      "signature": "(resource_type: 'TrgResource | Byte') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "LowestScore": {
      "signature": "(ScoreType: 'TrgScore | Byte') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Memory": {
      "signature": "(dest: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', cmptype: 'TrgComparison | Byte', value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "MemoryEPD": {
      "signature": "(dest: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', cmptype: 'TrgComparison | Byte', value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "MemoryX": {
      "signature": "(dest: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', cmptype: 'TrgComparison | Byte', value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', mask: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "MemoryXEPD": {
      "signature": "(dest: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', cmptype: 'TrgComparison | Byte', value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', mask: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "MostKills": {
      "signature": "(unit: 'str | Word | bytes') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "MostResources": {
      "signature": "(resource_type: 'TrgResource | Byte') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Never": {
      "signature": "() -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Opponents": {
      "signature": "(player: '_Player | Dword', comparison: 'TrgComparison | Byte', number: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Score": {
      "signature": "(player: '_Player | Dword', ScoreType: 'TrgScore | Byte', comparison: 'TrgComparison | Byte', number: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Switch": {
      "signature": "(switch: 'str | Byte | bytes', state: 'TrgSwitchState | Byte') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "dedent": {
      "signature": "(text)",
      "doc": "",
      "module": "textwrap"
    },
    "fill": {
      "signature": "(text, width=70, **kwargs)",
      "doc": "",
      "module": "textwrap"
    },
    "indent": {
      "signature": "(text, prefix, predicate=None)",
      "doc": "",
      "module": "textwrap"
    },
    "shorten": {
      "signature": "(text, width, **kwargs)",
      "doc": "",
      "module": "textwrap"
    },
    "wrap": {
      "signature": "(text, width=70, **kwargs)",
      "doc": "",
      "module": "textwrap"
    },
    "clear_frames": {
      "signature": "(tb)",
      "doc": "",
      "module": "traceback"
    },
    "extract_stack": {
      "signature": "(f=None, limit=None)",
      "doc": "",
      "module": "traceback"
    },
    "extract_tb": {
      "signature": "(tb, limit=None)",
      "doc": "",
      "module": "traceback"
    },
    "format_exc": {
      "signature": "(limit=None, chain=True)",
      "doc": "",
      "module": "traceback"
    },
    "format_exception": {
      "signature": "(exc, /, value=<implicit>, tb=<implicit>, limit=None, chain=True)",
      "doc": "",
      "module": "traceback"
    },
    "format_exception_only": {
      "signature": "(exc, /, value=<implicit>)",
      "doc": "",
      "module": "traceback"
    },
    "format_list": {
      "signature": "(extracted_list)",
      "doc": "",
      "module": "traceback"
    },
    "format_stack": {
      "signature": "(f=None, limit=None)",
      "doc": "",
      "module": "traceback"
    },
    "format_tb": {
      "signature": "(tb, limit=None)",
      "doc": "",
      "module": "traceback"
    },
    "print_exc": {
      "signature": "(limit=None, file=None, chain=True)",
      "doc": "",
      "module": "traceback"
    },
    "print_exception": {
      "signature": "(exc, /, value=<implicit>, tb=<implicit>, limit=None, file=None, chain=True)",
      "doc": "",
      "module": "traceback"
    },
    "print_last": {
      "signature": "(limit=None, file=None, chain=True)",
      "doc": "",
      "module": "traceback"
    },
    "print_list": {
      "signature": "(extracted_list, file=None)",
      "doc": "",
      "module": "traceback"
    },
    "print_stack": {
      "signature": "(f=None, limit=None, file=None)",
      "doc": "",
      "module": "traceback"
    },
    "print_tb": {
      "signature": "(tb, limit=None, file=None)",
      "doc": "",
      "module": "traceback"
    },
    "walk_stack": {
      "signature": "(f)",
      "doc": "",
      "module": "traceback"
    },
    "walk_tb": {
      "signature": "(tb)",
      "doc": "",
      "module": "traceback"
    },
    "get_current_custom_varbuffer": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.core.eudstruct.vararray"
    },
    "get_current_varbuffer": {
      "signature": "() -> 'EUDVarBuffer | None'",
      "doc": "",
      "module": "eudplib.core.variable.eudv"
    },
    "EP_SetRValueStrictMode": {
      "signature": "(mode: 'bool') -> 'None'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDCreateVariables": {
      "signature": "(varn: 'int')",
      "doc": "",
      "module": "freeze.freeze"
    },
    "IsEUDVariable": {
      "signature": "(x: 'object') -> 'TypeGuard[EUDVariable]'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "NonSeqCompute": {
      "signature": "(assignpairs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SeqCompute": {
      "signature": "(assignpairs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetVariables": {
      "signature": "(srclist, dstlist, mdtlist=None) -> 'None'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "VProc": {
      "signature": "(v: 'EUDVariable | Sequence[EUDVariable]', actions) -> 'bt.RawTrigger'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "process_dest": {
      "signature": "(dest) -> 'int | ConstExpr'",
      "doc": "",
      "module": "eudplib.core.eudstruct.vararray"
    },
    "T": {
      "signature": "(x: int) -> int",
      "doc": "",
      "module": "eudplib.core.eudfunc.trace.tracecrypt"
    },
    "mix": {
      "signature": "(x: int, y: int) -> int",
      "doc": "",
      "module": "eudplib.core.eudfunc.trace.tracecrypt"
    },
    "EUDTraceLog": {
      "signature": "(lineno: int | None = None) -> None",
      "doc": "",
      "module": "eudplib.core.eudfunc"
    },
    "GetTraceStackDepth": {
      "signature": "() -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "eudplib.core.eudfunc"
    },
    "EUDReturn": {
      "signature": "(*args)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDFullFunc": {
      "signature": "(arginitvals, argtypes, rettypes=None, *, traced=False)",
      "doc": "",
      "module": "eudplib.string.strall"
    },
    "EUDFunc": {
      "signature": "(fdecl_func)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDTracedFunc": {
      "signature": "(fdecl_func)",
      "doc": "",
      "module": "eudplib.core.eudfunc"
    },
    "EUDTracedTypedFunc": {
      "signature": "(argtypes, rettypes=None)",
      "doc": "",
      "module": "eudplib.core.eudfunc"
    },
    "EUDTypedFunc": {
      "signature": "(argtypes, rettypes=None, *, traced=False)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDXTypedFunc": {
      "signature": "(argmasks, argtypes, rettypes=None, *, traced=False)",
      "doc": "",
      "module": "eudplib.core.eudfunc"
    },
    "AddCurrentPlayer": {
      "signature": "(p)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "GetCPCache": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.memio.memifgen"
    },
    "SetCurrentPlayer": {
      "signature": "(p)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "cpcache_match_cond": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.core.curpl"
    },
    "cpset": {
      "signature": "(a, b)",
      "doc": "",
      "module": "eudplib.core.inplacecw"
    },
    "iand": {
      "signature": "(a, b, v)",
      "doc": "",
      "module": "eudplib.collections.eudarray"
    },
    "ilshift": {
      "signature": "(a, b, n)",
      "doc": "",
      "module": "eudplib.collections.eudarray"
    },
    "ior": {
      "signature": "(a, b, v)",
      "doc": "",
      "module": "eudplib.collections.eudarray"
    },
    "irshift": {
      "signature": "(a, b, n)",
      "doc": "",
      "module": "eudplib.collections.eudarray"
    },
    "iset": {
      "signature": "(a, b, modifier, v)",
      "doc": "",
      "module": "eudplib.collections.eudarray"
    },
    "isub": {
      "signature": "(a, b, v)",
      "doc": "",
      "module": "eudplib.collections.eudarray"
    },
    "ixor": {
      "signature": "(a, b, v)",
      "doc": "",
      "module": "eudplib.collections.eudarray"
    },
    "EUDMethod": {
      "signature": "(method)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDTracedMethod": {
      "signature": "(method)",
      "doc": "",
      "module": "eudplib.core.eudfunc"
    },
    "EUDTracedTypedMethod": {
      "signature": "(argtypes, rettypes=None)",
      "doc": "",
      "module": "eudplib.core.eudfunc"
    },
    "EUDTypedMethod": {
      "signature": "(argtypes, rettypes=None, *, traced=False)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_div": {
      "signature": "(a, b, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_mul": {
      "signature": "(a, b, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bitand": {
      "signature": "(a, b)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bitlshift": {
      "signature": "(a, b, _fdict={2: <eudplib.core.eudfunc.eudtypedfuncn.EUDTypedFuncN object at 0x0000014D0332D8D0>}, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bitnand": {
      "signature": "(a, b)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bitnor": {
      "signature": "(a, b)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bitnot": {
      "signature": "(a)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bitnxor": {
      "signature": "(a, b)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bitor": {
      "signature": "(a, b)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bitrshift": {
      "signature": "(a, b, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bitxor": {
      "signature": "(a, b)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDFuncPtr": {
      "signature": "(argn, retn)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDTypedFuncPtr": {
      "signature": "(argtypes, rettypes)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDClearNamespace": {
      "signature": "() -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDRegisterObjectToNamespace": {
      "signature": "(funcname: str, obj: Any) -> Any",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDRegistered": {
      "signature": "(func)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "GetEUDNamespace": {
      "signature": "() -> dict[str, typing.Any]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "apply_patch_table": {
      "signature": "(initepd, obj, patch_table: list[list[int | None]]) -> None",
      "doc": "",
      "module": "eudplib.trigger.tpatcher"
    },
    "is_castable": {
      "signature": "(cond) -> bool",
      "doc": "",
      "module": "eudplib.trigger.tpatcher"
    },
    "is_const_cond": {
      "signature": "(cond) -> bool",
      "doc": "",
      "module": "eudplib.trigger.tpatcher"
    },
    "is_nagatable_cond": {
      "signature": "(cond) -> bool",
      "doc": "",
      "module": "eudplib.trigger.tpatcher"
    },
    "negate_cond": {
      "signature": "(cond: Union[eudplib.core.allocator.ConstExpr, bool, int, eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudlv.EUDLightVariable, eudplib.core.variable.eudlv.EUDLightBool, eudplib.utils.exprproxy.ExprProxy[bool | int | eudplib.core.variable.eudv.EUDVariable | eudplib.core.variable.eudlv.EUDLightVariable | eudplib.core.variable.eudlv.EUDLightBool], eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.ConstExpr]]) -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "eudplib.ctrlstru.logic"
    },
    "patch_action": {
      "signature": "(act: Union[eudplib.core.rawtrigger.action.Action, eudplib.core.allocator.Forward, eudplib.utils.exprproxy.ExprProxy[eudplib.core.rawtrigger.action.Action | eudplib.core.allocator.Forward]]) -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "eudplib.trigger.triggerdef"
    },
    "patch_condition": {
      "signature": "(cond: Union[eudplib.core.allocator.ConstExpr, bool, int, eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudlv.EUDLightVariable, eudplib.core.variable.eudlv.EUDLightBool, eudplib.utils.exprproxy.ExprProxy[bool | int | eudplib.core.variable.eudv.EUDVariable | eudplib.core.variable.eudlv.EUDLightVariable | eudplib.core.variable.eudlv.EUDLightBool], eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.ConstExpr]]) -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "eudplib.trigger.triggerdef"
    },
    "EUDBranch": {
      "signature": "(conditions: Union[eudplib.core.allocator.ConstExpr, bool, int, eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudlv.EUDLightVariable, eudplib.core.variable.eudlv.EUDLightBool, eudplib.utils.exprproxy.ExprProxy[bool | int | eudplib.core.variable.eudv.EUDVariable | eudplib.core.variable.eudlv.EUDLightVariable | eudplib.core.variable.eudlv.EUDLightBool], eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.ConstExpr], collections.abc.Iterable[Union[eudplib.core.allocator.ConstExpr, bool, int, eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudlv.EUDLightVariable, eudplib.core.variable.eudlv.EUDLightBool, eudplib.utils.exprproxy.ExprProxy[bool | int | eudplib.core.variable.eudv.EUDVariable | eudplib.core.variable.eudlv.EUDLightVariable | eudplib.core.variable.eudlv.EUDLightBool], eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.ConstExpr], collections.abc.Iterable]]], ontrue: eudplib.core.allocator.ConstExpr, onfalse: eudplib.core.allocator.ConstExpr, *, _actions: eudplib.core.rawtrigger.action.Action | collections.abc.Sequence[eudplib.core.rawtrigger.action.Action | collections.abc.Sequence] | None = None) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Trigger": {
      "signature": "(conditions: eudplib.core.rawtrigger.condition.Condition | bool | collections.abc.Iterable[eudplib.core.rawtrigger.condition.Condition | bool | collections.abc.Iterable | None] | None = None, actions: eudplib.core.rawtrigger.action.Action | collections.abc.Iterable[eudplib.core.rawtrigger.action.Action | collections.abc.Iterable | None] | None = None, preserved: bool = True) -> tuple[eudplib.core.allocator.Forward, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "PTrigger": {
      "signature": "(players: eudplib.core.rawtrigger.constenc._Player | int | collections.abc.Iterable[eudplib.core.rawtrigger.constenc._Player | int | collections.abc.Iterable], conditions: eudplib.core.rawtrigger.condition.Condition | bool | collections.abc.Iterable[eudplib.core.rawtrigger.condition.Condition | bool | collections.abc.Iterable | None] | None = None, actions: eudplib.core.rawtrigger.action.Action | collections.abc.Iterable[eudplib.core.rawtrigger.action.Action | collections.abc.Iterable | None] | None = None) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "init_ptrigger": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.trigger.ptrigger"
    },
    "DoActions": {
      "signature": "(*actions, preserved=True) -> tuple[eudplib.core.allocator.Forward, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDJump": {
      "signature": "(nextptr, *, must_use=True) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDJumpIf": {
      "signature": "(conditions, ontrue) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDJumpIfNot": {
      "signature": "(conditions, onfalse) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDTernary": {
      "signature": "(conditions, *, neg=False) -> collections.abc.Callable[[typing.Any], collections.abc.Callable[[typing.Any], eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDEndInfLoop": {
      "signature": "() -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDEndLoopN": {
      "signature": "() -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDEndWhile": {
      "signature": "() -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDInfLoop": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDLoopN": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDLoopRange": {
      "signature": "(start, end=None) -> collections.abc.Iterator[eudplib.core.variable.eudv.EUDVariable]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDWhile": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDWhileNot": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "freeze.freeze"
    },
    "eudloop_break": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "eudloop_break_if": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "eudloop_break_ifnot": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "eudloop_continue": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "eudloop_continue_if": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "eudloop_continue_ifnot": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "is_continuepoint_set": {
      "signature": "() -> bool",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "set_continuepoint": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "get_current_jumpbuffer": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.ctrlstru.jumptable"
    },
    "register_new_jumpbuffer": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.ctrlstru.jumptable"
    },
    "EPDSwitch": {
      "signature": "(epd, mask=4294967295) -> Literal[True]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDEndSwitch": {
      "signature": "() -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDSwitch": {
      "signature": "(var, mask=4294967295) -> Literal[True]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDSwitchCase": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDSwitchDefault": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "freeze.freeze"
    },
    "eudswitch_break": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.swblock"
    },
    "eudswitch_break_if": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.swblock"
    },
    "eudswitch_break_ifnot": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.swblock"
    },
    "EUDBreak": {
      "signature": "() -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDBreakIf": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDBreakIfNot": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDContinue": {
      "signature": "() -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDContinueIf": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDContinueIfNot": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDIsContinuePointSet": {
      "signature": "() -> bool",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDSetContinuePoint": {
      "signature": "() -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDElse": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDElseIf": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDElseIfNot": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDEndExecuteOnce": {
      "signature": "() -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDEndIf": {
      "signature": "() -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDExecuteOnce": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDIf": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDIfNot": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDAnd": {
      "signature": "(cond1, *conds) -> eudplib.core.variable.eudlv.EUDLightBool",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDNot": {
      "signature": "(cond)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDOr": {
      "signature": "(cond1, *conds) -> eudplib.core.variable.eudlv.EUDLightBool",
      "doc": "",
      "module": "freeze.freeze"
    },
    "MoveCP": {
      "signature": "(dest) -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.keycalc"
    },
    "SetMemoryC": {
      "signature": "(dest, modtype, value) -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetMemoryS": {
      "signature": "(dest, modtype, value) -> tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "freeze.trigutils"
    },
    "load": {
      "signature": "(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)",
      "doc": "",
      "module": "json"
    },
    "pop": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.memio.s"
    },
    "push": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.memio.s"
    },
    "rand": {
      "signature": "(dest) -> tuple[typing.Any, typing.Any]",
      "doc": "",
      "module": "eudplib.memio.s"
    },
    "srand": {
      "signature": "() -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.keycalc"
    },
    "f_addcurpl": {
      "signature": "(cp)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_setcurpl": {
      "signature": "(cp, *, actions=[], set_modifier=True)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_setcurpl2cpcache": {
      "signature": "(v=[], actions=[])",
      "doc": "",
      "module": "freeze.freeze"
    },
    "guess_ordering": {
      "signature": "(bitmask: int, shift: int) -> bool",
      "doc": "",
      "module": "eudplib.memio.readtable"
    },
    "signed_shift": {
      "signature": "(a: int, b: int)",
      "doc": "",
      "module": "eudplib.memio.readtable"
    },
    "f_dwadd_epd": {
      "signature": "(targetplayer, value)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_dwepdread_epd_safe": {
      "signature": "(*args, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_dwread_epd": {
      "signature": "(targetplayer, *, ret=None)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_dwread_epd_safe": {
      "signature": "(*args, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_dwsubtract_epd": {
      "signature": "(targetplayer, value)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_dwwrite_epd": {
      "signature": "(targetplayer, value)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_epdread_epd": {
      "signature": "(targetplayer, *, ret=None)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_epdread_epd_safe": {
      "signature": "(*args, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_flagread_epd": {
      "signature": "(targetplayer, *flags, _readerdict={})",
      "doc": "",
      "module": "freeze.freeze"
    },
    "setdw_epd": {
      "signature": "(targetplayer, modifier, value)",
      "doc": "",
      "module": "eudplib.memio.dwepdio"
    },
    "f_bread_cp": {
      "signature": "(cpo, subp, *, ret=None)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bwrite_cp": {
      "signature": "(cpo, subp, b)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_dwadd_cp": {
      "signature": "(cpo, value)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_dwepdread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_dwread_cp": {
      "signature": "(cpo, *, ret=None)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_dwsubtract_cp": {
      "signature": "(cpo, value)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_dwwrite_cp": {
      "signature": "(cpo, value)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_epdread_cp": {
      "signature": "(cpo, *, ret=None)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_maskwrite_cp": {
      "signature": "(cpo, value, mask)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_wread_cp": {
      "signature": "(cpo, subp, *, ret=None)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_wwrite_cp": {
      "signature": "(cpo, subp, w)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_badd_epd": {
      "signature": "(epd, subp, b)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bread_epd": {
      "signature": "(epd, subp, *, ret=None)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bsubtract_epd": {
      "signature": "(epd, subp, b)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bwrite_epd": {
      "signature": "(epd, subp, b) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_maskwrite_epd": {
      "signature": "(epd, value, mask) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_wadd_epd": {
      "signature": "(epd, subp, w)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_wread_epd": {
      "signature": "(epd, subp, *, ret=None)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_wsubtract_epd": {
      "signature": "(epd, subp, w)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_wwrite_epd": {
      "signature": "(epd, subp, w)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_memcpy": {
      "signature": "(dst, src, copylen, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_maskread_cp": {
      "signature": "(cpo, mask, *, _fdict={}, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_maskread_epd": {
      "signature": "(targetplayer, mask, *, _fdict={}, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_readgen_cp": {
      "signature": "(mask: int, *args: tuple[int, collections.abc.Callable[[int], int]], docstring: str | None = None, _check_empty: bool = False) -> collections.abc.Callable",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_readgen_epd": {
      "signature": "(mask: int, *args: tuple[int, collections.abc.Callable[[int], int]], docstring: str | None = None, _check_empty: bool = False) -> eudplib.core.eudfunc.eudtypedfuncn.EUDTypedFuncN",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bread": {
      "signature": "(ptr, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_bwrite": {
      "signature": "(ptr, b)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_dwread": {
      "signature": "(ptr, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_dwwrite": {
      "signature": "(ptr, dw)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_wread": {
      "signature": "(ptr, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_wwrite": {
      "signature": "(ptr, w)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_cunitepdread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_cunitread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_epdcunitread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_epdspriteread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_posread_cp": {
      "signature": "(cpoffset, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_posread_epd": {
      "signature": "(epd, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_spriteepdread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_spriteread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDStack": {
      "signature": "(basetype=None)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_addloc": {
      "signature": "(loc, *coords, action=False)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_dilateloc": {
      "signature": "(loc, *coords, action=False)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_getlocTL": {
      "signature": "(loc, **kwargs) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_setloc": {
      "signature": "(loc, *coords, action=False)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_setloc_epd": {
      "signature": "(loc, epd) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_div_euclid": {
      "signature": "(a, b, **kwargs) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable] | tuple[int, int]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_div_floor": {
      "signature": "(a, b, **kwargs) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable] | tuple[int, int]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_div_towards_zero": {
      "signature": "(a, b, **kwargs) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable] | tuple[int, int]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_pow": {
      "signature": "(a, b)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDBinaryMax": {
      "signature": "(cond, minv=0, maxv=4294967295) -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDBinaryMin": {
      "signature": "(cond, minv=0, maxv=4294967295) -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "freeze.freeze"
    },
    "copy": {
      "signature": "(src, dst, *, follow_symlinks=True)",
      "doc": "",
      "module": "shutil"
    },
    "deepcopy": {
      "signature": "(x, memo=None, _nil=[])",
      "doc": "",
      "module": "copy"
    },
    "asdict": {
      "signature": "(obj, *, dict_factory=<class 'dict'>)",
      "doc": "",
      "module": "dataclasses"
    },
    "astuple": {
      "signature": "(obj, *, tuple_factory=<class 'tuple'>)",
      "doc": "",
      "module": "dataclasses"
    },
    "dataclass": {
      "signature": "(cls=None, /, *, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False, weakref_slot=False)",
      "doc": "",
      "module": "eudplib.collections.objpool"
    },
    "field": {
      "signature": "(*, default=<dataclasses._MISSING_TYPE object at 0x0000014D033B5250>, default_factory=<dataclasses._MISSING_TYPE object at 0x0000014D033B5250>, init=True, repr=True, hash=None, compare=True, metadata=None, kw_only=<dataclasses._MISSING_TYPE object at 0x0000014D033B5250>)",
      "doc": "",
      "module": "dataclasses"
    },
    "fields": {
      "signature": "(class_or_instance)",
      "doc": "",
      "module": "dataclasses"
    },
    "is_dataclass": {
      "signature": "(obj)",
      "doc": "",
      "module": "dataclasses"
    },
    "make_dataclass": {
      "signature": "(cls_name, fields, *, bases=(), namespace=None, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False, weakref_slot=False)",
      "doc": "",
      "module": "dataclasses"
    },
    "replace": {
      "signature": "(obj, /, **changes)",
      "doc": "",
      "module": "dataclasses"
    },
    "IsUnlimiterOn": {
      "signature": "() -> bool",
      "doc": "",
      "module": "eudplib.eudlib.utilf.listloop"
    },
    "EUDLoopBullet": {
      "signature": "() -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "eudplib.eudlib.utilf.listloop"
    },
    "EUDLoopCUnit": {
      "signature": "() -> collections.abc.Iterator[eudplib.scdata.cunit.CUnit]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDLoopList": {
      "signature": "(header_offset, break_offset=None) -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDLoopNewCUnit": {
      "signature": "(allowance: int = 2) -> collections.abc.Iterator[eudplib.scdata.cunit.CUnit]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDLoopNewUnit": {
      "signature": "(allowance: int = 2) -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDLoopPlayerCUnit": {
      "signature": "(player) -> collections.abc.Iterator[eudplib.scdata.cunit.CUnit]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDLoopPlayerUnit": {
      "signature": "(player) -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDLoopSprite": {
      "signature": "() -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "eudplib.eudlib.utilf.listloop"
    },
    "EUDLoopUnit": {
      "signature": "() -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDLoopUnit2": {
      "signature": "() -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDEndPlayerLoop": {
      "signature": "()",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDLoopPlayer": {
      "signature": "(ptype: str | None = 'Human', force=None, race: str | None = None) -> collections.abc.Iterator[eudplib.scdata.player.TrgPlayer]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDPlayerLoop": {
      "signature": "()",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_getseed": {
      "signature": "() -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_srand": {
      "signature": "(seed) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "CenterViewAll": {
      "signature": "(location) -> tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "DisplayTextAll": {
      "signature": "(text) -> tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "IsUserCP": {
      "signature": "() -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "MinimapPingAll": {
      "signature": "(location) -> tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "PlayWAVAll": {
      "signature": "(soundpath) -> tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetMissionObjectivesAll": {
      "signature": "(text) -> tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "TalkingPortraitAll": {
      "signature": "(unit, time) -> tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_getuserplayerid": {
      "signature": "() -> eudplib.scdata.player.TrgPlayer",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDLoopTrigger": {
      "signature": "(player) -> 'Iterator[tuple[EUDVariable, EUDVariable]]'",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "GetFirstTrigTrigger": {
      "signature": "(player: 'Player') -> 'EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "GetLastTrigTrigger": {
      "signature": "(player: 'Player') -> 'EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrigTriggerBegin": {
      "signature": "(player: 'Player') -> 'EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrigTriggerEnd": {
      "signature": "(player: 'Player') -> 'c.Forward | EUDVariable'",
      "doc": "",
      "module": "freeze.freeze"
    },
    "Action": {
      "signature": "(locid1: int, strid: int, wavid: int, time: int, player1: int, player2: int, unitid: int, acttype: int, amount: int, flags: int, *, eudx: int = 0) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Briefing": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Condition": {
      "signature": "(locid: int, player: int, amount: int, unitid: int, comparison: int, condtype: int, restype: int, flag: int, *, eudx: int = 0) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "NoAction": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "NoCondition": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "get_executing_players": {
      "signature": "(btrigger: bytes) -> list[bool]",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "get_trigger_size": {
      "signature": "(btrigger: bytes) -> int",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "inline_codify_binary_trigger": {
      "signature": "(btrigger: bytes) -> tuple[eudplib.core.allocator.ConstExpr, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger]",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "inline_codify_binary_triggers": {
      "signature": "(btriggers: collections.abc.Collection[bytes | int]) -> tuple[eudplib.core.allocator.ConstExpr, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger]",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "try_share_trigger": {
      "signature": "(btrigger: bytes) -> int | bytes",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "compute_base_inline_code_globals": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "get_inline_code_globals": {
      "signature": "() -> dict[str, typing.Any]",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilccompile"
    },
    "GetInlineCodePlayerList": {
      "signature": "(btrigger: bytes) -> int | None",
      "doc": "",
      "module": "freeze.trigcrypt"
    },
    "PRT_SetInliningRate": {
      "signature": "(rate: float) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "create_inject_finalizer": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK, root: eudplib.core.allocator.Forward | eudplib.core.rawtrigger.rawtriggerdef.RawTrigger, mrgndata: bytes | None = None) -> eudplib.core.allocator.Forward",
      "doc": "",
      "module": "eudplib.maprw.injector.apply_injector"
    },
    "initialize_payload": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK, payload: eudplib.core.allocator.pbuffer.Payload, mrgndata: collections.abc.ByteString | None = None) -> None",
      "doc": "",
      "module": "eudplib.maprw.injector.apply_injector"
    },
    "create_payload_relocator": {
      "signature": "(payload: eudplib.core.allocator.pbuffer.Payload) -> eudplib.core.allocator.pbuffer.Payload",
      "doc": "",
      "module": "eudplib.maprw.injector.apply_injector"
    },
    "copy_deaths": {
      "signature": "(iplayer: eudplib.scdata.player.TrgPlayer | int, oplayer: eudplib.scdata.player.TrgPlayer | int, copyepd: bool = False, initvalue: int | None = None) -> None",
      "doc": "",
      "module": "eudplib.maprw.injector.vector_reloc"
    },
    "create_vector_relocator": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK, payload: eudplib.core.allocator.pbuffer.Payload) -> None",
      "doc": "",
      "module": "eudplib.maprw.injector.apply_injector"
    },
    "PRT_SkipPayloadRelocator": {
      "signature": "(enable: bool) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "apply_injector": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK, root: eudplib.core.allocator.Forward | eudplib.core.rawtrigger.rawtriggerdef.RawTrigger) -> None",
      "doc": "",
      "module": "eudplib.maprw.savemap"
    },
    "GetMapStringAddr": {
      "signature": "(str_id)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "temp_string_id": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.string.dbstr"
    },
    "PColor": {
      "signature": "(i)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "PName": {
      "signature": "(x)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "eprint_all": {
      "signature": "(*args)",
      "doc": "",
      "module": "eudplib.string.fmtprint"
    },
    "f_cpstr_print": {
      "signature": "(*args, EOS=True, encoding='UTF-8')",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_eprintln": {
      "signature": "(*args)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_dbstr_print": {
      "signature": "(dst, *args, EOS=True, encoding='UTF-8')",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_eprintAll": {
      "signature": "(format_string, *args)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_eprintf": {
      "signature": "(format_string, *args)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_sprintf": {
      "signature": "(dst, format_string, *args, EOS=True, encoding='UTF-8')",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_sprintf_cp": {
      "signature": "(format_string, *args, EOS=True, encoding='UTF-8')",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_parse": {
      "signature": "(dst, radix=10)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_strlen": {
      "signature": "(src, /, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_strlen_epd": {
      "signature": "(epd, subp=0, /, **kwargs)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "IsPName": {
      "signature": "(player, name)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetPName": {
      "signature": "(player, *name)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SetPNamef": {
      "signature": "(player, format_string, *args)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "compare_sequence": {
      "signature": "(src: int, seq: str) -> list[eudplib.core.rawtrigger.condition.Condition]",
      "doc": "",
      "module": "eudplib.string.pname"
    },
    "TextFX_FadeIn": {
      "signature": "(*args, color=None, wait=1, reset=True, tag=None, encoding='UTF-8')",
      "doc": "",
      "module": "freeze.freeze"
    },
    "TextFX_FadeOut": {
      "signature": "(*args, color=None, wait=1, reset=True, tag=None, encoding='UTF-8')",
      "doc": "",
      "module": "freeze.freeze"
    },
    "TextFX_Remove": {
      "signature": "(tag)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "TextFX_SetTimer": {
      "signature": "(tag, modtype, value)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_cpchar_addstr": {
      "signature": "(src)",
      "doc": "",
      "module": "eudplib.string.texteffect"
    },
    "f_cpchar_addstr_epd": {
      "signature": "(src)",
      "doc": "",
      "module": "eudplib.string.texteffect"
    },
    "f_cpchar_print": {
      "signature": "(*args, EOS=True, encoding='UTF-8')",
      "doc": "",
      "module": "eudplib.string.texteffect"
    },
    "get_textfx_timer": {
      "signature": "(tag)",
      "doc": "",
      "module": "eudplib.string.strbuffer"
    },
    "GetGlobalStringBuffer": {
      "signature": "()",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_printAt": {
      "signature": "(line, format_string, *args)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_println": {
      "signature": "(format_string, *args)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_simpleprint": {
      "signature": "(*args, spaced=True)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_printAll": {
      "signature": "(format_string, *args)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_printAllAt": {
      "signature": "(line, format_string, *args)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_eprintln2": {
      "signature": "(*args) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_settbl": {
      "signature": "(tbl_id, offset, *args, encoding=None)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_settbl2": {
      "signature": "(tbl_id, offset, *args, encoding=None)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_settblf": {
      "signature": "(tbl_id, offset, format_string, *args, encoding=None)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "f_settblf2": {
      "signature": "(tbl_id, offset, format_string, *args, encoding=None)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDDoEvents": {
      "signature": "() -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDOnStart": {
      "signature": "(func: collections.abc.Callable) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "eud_onstart2": {
      "signature": "(func: collections.abc.Callable) -> None",
      "doc": "",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "has_already_started": {
      "signature": "() -> bool",
      "doc": "",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "main_starter": {
      "signature": "(mf: collections.abc.Callable) -> eudplib.core.allocator.Forward",
      "doc": "",
      "module": "eudplib.maprw.savemap"
    },
    "filter": {
      "signature": "(names, pat)",
      "doc": "",
      "module": "fnmatch"
    },
    "fnmatch": {
      "signature": "(name, pat)",
      "doc": "",
      "module": "fnmatch"
    },
    "fnmatchcase": {
      "signature": "(name, pat)",
      "doc": "",
      "module": "fnmatch"
    },
    "translate": {
      "signature": "(pat)",
      "doc": "",
      "module": "fnmatch"
    },
    "compress": {
      "signature": "(data, format=1, check=-1, preset=None, filters=None)",
      "doc": "",
      "module": "lzma"
    },
    "decompress": {
      "signature": "(data, format=0, memlimit=None, filters=None)",
      "doc": "",
      "module": "lzma"
    },
    "chown": {
      "signature": "(path, user=None, group=None)",
      "doc": "",
      "module": "shutil"
    },
    "copy2": {
      "signature": "(src, dst, *, follow_symlinks=True)",
      "doc": "",
      "module": "shutil"
    },
    "copyfile": {
      "signature": "(src, dst, *, follow_symlinks=True)",
      "doc": "",
      "module": "shutil"
    },
    "copyfileobj": {
      "signature": "(fsrc, fdst, length=0)",
      "doc": "",
      "module": "shutil"
    },
    "copymode": {
      "signature": "(src, dst, *, follow_symlinks=True)",
      "doc": "",
      "module": "shutil"
    },
    "copystat": {
      "signature": "(src, dst, *, follow_symlinks=True)",
      "doc": "",
      "module": "shutil"
    },
    "copytree": {
      "signature": "(src, dst, symlinks=False, ignore=None, copy_function=<function copy2 at 0x0000014D03532DE0>, ignore_dangling_symlinks=False, dirs_exist_ok=False)",
      "doc": "",
      "module": "shutil"
    },
    "disk_usage": {
      "signature": "(path)",
      "doc": "",
      "module": "shutil"
    },
    "get_archive_formats": {
      "signature": "()",
      "doc": "",
      "module": "shutil"
    },
    "get_terminal_size": {
      "signature": "(fallback=(80, 24))",
      "doc": "",
      "module": "shutil"
    },
    "get_unpack_formats": {
      "signature": "()",
      "doc": "",
      "module": "shutil"
    },
    "ignore_patterns": {
      "signature": "(*patterns)",
      "doc": "",
      "module": "shutil"
    },
    "make_archive": {
      "signature": "(base_name, format, root_dir=None, base_dir=None, verbose=0, dry_run=0, owner=None, group=None, logger=None)",
      "doc": "",
      "module": "shutil"
    },
    "move": {
      "signature": "(src, dst, copy_function=<function copy2 at 0x0000014D03532DE0>)",
      "doc": "",
      "module": "shutil"
    },
    "register_archive_format": {
      "signature": "(name, function, extra_args=None, description='')",
      "doc": "",
      "module": "shutil"
    },
    "register_unpack_format": {
      "signature": "(name, extensions, function, extra_args=None, description='')",
      "doc": "",
      "module": "shutil"
    },
    "rmtree": {
      "signature": "(path, ignore_errors=False, onerror=None, *, dir_fd=None)",
      "doc": "",
      "module": "shutil"
    },
    "unpack_archive": {
      "signature": "(filename, extract_dir=None, format=None, *, filter=None)",
      "doc": "",
      "module": "shutil"
    },
    "unregister_archive_format": {
      "signature": "(name)",
      "doc": "",
      "module": "shutil"
    },
    "unregister_unpack_format": {
      "signature": "(name)",
      "doc": "",
      "module": "shutil"
    },
    "which": {
      "signature": "(cmd, mode=1, path=None)",
      "doc": "",
      "module": "shutil"
    },
    "NamedTemporaryFile": {
      "signature": "(mode='w+b', buffering=-1, encoding=None, newline=None, suffix=None, prefix=None, dir=None, delete=True, *, errors=None)",
      "doc": "",
      "module": "eudplib.maprw.mpqadd"
    },
    "TemporaryFile": {
      "signature": "(mode='w+b', buffering=-1, encoding=None, newline=None, suffix=None, prefix=None, dir=None, delete=True, *, errors=None)",
      "doc": "",
      "module": "tempfile"
    },
    "gettempdir": {
      "signature": "()",
      "doc": "",
      "module": "tempfile"
    },
    "gettempdirb": {
      "signature": "()",
      "doc": "",
      "module": "tempfile"
    },
    "gettempprefix": {
      "signature": "()",
      "doc": "",
      "module": "tempfile"
    },
    "gettempprefixb": {
      "signature": "()",
      "doc": "",
      "module": "tempfile"
    },
    "mkdtemp": {
      "signature": "(suffix=None, prefix=None, dir=None)",
      "doc": "",
      "module": "tempfile"
    },
    "mkstemp": {
      "signature": "(suffix=None, prefix=None, dir=None, text=False)",
      "doc": "",
      "module": "tempfile"
    },
    "mktemp": {
      "signature": "(suffix='', prefix='tmp', dir=None)",
      "doc": "",
      "module": "tempfile"
    },
    "MPQAddFile": {
      "signature": "(fname: str, path_or_content: str | bytes | bytearray | None, is_wav: bool = False) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "MPQAddWave": {
      "signature": "(fname: str, path_or_content: str | bytes | bytearray | None) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "MPQCheckFile": {
      "signature": "(fname: str) -> bytes",
      "doc": "",
      "module": "freeze.freeze"
    },
    "update_filelist_by_listfile": {
      "signature": "(mpqr: eudplib.core.mapdata.mpqapi.MPQ) -> None",
      "doc": "",
      "module": "eudplib.maprw.loadmap"
    },
    "LoadMap": {
      "signature": "(fname: str) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "SaveMap": {
      "signature": "(fname: str, rootf: collections.abc.Callable, *, sector_size: int | None = None) -> None",
      "doc": "",
      "module": "freeze.freeze"
    },
    "get_trace_map": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.maprw.savemap"
    },
    "Is64BitWireframe": {
      "signature": "() -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "freeze.freeze"
    },
    "grpwire_default32": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "grpwire_default64": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "tranwire_default32": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "tranwire_default64": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "wirefram_default32": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "wirefram_default64": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "architecture": {
      "signature": "(executable='D:\\\\a\\\\eud_draft_parser\\\\eud_draft_parser\\\\euddraft0.10.1.0\\\\euddraft.exe', bits='', linkage='')",
      "doc": "",
      "module": "platform"
    },
    "freedesktop_os_release": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "java_ver": {
      "signature": "(release='', vendor='', vminfo=('', '', ''), osinfo=('', '', ''))",
      "doc": "",
      "module": "platform"
    },
    "libc_ver": {
      "signature": "(executable=None, lib='', version='', chunksize=16384)",
      "doc": "",
      "module": "platform"
    },
    "mac_ver": {
      "signature": "(release='', versioninfo=('', '', ''), machine='')",
      "doc": "",
      "module": "platform"
    },
    "machine": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "node": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "platform": {
      "signature": "(aliased=0, terse=0)",
      "doc": "",
      "module": "platform"
    },
    "processor": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "python_branch": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "python_build": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "python_compiler": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "python_implementation": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "python_revision": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "python_version": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "python_version_tuple": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "release": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "system": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "system_alias": {
      "signature": "(system, release, version)",
      "doc": "",
      "module": "platform"
    },
    "uname": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "version": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "win32_edition": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "win32_is_iot": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "win32_ver": {
      "signature": "(release='', version='', csd='', ptype='')",
      "doc": "",
      "module": "platform"
    },
    "call": {
      "signature": "(*popenargs, timeout=None, **kwargs)",
      "doc": "",
      "module": "subprocess"
    },
    "check_call": {
      "signature": "(*popenargs, **kwargs)",
      "doc": "",
      "module": "subprocess"
    },
    "check_output": {
      "signature": "(*popenargs, timeout=None, **kwargs)",
      "doc": "",
      "module": "subprocess"
    },
    "getoutput": {
      "signature": "(cmd, *, encoding=None, errors=None)",
      "doc": "",
      "module": "subprocess"
    },
    "getstatusoutput": {
      "signature": "(cmd, *, encoding=None, errors=None)",
      "doc": "",
      "module": "subprocess"
    },
    "list2cmdline": {
      "signature": "(seq)",
      "doc": "",
      "module": "subprocess"
    },
    "run": {
      "signature": "(*popenargs, input=None, capture_output=False, timeout=None, check=False, **kwargs)",
      "doc": "",
      "module": "subprocess"
    },
    "EPS_SetDebug": {
      "signature": "(b)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "epsCompile": {
      "signature": "(filename, b_code)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "assemble": {
      "signature": "(instructions: collections.abc.Iterator[dis.Instruction], firstlineno: int, ep_lineno_map: collections.abc.Callable[[int], int]) -> bytes",
      "doc": "",
      "module": "eudplib.epscript.linetable_calculator"
    },
    "create_linetable_calculator": {
      "signature": "(firstlineno: int)",
      "doc": "",
      "module": "eudplib.epscript.linetable_calculator"
    },
    "gen_code_options": {
      "signature": "(code: code) -> dict[str, typing.Any]",
      "doc": "",
      "module": "eudplib.epscript.epsimp"
    },
    "gen_new_opcode": {
      "signature": "(code_object: code, code_options: dict[str, typing.Any], keys: list[str], ep_lineno_map: collections.abc.Callable[[int], int]) -> code",
      "doc": "",
      "module": "eudplib.epscript.epsimp"
    },
    "get_instruction_size": {
      "signature": "(instr) -> int",
      "doc": "",
      "module": "eudplib.epscript.linetable_calculator"
    },
    "get_pycode_attributes": {
      "signature": "() -> list[str]",
      "doc": "",
      "module": "eudplib.epscript.linetable_calculator"
    },
    "to_byte": {
      "signature": "(num)",
      "doc": "",
      "module": "eudplib.epscript.linetable_calculator"
    },
    "IsSCDBMap": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.epscript.epsimp"
    },
    "QueueGameCommand_AddSelect": {
      "signature": "(n, ptr_arr)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "QueueGameCommand_RemoveSelect": {
      "signature": "(n, ptr_arr)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "QueueGameCommand_Select": {
      "signature": "(n, ptr_arr)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "eudplibVersion": {
      "signature": "()",
      "doc": "",
      "module": "freeze.freeze"
    },
    "collapse_addresses": {
      "signature": "(addresses)",
      "doc": "",
      "module": "ipaddress"
    },
    "get_mixed_type_key": {
      "signature": "(obj)",
      "doc": "",
      "module": "ipaddress"
    },
    "ip_address": {
      "signature": "(address)",
      "doc": "",
      "module": "ipaddress"
    },
    "ip_interface": {
      "signature": "(address)",
      "doc": "",
      "module": "ipaddress"
    },
    "ip_network": {
      "signature": "(address, strict=True)",
      "doc": "",
      "module": "ipaddress"
    },
    "summarize_address_range": {
      "signature": "(first, last)",
      "doc": "",
      "module": "ipaddress"
    },
    "v4_int_to_packed": {
      "signature": "(address)",
      "doc": "",
      "module": "ipaddress"
    },
    "v6_int_to_packed": {
      "signature": "(address)",
      "doc": "",
      "module": "ipaddress"
    },
    "clear_cache": {
      "signature": "()",
      "doc": "",
      "module": "urllib.parse"
    },
    "parse_qs": {
      "signature": "(qs, keep_blank_values=False, strict_parsing=False, encoding='utf-8', errors='replace', max_num_fields=None, separator='&')",
      "doc": "",
      "module": "urllib.parse"
    },
    "parse_qsl": {
      "signature": "(qs, keep_blank_values=False, strict_parsing=False, encoding='utf-8', errors='replace', max_num_fields=None, separator='&')",
      "doc": "",
      "module": "urllib.parse"
    },
    "quote": {
      "signature": "(string, safe='/', encoding=None, errors=None)",
      "doc": "",
      "module": "urllib.request"
    },
    "quote_from_bytes": {
      "signature": "(bs, safe='/')",
      "doc": "",
      "module": "urllib.parse"
    },
    "quote_plus": {
      "signature": "(string, safe='', encoding=None, errors=None)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splitattr": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splithost": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splitnport": {
      "signature": "(host, defport=-1)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splitpasswd": {
      "signature": "(user)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splitport": {
      "signature": "(host)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splitquery": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splittag": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splittype": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splituser": {
      "signature": "(host)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splitvalue": {
      "signature": "(attr)",
      "doc": "",
      "module": "urllib.parse"
    },
    "to_bytes": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.parse"
    },
    "unquote": {
      "signature": "(string, encoding='utf-8', errors='replace')",
      "doc": "",
      "module": "urllib.request"
    },
    "unquote_plus": {
      "signature": "(string, encoding='utf-8', errors='replace')",
      "doc": "",
      "module": "urllib.parse"
    },
    "unquote_to_bytes": {
      "signature": "(string)",
      "doc": "",
      "module": "urllib.request"
    },
    "urldefrag": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.parse"
    },
    "urlencode": {
      "signature": "(query, doseq=False, safe='', encoding=None, errors=None, quote_via=<function quote_plus at 0x0000014D0384DEE0>)",
      "doc": "",
      "module": "urllib.parse"
    },
    "urljoin": {
      "signature": "(base, url, allow_fragments=True)",
      "doc": "",
      "module": "urllib.request"
    },
    "urlparse": {
      "signature": "(url, scheme='', allow_fragments=True)",
      "doc": "",
      "module": "urllib.request"
    },
    "urlunparse": {
      "signature": "(components)",
      "doc": "",
      "module": "urllib.request"
    },
    "urlunsplit": {
      "signature": "(components)",
      "doc": "",
      "module": "urllib.parse"
    },
    "urlquote_from_bytes": {
      "signature": "(bs, safe='/')",
      "doc": "",
      "module": "pathlib"
    },
    "is_zipfile": {
      "signature": "(filename)",
      "doc": "",
      "module": "zipfile"
    },
    "a85decode": {
      "signature": "(b, *, foldspaces=False, adobe=False, ignorechars=b' \\t\\n\\r\\x0b')",
      "doc": "",
      "module": "base64"
    },
    "a85encode": {
      "signature": "(b, *, foldspaces=False, wrapcol=0, pad=False, adobe=False)",
      "doc": "",
      "module": "base64"
    },
    "b16decode": {
      "signature": "(s, casefold=False)",
      "doc": "",
      "module": "base64"
    },
    "b16encode": {
      "signature": "(s)",
      "doc": "",
      "module": "base64"
    },
    "b32decode": {
      "signature": "(s, casefold=False, map01=None)",
      "doc": "",
      "module": "base64"
    },
    "b32encode": {
      "signature": "(s)",
      "doc": "",
      "module": "base64"
    },
    "b32hexdecode": {
      "signature": "(s, casefold=False)",
      "doc": "",
      "module": "base64"
    },
    "b32hexencode": {
      "signature": "(s)",
      "doc": "",
      "module": "base64"
    },
    "b64decode": {
      "signature": "(s, altchars=None, validate=False)",
      "doc": "",
      "module": "base64"
    },
    "b64encode": {
      "signature": "(s, altchars=None)",
      "doc": "",
      "module": "email.base64mime"
    },
    "b85decode": {
      "signature": "(b)",
      "doc": "",
      "module": "base64"
    },
    "b85encode": {
      "signature": "(b, pad=False)",
      "doc": "",
      "module": "base64"
    },
    "decodebytes": {
      "signature": "(s)",
      "doc": "",
      "module": "base64"
    },
    "encode": {
      "signature": "(string, charset='utf-8', encoding=None, lang='')",
      "doc": "",
      "module": "email._encoded_words"
    },
    "encodebytes": {
      "signature": "(s)",
      "doc": "",
      "module": "base64"
    },
    "standard_b64decode": {
      "signature": "(s)",
      "doc": "",
      "module": "base64"
    },
    "standard_b64encode": {
      "signature": "(s)",
      "doc": "",
      "module": "base64"
    },
    "test": {
      "signature": "()",
      "doc": "",
      "module": "base64"
    },
    "urlsafe_b64decode": {
      "signature": "(s)",
      "doc": "",
      "module": "base64"
    },
    "urlsafe_b64encode": {
      "signature": "(s)",
      "doc": "",
      "module": "base64"
    },
    "message_from_binary_file": {
      "signature": "(fp, *args, **kws)",
      "doc": "",
      "module": "email"
    },
    "message_from_bytes": {
      "signature": "(s, *args, **kws)",
      "doc": "",
      "module": "email"
    },
    "message_from_file": {
      "signature": "(fp, *args, **kws)",
      "doc": "",
      "module": "email"
    },
    "message_from_string": {
      "signature": "(s, *args, **kws)",
      "doc": "",
      "module": "email"
    },
    "file_digest": {
      "signature": "(fileobj, digest, /, *, _bufsize=262144)",
      "doc": "",
      "module": "hashlib"
    },
    "new": {
      "signature": "(name, data=b'', **kwargs)",
      "doc": "",
      "module": "hashlib"
    },
    "body_check": {
      "signature": "(octet)",
      "doc": "",
      "module": "email.quoprimime"
    },
    "body_decode": {
      "signature": "(string)",
      "doc": "",
      "module": "email.base64mime"
    },
    "body_encode": {
      "signature": "(s, maxlinelen=76, eol='\\n')",
      "doc": "",
      "module": "email.base64mime"
    },
    "body_length": {
      "signature": "(bytearray)",
      "doc": "",
      "module": "email.quoprimime"
    },
    "decodestring": {
      "signature": "(s, header=False)",
      "doc": "",
      "module": "quopri"
    },
    "header_check": {
      "signature": "(octet)",
      "doc": "",
      "module": "email.quoprimime"
    },
    "header_decode": {
      "signature": "(s)",
      "doc": "",
      "module": "email.quoprimime"
    },
    "header_encode": {
      "signature": "(header_bytes, charset='iso-8859-1')",
      "doc": "",
      "module": "email.base64mime"
    },
    "header_length": {
      "signature": "(bytearray)",
      "doc": "",
      "module": "email.base64mime"
    },
    "encodestring": {
      "signature": "(s, quotetabs=False, header=False)",
      "doc": "",
      "module": "quopri"
    },
    "ishex": {
      "signature": "(c)",
      "doc": "",
      "module": "quopri"
    },
    "needsquoting": {
      "signature": "(c, quotetabs, header)",
      "doc": "",
      "module": "quopri"
    },
    "unhex": {
      "signature": "(s)",
      "doc": "",
      "module": "quopri"
    },
    "encode_7or8bit": {
      "signature": "(msg)",
      "doc": "",
      "module": "email.charset"
    },
    "encode_base64": {
      "signature": "(msg)",
      "doc": "",
      "module": "email.encoders"
    },
    "encode_noop": {
      "signature": "(msg)",
      "doc": "",
      "module": "email.encoders"
    },
    "encode_quopri": {
      "signature": "(msg)",
      "doc": "",
      "module": "email.encoders"
    },
    "add_alias": {
      "signature": "(alias, canonical)",
      "doc": "",
      "module": "email.charset"
    },
    "add_charset": {
      "signature": "(charset, header_enc=None, body_enc=None, output_charset=None)",
      "doc": "",
      "module": "email.charset"
    },
    "add_codec": {
      "signature": "(charset, codecname)",
      "doc": "",
      "module": "email.charset"
    },
    "decode_header": {
      "signature": "(header)",
      "doc": "",
      "module": "email.header"
    },
    "make_header": {
      "signature": "(decoded_seq, maxlinelen=None, header_name=None, continuation_ws=' ')",
      "doc": "",
      "module": "email.header"
    },
    "formatstring": {
      "signature": "(cols, colwidth=20, spacing=6)",
      "doc": "",
      "module": "calendar"
    },
    "isleap": {
      "signature": "(year)",
      "doc": "",
      "module": "calendar"
    },
    "leapdays": {
      "signature": "(y1, y2)",
      "doc": "",
      "module": "calendar"
    },
    "monthrange": {
      "signature": "(year, month)",
      "doc": "",
      "module": "calendar"
    },
    "setfirstweekday": {
      "signature": "(firstweekday)",
      "doc": "",
      "module": "calendar"
    },
    "timegm": {
      "signature": "(tuple)",
      "doc": "",
      "module": "calendar"
    },
    "weekday": {
      "signature": "(year, month, day)",
      "doc": "",
      "module": "calendar"
    },
    "mktime_tz": {
      "signature": "(data)",
      "doc": "",
      "module": "email.utils"
    },
    "parsedate": {
      "signature": "(data)",
      "doc": "",
      "module": "email.utils"
    },
    "parsedate_tz": {
      "signature": "(data)",
      "doc": "",
      "module": "email.utils"
    },
    "collapse_rfc2231_value": {
      "signature": "(value, errors='replace', fallback_charset='us-ascii')",
      "doc": "",
      "module": "email.utils"
    },
    "decode_params": {
      "signature": "(params)",
      "doc": "",
      "module": "email.utils"
    },
    "decode_rfc2231": {
      "signature": "(s)",
      "doc": "",
      "module": "email.utils"
    },
    "encode_rfc2231": {
      "signature": "(s, charset=None, language=None)",
      "doc": "",
      "module": "email.utils"
    },
    "format_datetime": {
      "signature": "(dt, usegmt=False)",
      "doc": "",
      "module": "email.utils"
    },
    "formataddr": {
      "signature": "(pair, charset='utf-8')",
      "doc": "",
      "module": "email.utils"
    },
    "formatdate": {
      "signature": "(timeval=None, localtime=False, usegmt=False)",
      "doc": "",
      "module": "email.utils"
    },
    "getaddresses": {
      "signature": "(fieldvalues)",
      "doc": "",
      "module": "email.utils"
    },
    "localtime": {
      "signature": "(dt=None, isdst=-1)",
      "doc": "",
      "module": "email.utils"
    },
    "make_msgid": {
      "signature": "(idstring=None, domain=None)",
      "doc": "",
      "module": "email.utils"
    },
    "parseaddr": {
      "signature": "(addr)",
      "doc": "",
      "module": "email.utils"
    },
    "parsedate_to_datetime": {
      "signature": "(data)",
      "doc": "",
      "module": "email.utils"
    },
    "decode_b": {
      "signature": "(encoded)",
      "doc": "",
      "module": "email.message"
    },
    "decode_q": {
      "signature": "(encoded)",
      "doc": "",
      "module": "email._encoded_words"
    },
    "encode_b": {
      "signature": "(bstring)",
      "doc": "",
      "module": "email._encoded_words"
    },
    "encode_q": {
      "signature": "(bstring)",
      "doc": "",
      "module": "email._encoded_words"
    },
    "len_b": {
      "signature": "(bstring)",
      "doc": "",
      "module": "email._encoded_words"
    },
    "len_q": {
      "signature": "(bstring)",
      "doc": "",
      "module": "email._encoded_words"
    },
    "body_line_iterator": {
      "signature": "(msg, decode=False)",
      "doc": "",
      "module": "email.iterators"
    },
    "typed_subpart_iterator": {
      "signature": "(msg, maintype='text', subtype=None)",
      "doc": "",
      "module": "email.iterators"
    },
    "DER_cert_to_PEM_cert": {
      "signature": "(der_cert_bytes)",
      "doc": "",
      "module": "ssl"
    },
    "PEM_cert_to_DER_cert": {
      "signature": "(pem_cert_string)",
      "doc": "",
      "module": "ssl"
    },
    "cert_time_to_seconds": {
      "signature": "(cert_time)",
      "doc": "",
      "module": "ssl"
    },
    "create_default_context": {
      "signature": "(purpose=<Purpose.SERVER_AUTH: _ASN1Object(nid=129, shortname='serverAuth', longname='TLS Web Server Authentication', oid='1.3.6.1.5.5.7.3.1')>, *, cafile=None, capath=None, cadata=None)",
      "doc": "",
      "module": "ssl"
    },
    "get_default_verify_paths": {
      "signature": "()",
      "doc": "",
      "module": "ssl"
    },
    "get_protocol_name": {
      "signature": "(protocol_code)",
      "doc": "",
      "module": "ssl"
    },
    "get_server_certificate": {
      "signature": "(addr, ssl_version=<_SSLMethod.PROTOCOL_TLS_CLIENT: 16>, ca_certs=None, timeout=<object object at 0x0000014D00B04400>)",
      "doc": "",
      "module": "ssl"
    },
    "match_hostname": {
      "signature": "(cert, hostname)",
      "doc": "",
      "module": "ssl"
    },
    "wrap_socket": {
      "signature": "(sock, keyfile=None, certfile=None, server_side=False, cert_reqs=<VerifyMode.CERT_NONE: 0>, ssl_version=<_SSLMethod.PROTOCOL_TLS: 2>, ca_certs=None, do_handshake_on_connect=True, suppress_ragged_eofs=True, ciphers=None)",
      "doc": "",
      "module": "ssl"
    },
    "parse_headers": {
      "signature": "(fp, _class=<class 'http.client.HTTPMessage'>)",
      "doc": "",
      "module": "http.client"
    },
    "pathname2url": {
      "signature": "(p)",
      "doc": "",
      "module": "urllib.request"
    },
    "url2pathname": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.request"
    },
    "build_opener": {
      "signature": "(*handlers)",
      "doc": "",
      "module": "urllib.request"
    },
    "ftperrors": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "getproxies": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "getproxies_environment": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "getproxies_registry": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "install_opener": {
      "signature": "(opener)",
      "doc": "",
      "module": "urllib.request"
    },
    "localhost": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "noheaders": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "parse_http_list": {
      "signature": "(s)",
      "doc": "",
      "module": "urllib.request"
    },
    "parse_keqv_list": {
      "signature": "(l)",
      "doc": "",
      "module": "urllib.request"
    },
    "proxy_bypass": {
      "signature": "(host)",
      "doc": "",
      "module": "urllib.request"
    },
    "proxy_bypass_environment": {
      "signature": "(host, proxies=None)",
      "doc": "",
      "module": "urllib.request"
    },
    "proxy_bypass_registry": {
      "signature": "(host)",
      "doc": "",
      "module": "urllib.request"
    },
    "request_host": {
      "signature": "(request)",
      "doc": "",
      "module": "urllib.request"
    },
    "thishost": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "urlcleanup": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "urlopen": {
      "signature": "(url, data=None, timeout=<object object at 0x0000014D00B04400>, *, cafile=None, capath=None, cadefault=False, context=None)",
      "doc": "",
      "module": "autoupdate"
    },
    "urlretrieve": {
      "signature": "(url, filename=None, reporthook=None, data=None)",
      "doc": "",
      "module": "urllib.request"
    },
    "RGB": {
      "signature": "(red, green, blue)",
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "IsThisForeground": {
      "signature": "()",
      "doc": "",
      "module": "msgbox"
    },
    "MessageBox": {
      "signature": "(title, text, style=0, textio=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)",
      "doc": "",
      "module": "applyeuddraft"
    },
    "checkUpdate": {
      "signature": "()",
      "doc": "",
      "module": "autoupdate"
    },
    "download": {
      "signature": "(url)",
      "doc": "",
      "module": "autoupdate"
    },
    "getLatestUpdateCheckpoint": {
      "signature": "()",
      "doc": "",
      "module": "autoupdate"
    },
    "getLatestVersion": {
      "signature": "()",
      "doc": "",
      "module": "autoupdate"
    },
    "getRelease": {
      "signature": "(version)",
      "doc": "",
      "module": "autoupdate"
    },
    "issueAutoUpdate": {
      "signature": "()",
      "doc": "",
      "module": "autoupdate"
    },
    "versionLt": {
      "signature": "(version1, version2)",
      "doc": "",
      "module": "autoupdate"
    },
    "writeVersionCheckpoint": {
      "signature": "(version)",
      "doc": "",
      "module": "autoupdate"
    },
    "empty": {
      "signature": "()",
      "doc": "",
      "module": "pluginLoader"
    },
    "getGlobalPluginDirectory": {
      "signature": "()",
      "doc": "",
      "module": "euddraft"
    },
    "getPluginPath": {
      "signature": "(pluginName)",
      "doc": "",
      "module": "pluginLoader"
    },
    "getSCBankSettings": {
      "signature": "()",
      "doc": "",
      "module": "pluginLoader"
    },
    "isFreezeIssued": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "isPromptIssued": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "isSCBankIssued": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "loadPluginsFromConfig": {
      "signature": "(ep, config)",
      "doc": "",
      "module": "applyeuddraft"
    },
    "suppress_warnings": {
      "signature": "(flag: bool)",
      "doc": "",
      "module": "pluginLoader"
    },
    "readconfig": {
      "signature": "(fname) -> tuple[typing.Dict[str, typing.Dict[str, str]], list[Exception]]",
      "doc": "",
      "module": "applyeuddraft"
    },
    "run_module": {
      "signature": "(mod_name, init_globals=None, run_name=None, alter_sys=False)",
      "doc": "Execute a module's code without importing it.",
      "module": "runpy"
    },
    "run_path": {
      "signature": "(path_name, init_globals=None, run_name=None)",
      "doc": "Execute code located at the specified filesystem location.",
      "module": "runpy"
    },
    "close_all_fds_except": {
      "signature": "(fds)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "close_fds": {
      "signature": "(*fds)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "debug": {
      "signature": "(msg, *args)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "get_logger": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "get_temp_dir": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "info": {
      "signature": "(msg, *args)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "is_abstract_socket_namespace": {
      "signature": "(address)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "is_exiting": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "log_to_stderr": {
      "signature": "(level=None)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "register_after_fork": {
      "signature": "(obj, func)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "spawnv_passfds": {
      "signature": "(path, args, passfds)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "sub_debug": {
      "signature": "(msg, *args)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "sub_warning": {
      "signature": "(msg, *args)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "freeze_support": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "get_command_line": {
      "signature": "(**kwds)",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "get_executable": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "get_preparation_data": {
      "signature": "(name)",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "import_main_path": {
      "signature": "(main_path)",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "is_forking": {
      "signature": "(argv)",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "prepare": {
      "signature": "(data)",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "set_executable": {
      "signature": "(exe)",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "spawn_main": {
      "signature": "(pipe_handle, parent_pid=None, tracker_fd=None)",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "applyEUDDraft": {
      "signature": "(sfname)",
      "doc": "",
      "module": "applyeuddraft"
    },
    "applylib": {
      "signature": "()",
      "doc": "",
      "module": "euddraft"
    },
    "hasModifiedFile": {
      "signature": "(dirname, since)",
      "doc": "",
      "module": "euddraft"
    },
    "isFileModified": {
      "signature": "(path, since)",
      "doc": "",
      "module": "euddraft"
    },
    "BackupOrigPUPx": {
      "signature": "()",
      "doc": "",
      "module": "freeze.trigutils"
    },
    "ObfuscatedAdd": {
      "signature": "(var, amount, acts=[])",
      "doc": "",
      "module": "freeze.freeze"
    },
    "RestorePUPx": {
      "signature": "()",
      "doc": "",
      "module": "freeze.freeze"
    },
    "getExpectedTriggerCount": {
      "signature": "()",
      "doc": "",
      "module": "freeze.freeze"
    },
    "getObf": {
      "signature": "()",
      "doc": "",
      "module": "freeze.trigutils"
    },
    "getTriggerExecutingPlayers": {
      "signature": "(bTrigger)",
      "doc": "",
      "module": "freeze.trigcrypt"
    },
    "T2": {
      "signature": "(x)",
      "doc": "",
      "module": "freeze.utils"
    },
    "mix2": {
      "signature": "(x, y)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "tryUnT": {
      "signature": "(x)",
      "doc": "",
      "module": "freeze.utils"
    },
    "unT2": {
      "signature": "(y)",
      "doc": "",
      "module": "freeze.crypt"
    },
    "unmix2": {
      "signature": "(z, y)",
      "doc": "",
      "module": "freeze.trigcrypt"
    },
    "getMapHandleEPD": {
      "signature": "()",
      "doc": "",
      "module": "freeze.keycalc"
    },
    "keycalc": {
      "signature": "(seedKey, fileCursor)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "assignerMerge": {
      "signature": "(op1, op2)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "obfuscatedValueAssigner": {
      "signature": "(v, vInsert)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "writeAssigner": {
      "signature": "(operations)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "ObfuscatedJump": {
      "signature": "()",
      "doc": "",
      "module": "freeze"
    },
    "clearOJumper": {
      "signature": "()",
      "doc": "",
      "module": "freeze.obfjump"
    },
    "decryptOffsets": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "encryptOffsets": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "initOffsets": {
      "signature": "(seedKey, destKeyVal, cryptKey)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "issuePatcher": {
      "signature": "(parent, attrname, ratio)",
      "doc": "",
      "module": "freeze.obfpatch"
    },
    "obfpatch": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "obfunpatch": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "bseti4": {
      "signature": "(b, pos, dw)",
      "doc": "",
      "module": "freeze.trigcrypt"
    },
    "encryptTrigger": {
      "signature": "(bTrigger_, key)",
      "doc": "",
      "module": "freeze.trigcrypt"
    },
    "encryptTriggers": {
      "signature": "(cryptKey)",
      "doc": "",
      "module": "freeze.freeze"
    },
    "hexdump": {
      "signature": "(b)",
      "doc": "",
      "module": "freeze.trigcrypt"
    },
    "unFreeze": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "createPayloadMain": {
      "signature": "(pluginList, pluginFuncDict)",
      "doc": "",
      "module": "applyeuddraft"
    },
    "isEpExc": {
      "signature": "(s)",
      "doc": "",
      "module": "applyeuddraft"
    },
    "warn_with_traceback": {
      "signature": "(message, category, filename, lineno, file=None, line=None)",
      "doc": "",
      "module": "applyeuddraft"
    },
    "SetGlobalPoolFieldN": {
      "signature": "(fieldn: int) -> None",
      "doc": "",
      "module": "eudplib.collections.objpool"
    },
    "get_global_pool": {
      "signature": "() -> eudplib.collections.objpool.ObjPool",
      "doc": "",
      "module": "eudplib.collections.objpool"
    },
    "py_make_scanner": {
      "signature": "(context)",
      "doc": "",
      "module": "json.scanner"
    },
    "JSONArray": {
      "signature": "(s_and_end, scan_once, _w=<built-in method match of re.Pattern object at 0x0000014D038BEDC0>, _ws=' \\t\\n\\r')",
      "doc": "",
      "module": "json.decoder"
    },
    "JSONObject": {
      "signature": "(s_and_end, strict, scan_once, object_hook, object_pairs_hook, memo=None, _w=<built-in method match of re.Pattern object at 0x0000014D038BEDC0>, _ws=' \\t\\n\\r')",
      "doc": "",
      "module": "json.decoder"
    },
    "py_scanstring": {
      "signature": "(s, end, strict=True, _b={'\"': '\"', '\\\\': '\\\\', '/': '/', 'b': '\\x08', 'f': '\\x0c', 'n': '\\n', 'r': '\\r', 't': '\\t'}, _m=<built-in method match of re.Pattern object at 0x0000014D039247C0>)",
      "doc": "",
      "module": "json.decoder"
    },
    "py_encode_basestring": {
      "signature": "(s)",
      "doc": "",
      "module": "json.encoder"
    },
    "py_encode_basestring_ascii": {
      "signature": "(s)",
      "doc": "",
      "module": "json.encoder"
    },
    "dumps": {
      "signature": "(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)",
      "doc": "",
      "module": "json"
    },
    "loads": {
      "signature": "(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)",
      "doc": "",
      "module": "json"
    },
    "extend_path": {
      "signature": "(path, name)",
      "doc": "",
      "module": "pkgutil"
    },
    "get_data": {
      "signature": "(package, resource)",
      "doc": "",
      "module": "pkgutil"
    },
    "get_importer": {
      "signature": "(path_item)",
      "doc": "",
      "module": "pkgutil"
    },
    "get_loader": {
      "signature": "(module_or_name)",
      "doc": "",
      "module": "pkgutil"
    },
    "iter_importer_modules": {
      "signature": "(importer, prefix='')",
      "doc": "",
      "module": "pkgutil"
    },
    "iter_importers": {
      "signature": "(fullname='')",
      "doc": "",
      "module": "pkgutil"
    },
    "iter_modules": {
      "signature": "(path=None, prefix='')",
      "doc": "",
      "module": "pkgutil"
    },
    "iter_zipimport_modules": {
      "signature": "(importer, prefix='')",
      "doc": "",
      "module": "pkgutil"
    },
    "read_code": {
      "signature": "(stream)",
      "doc": "",
      "module": "pkgutil"
    },
    "simplegeneric": {
      "signature": "(func)",
      "doc": "",
      "module": "pkgutil"
    },
    "walk_packages": {
      "signature": "(path=None, prefix='', onerror=None)",
      "doc": "",
      "module": "pkgutil"
    }
  },
  "classes": {
    "ArithmeticError": {
      "methods": {},
      "doc": "Base class for arithmetic errors.",
      "module": "builtins"
    },
    "AssertionError": {
      "methods": {},
      "doc": "Assertion failed.",
      "module": "builtins"
    },
    "AttributeError": {
      "methods": {},
      "doc": "Attribute not found.",
      "module": "builtins"
    },
    "BaseException": {
      "methods": {},
      "doc": "Common base class for all exceptions",
      "module": "builtins"
    },
    "BaseExceptionGroup": {
      "methods": {},
      "doc": "A combination of multiple unrelated exceptions.",
      "module": "builtins"
    },
    "BlockingIOError": {
      "methods": {},
      "doc": "I/O operation would block.",
      "module": "io"
    },
    "BrokenPipeError": {
      "methods": {},
      "doc": "Broken pipe.",
      "module": "builtins"
    },
    "BufferError": {
      "methods": {},
      "doc": "Buffer error.",
      "module": "builtins"
    },
    "BytesWarning": {
      "methods": {},
      "doc": "Base class for warnings about bytes and buffer related problems, mostly",
      "module": "builtins"
    },
    "ChildProcessError": {
      "methods": {},
      "doc": "Child process error.",
      "module": "builtins"
    },
    "ConnectionAbortedError": {
      "methods": {},
      "doc": "Connection aborted.",
      "module": "builtins"
    },
    "ConnectionError": {
      "methods": {},
      "doc": "Connection error.",
      "module": "builtins"
    },
    "ConnectionRefusedError": {
      "methods": {},
      "doc": "Connection refused.",
      "module": "builtins"
    },
    "ConnectionResetError": {
      "methods": {},
      "doc": "Connection reset.",
      "module": "builtins"
    },
    "DeprecationWarning": {
      "methods": {},
      "doc": "Base class for warnings about deprecated features.",
      "module": "builtins"
    },
    "EOFError": {
      "methods": {},
      "doc": "Read beyond end of file.",
      "module": "builtins"
    },
    "EncodingWarning": {
      "methods": {},
      "doc": "Base class for warnings about encodings.",
      "module": "builtins"
    },
    "EnvironmentError": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "builtins"
    },
    "Exception": {
      "methods": {},
      "doc": "Common base class for all non-exit exceptions.",
      "module": "builtins"
    },
    "ExceptionGroup": {
      "methods": {},
      "doc": "",
      "module": "builtins"
    },
    "FileExistsError": {
      "methods": {},
      "doc": "File already exists.",
      "module": "builtins"
    },
    "FileNotFoundError": {
      "methods": {},
      "doc": "File not found.",
      "module": "builtins"
    },
    "FloatingPointError": {
      "methods": {},
      "doc": "Floating point operation failed.",
      "module": "builtins"
    },
    "FutureWarning": {
      "methods": {},
      "doc": "Base class for warnings about constructs that will change semantically",
      "module": "builtins"
    },
    "GeneratorExit": {
      "methods": {},
      "doc": "Request that a generator exit.",
      "module": "builtins"
    },
    "IOError": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "builtins"
    },
    "ImportError": {
      "methods": {},
      "doc": "Import can't find module, or can't find name in module.",
      "module": "builtins"
    },
    "ImportWarning": {
      "methods": {},
      "doc": "Base class for warnings about probable mistakes in module imports",
      "module": "builtins"
    },
    "IndentationError": {
      "methods": {},
      "doc": "Improper indentation.",
      "module": "builtins"
    },
    "IndexError": {
      "methods": {},
      "doc": "Sequence index out of range.",
      "module": "builtins"
    },
    "InterruptedError": {
      "methods": {},
      "doc": "Interrupted by signal.",
      "module": "builtins"
    },
    "IsADirectoryError": {
      "methods": {},
      "doc": "Operation doesn't work on directories.",
      "module": "builtins"
    },
    "KeyError": {
      "methods": {},
      "doc": "Mapping key not found.",
      "module": "builtins"
    },
    "KeyboardInterrupt": {
      "methods": {},
      "doc": "Program interrupted by user.",
      "module": "builtins"
    },
    "LookupError": {
      "methods": {},
      "doc": "Base class for lookup errors.",
      "module": "builtins"
    },
    "MemoryError": {
      "methods": {},
      "doc": "Out of memory.",
      "module": "builtins"
    },
    "ModuleNotFoundError": {
      "methods": {},
      "doc": "Module not found.",
      "module": "builtins"
    },
    "NameError": {
      "methods": {},
      "doc": "Name not found globally.",
      "module": "builtins"
    },
    "NotADirectoryError": {
      "methods": {},
      "doc": "Operation only works on directories.",
      "module": "builtins"
    },
    "NotImplementedError": {
      "methods": {},
      "doc": "Method or function hasn't been implemented yet.",
      "module": "builtins"
    },
    "OSError": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "builtins"
    },
    "OverflowError": {
      "methods": {},
      "doc": "Result too large to be represented.",
      "module": "builtins"
    },
    "PendingDeprecationWarning": {
      "methods": {},
      "doc": "Base class for warnings about features which will be deprecated",
      "module": "builtins"
    },
    "PermissionError": {
      "methods": {},
      "doc": "Not enough permissions.",
      "module": "builtins"
    },
    "ProcessLookupError": {
      "methods": {},
      "doc": "Process not found.",
      "module": "builtins"
    },
    "RecursionError": {
      "methods": {},
      "doc": "Recursion limit exceeded.",
      "module": "builtins"
    },
    "ReferenceError": {
      "methods": {},
      "doc": "Weak ref proxy used after referent went away.",
      "module": "builtins"
    },
    "ResourceWarning": {
      "methods": {},
      "doc": "Base class for warnings about resource usage.",
      "module": "builtins"
    },
    "RuntimeError": {
      "methods": {},
      "doc": "Unspecified run-time error.",
      "module": "builtins"
    },
    "RuntimeWarning": {
      "methods": {},
      "doc": "Base class for warnings about dubious runtime behavior.",
      "module": "builtins"
    },
    "StopAsyncIteration": {
      "methods": {},
      "doc": "Signal the end from iterator.__anext__().",
      "module": "builtins"
    },
    "StopIteration": {
      "methods": {},
      "doc": "Signal the end from iterator.__next__().",
      "module": "builtins"
    },
    "SyntaxError": {
      "methods": {},
      "doc": "Invalid syntax.",
      "module": "builtins"
    },
    "SyntaxWarning": {
      "methods": {},
      "doc": "Base class for warnings about dubious syntax.",
      "module": "builtins"
    },
    "SystemError": {
      "methods": {},
      "doc": "Internal error in the Python interpreter.",
      "module": "builtins"
    },
    "SystemExit": {
      "methods": {},
      "doc": "Request to exit from the interpreter.",
      "module": "builtins"
    },
    "TabError": {
      "methods": {},
      "doc": "Improper mixture of spaces and tabs.",
      "module": "builtins"
    },
    "TimeoutError": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing"
    },
    "TypeError": {
      "methods": {},
      "doc": "Inappropriate argument type.",
      "module": "builtins"
    },
    "UnboundLocalError": {
      "methods": {},
      "doc": "Local name referenced but not bound to a value.",
      "module": "builtins"
    },
    "UnicodeDecodeError": {
      "methods": {},
      "doc": "Unicode decoding error.",
      "module": "builtins"
    },
    "UnicodeEncodeError": {
      "methods": {},
      "doc": "Unicode encoding error.",
      "module": "builtins"
    },
    "UnicodeError": {
      "methods": {},
      "doc": "Unicode related error.",
      "module": "builtins"
    },
    "UnicodeTranslateError": {
      "methods": {},
      "doc": "Unicode translation error.",
      "module": "builtins"
    },
    "UnicodeWarning": {
      "methods": {},
      "doc": "Base class for warnings about Unicode related problems, mostly",
      "module": "builtins"
    },
    "UserWarning": {
      "methods": {},
      "doc": "Base class for warnings generated by user code.",
      "module": "builtins"
    },
    "ValueError": {
      "methods": {},
      "doc": "Inappropriate argument value (of correct type).",
      "module": "builtins"
    },
    "Warning": {
      "methods": {},
      "doc": "Base class for warning categories.",
      "module": "builtins"
    },
    "WindowsError": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "builtins"
    },
    "ZeroDivisionError": {
      "methods": {},
      "doc": "Second argument to a division or modulo operation was zero.",
      "module": "builtins"
    },
    "bool": {
      "methods": {},
      "doc": "bool(x) -> bool",
      "module": "builtins"
    },
    "bytearray": {
      "methods": {},
      "doc": "bytearray(iterable_of_ints) -> bytearray",
      "module": "builtins"
    },
    "bytes": {
      "methods": {},
      "doc": "bytes(iterable_of_ints) -> bytes",
      "module": "builtins"
    },
    "classmethod": {
      "methods": {},
      "doc": "classmethod(function) -> method",
      "module": "builtins"
    },
    "complex": {
      "methods": {},
      "doc": "Create a complex number from a real part and an optional imaginary part.",
      "module": "builtins"
    },
    "dict": {
      "methods": {},
      "doc": "dict() -> new empty dictionary",
      "module": "builtins"
    },
    "enumerate": {
      "methods": {},
      "doc": "Return an enumerate object.",
      "module": "builtins"
    },
    "filter": {
      "methods": {},
      "doc": "filter(function or None, iterable) --> filter object",
      "module": "builtins"
    },
    "float": {
      "methods": {},
      "doc": "Convert a string or number to a floating point number, if possible.",
      "module": "builtins"
    },
    "frozenset": {
      "methods": {},
      "doc": "frozenset() -> empty frozenset object",
      "module": "builtins"
    },
    "int": {
      "methods": {},
      "doc": "int([x]) -> integer",
      "module": "builtins"
    },
    "list": {
      "methods": {},
      "doc": "Built-in mutable sequence.",
      "module": "builtins"
    },
    "map": {
      "methods": {},
      "doc": "map(func, *iterables) --> map object",
      "module": "builtins"
    },
    "memoryview": {
      "methods": {},
      "doc": "Create a new memoryview object which references the given object.",
      "module": "builtins"
    },
    "object": {
      "methods": {},
      "doc": "The base class of the class hierarchy.",
      "module": "builtins"
    },
    "property": {
      "methods": {
        "deleter": {
          "signature": "(self, fdel)",
          "doc": ""
        },
        "getter": {
          "signature": "(self, fget)",
          "doc": ""
        },
        "setter": {
          "signature": "(self, fset)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "enum"
    },
    "range": {
      "methods": {},
      "doc": "range(stop) -> range object",
      "module": "builtins"
    },
    "reversed": {
      "methods": {},
      "doc": "Return a reverse iterator over the values of the given sequence.",
      "module": "builtins"
    },
    "set": {
      "methods": {},
      "doc": "set() -> new empty set object",
      "module": "builtins"
    },
    "slice": {
      "methods": {},
      "doc": "",
      "module": "ast"
    },
    "staticmethod": {
      "methods": {},
      "doc": "staticmethod(function) -> method",
      "module": "builtins"
    },
    "str": {
      "methods": {},
      "doc": "str(object='') -> str",
      "module": "builtins"
    },
    "super": {
      "methods": {},
      "doc": "super() -> same as super(__class__, <first argument>)",
      "module": "builtins"
    },
    "tuple": {
      "methods": {},
      "doc": "Built-in immutable sequence.",
      "module": "builtins"
    },
    "type": {
      "methods": {},
      "doc": "type(object) -> the object's type",
      "module": "builtins"
    },
    "zip": {
      "methods": {},
      "doc": "zip(*iterables, strict=False) --> Yield tuples until an input is exhausted.",
      "module": "builtins"
    },
    "HKEYType": {
      "methods": {},
      "doc": "PyHKEY Object - A Python object, representing a win32 registry key.",
      "module": "winreg"
    },
    "error": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "DirEntry": {
      "methods": {},
      "doc": "",
      "module": "os"
    },
    "stat_result": {
      "methods": {},
      "doc": "stat_result: Result from stat, fstat, or lstat.",
      "module": "os"
    },
    "statvfs_result": {
      "methods": {},
      "doc": "statvfs_result: Result from statvfs or fstatvfs.",
      "module": "os"
    },
    "terminal_size": {
      "methods": {},
      "doc": "A tuple of (columns, lines) for holding terminal window size",
      "module": "os"
    },
    "times_result": {
      "methods": {},
      "doc": "times_result: Result from os.times().",
      "module": "os"
    },
    "uname_result": {
      "methods": {},
      "doc": "",
      "module": "platform"
    },
    "struct_time": {
      "methods": {},
      "doc": "The time value as returned by gmtime(), localtime(), and strptime(), and",
      "module": "time"
    },
    "ZipImportError": {
      "methods": {},
      "doc": "",
      "module": "zipimport"
    },
    "zipimporter": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Use default semantics for module creation."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "find_loader": {
          "signature": "(self, fullname, path=None)",
          "doc": "find_loader(fullname, path=None) -> self, str or None."
        },
        "find_module": {
          "signature": "(self, fullname, path=None)",
          "doc": "find_module(fullname, path=None) -> self or None."
        },
        "find_spec": {
          "signature": "(self, fullname, target=None)",
          "doc": "Create a ModuleSpec for the specified module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "get_code(fullname) -> code object."
        },
        "get_data": {
          "signature": "(self, pathname)",
          "doc": "get_data(pathname) -> string with file data."
        },
        "get_filename": {
          "signature": "(self, fullname)",
          "doc": "get_filename(fullname) -> filename string."
        },
        "get_resource_reader": {
          "signature": "(self, fullname)",
          "doc": "Return the ResourceReader for a package in a zip file."
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "get_source(fullname) -> source string."
        },
        "invalidate_caches": {
          "signature": "(self)",
          "doc": "Reload the file data of the archive path."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "is_package(fullname) -> bool."
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": "load_module(fullname) -> module."
        }
      },
      "doc": "zipimporter(archivepath) -> zipimporter object",
      "module": "pkgutil"
    },
    "BufferedIncrementalDecoder": {
      "methods": {
        "decode": {
          "signature": "(self, input, final=False)",
          "doc": ""
        },
        "getstate": {
          "signature": "(self)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "setstate": {
          "signature": "(self, state)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "codecs"
    },
    "BufferedIncrementalEncoder": {
      "methods": {
        "encode": {
          "signature": "(self, input, final=False)",
          "doc": ""
        },
        "getstate": {
          "signature": "(self)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "setstate": {
          "signature": "(self, state)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "codecs"
    },
    "Codec": {
      "methods": {},
      "doc": "",
      "module": "encodings.cp949"
    },
    "CodecInfo": {
      "methods": {},
      "doc": "Codec details when looking up the codec registry",
      "module": "codecs"
    },
    "IncrementalDecoder": {
      "methods": {},
      "doc": "",
      "module": "encodings.cp949"
    },
    "IncrementalEncoder": {
      "methods": {},
      "doc": "",
      "module": "encodings.cp949"
    },
    "StreamReader": {
      "methods": {
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": " Set the input stream's current position."
        }
      },
      "doc": "",
      "module": "encodings.cp949"
    },
    "StreamReaderWriter": {
      "methods": {
        "read": {
          "signature": "(self, size=-1)",
          "doc": ""
        },
        "readline": {
          "signature": "(self, size=None)",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, sizehint=None)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": ""
        },
        "write": {
          "signature": "(self, data)",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, list)",
          "doc": ""
        }
      },
      "doc": " StreamReaderWriter instances allow wrapping streams which",
      "module": "codecs"
    },
    "StreamRecoder": {
      "methods": {
        "read": {
          "signature": "(self, size=-1)",
          "doc": ""
        },
        "readline": {
          "signature": "(self, size=None)",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, sizehint=None)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": ""
        },
        "write": {
          "signature": "(self, data)",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, list)",
          "doc": ""
        }
      },
      "doc": " StreamRecoder instances translate data from one encoding to another.",
      "module": "codecs"
    },
    "StreamWriter": {
      "methods": {
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "encodings.cp949"
    },
    "CodecRegistryError": {
      "methods": {},
      "doc": "",
      "module": "encodings"
    },
    "ABC": {
      "methods": {},
      "doc": "Helper class that provides a standard way to create an ABC using",
      "module": "abc"
    },
    "ABCMeta": {
      "methods": {
        "register": {
          "signature": "(cls, subclass)",
          "doc": "Register a virtual subclass of an ABC."
        }
      },
      "doc": "Metaclass for defining Abstract Base Classes (ABCs).",
      "module": "eudplib.scdata.offsetmap.member"
    },
    "abstractclassmethod": {
      "methods": {},
      "doc": "A decorator indicating abstract classmethods.",
      "module": "abc"
    },
    "abstractproperty": {
      "methods": {},
      "doc": "A decorator indicating abstract properties.",
      "module": "abc"
    },
    "abstractstaticmethod": {
      "methods": {},
      "doc": "A decorator indicating abstract staticmethods.",
      "module": "abc"
    },
    "BufferedIOBase": {
      "methods": {},
      "doc": "Base class for buffered IO objects.",
      "module": "io"
    },
    "BufferedRWPair": {
      "methods": {},
      "doc": "A buffered reader and writer object together.",
      "module": "io"
    },
    "BufferedRandom": {
      "methods": {},
      "doc": "A buffered interface to random access streams.",
      "module": "io"
    },
    "BufferedReader": {
      "methods": {},
      "doc": "Create a new buffered reader using the given readable raw IO object.",
      "module": "io"
    },
    "BufferedWriter": {
      "methods": {},
      "doc": "A buffer for a writeable sequential RawIO object.",
      "module": "io"
    },
    "BytesIO": {
      "methods": {},
      "doc": "Buffered I/O implementation using an in-memory bytes buffer.",
      "module": "email.message"
    },
    "FileIO": {
      "methods": {},
      "doc": "Open a file.",
      "module": "io"
    },
    "IOBase": {
      "methods": {},
      "doc": "The abstract base class for all I/O classes.",
      "module": "io"
    },
    "IncrementalNewlineDecoder": {
      "methods": {},
      "doc": "Codec used when reading a file in universal newlines mode.",
      "module": "io"
    },
    "RawIOBase": {
      "methods": {},
      "doc": "Base class for raw binary I/O.",
      "module": "io"
    },
    "StringIO": {
      "methods": {},
      "doc": "Text I/O implementation using an in-memory buffer.",
      "module": "email.message"
    },
    "TextIOBase": {
      "methods": {},
      "doc": "Base class for text I/O.",
      "module": "io"
    },
    "TextIOWrapper": {
      "methods": {},
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "module": "email.parser"
    },
    "UnsupportedOperation": {
      "methods": {},
      "doc": "",
      "module": "io"
    },
    "GenericAlias": {
      "methods": {},
      "doc": "Represent a PEP 585 generic type",
      "module": "dataclasses"
    },
    "Mapping": {
      "methods": {
        "get": {
          "signature": "(self, key, default=None)",
          "doc": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None."
        },
        "items": {
          "signature": "(self)",
          "doc": "D.items() -> a set-like object providing a view on D's items"
        },
        "keys": {
          "signature": "(self)",
          "doc": "D.keys() -> a set-like object providing a view on D's keys"
        },
        "values": {
          "signature": "(self)",
          "doc": "D.values() -> an object providing a view on D's values"
        }
      },
      "doc": "A Mapping is a generic container for associating key/value",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "MutableMapping": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": "D.clear() -> None.  Remove all items from D."
        },
        "get": {
          "signature": "(self, key, default=None)",
          "doc": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None."
        },
        "items": {
          "signature": "(self)",
          "doc": "D.items() -> a set-like object providing a view on D's items"
        },
        "keys": {
          "signature": "(self)",
          "doc": "D.keys() -> a set-like object providing a view on D's keys"
        },
        "pop": {
          "signature": "(self, key, default=<object object at 0x0000014D00B040C0>)",
          "doc": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value."
        },
        "popitem": {
          "signature": "(self)",
          "doc": "D.popitem() -> (k, v), remove and return some (key, value) pair"
        },
        "setdefault": {
          "signature": "(self, key, default=None)",
          "doc": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D"
        },
        "update": {
          "signature": "(self, other=(), /, **kwds)",
          "doc": " D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F."
        },
        "values": {
          "signature": "(self)",
          "doc": "D.values() -> an object providing a view on D's values"
        }
      },
      "doc": "A MutableMapping is a generic container for associating",
      "module": "collections.abc"
    },
    "PathLike": {
      "methods": {},
      "doc": "Abstract base class for implementing the file system path protocol.",
      "module": "os"
    },
    "accumulate": {
      "methods": {},
      "doc": "Return series of accumulated sums (or other binary function results).",
      "module": "itertools"
    },
    "chain": {
      "methods": {},
      "doc": "chain(*iterables) --> chain object",
      "module": "eudplib.ctrlstru.swblock"
    },
    "combinations": {
      "methods": {},
      "doc": "Return successive r-length combinations of elements in the iterable.",
      "module": "eudplib.ctrlstru.swblock"
    },
    "combinations_with_replacement": {
      "methods": {},
      "doc": "Return successive r-length combinations of elements in the iterable allowing individual elements to have successive repeats.",
      "module": "itertools"
    },
    "compress": {
      "methods": {},
      "doc": "Return data elements corresponding to true selector elements.",
      "module": "itertools"
    },
    "count": {
      "methods": {},
      "doc": "Return a count object whose .__next__() method returns consecutive values.",
      "module": "itertools"
    },
    "cycle": {
      "methods": {},
      "doc": "Return elements from the iterable until it is exhausted. Then repeat the sequence indefinitely.",
      "module": "itertools"
    },
    "dropwhile": {
      "methods": {},
      "doc": "Drop items from the iterable while predicate(item) is true.",
      "module": "itertools"
    },
    "filterfalse": {
      "methods": {},
      "doc": "Return those items of iterable for which function(item) is false.",
      "module": "itertools"
    },
    "groupby": {
      "methods": {},
      "doc": "make an iterator that returns consecutive keys and groups from the iterable",
      "module": "itertools"
    },
    "islice": {
      "methods": {},
      "doc": "islice(iterable, stop) --> islice object",
      "module": "pickle"
    },
    "pairwise": {
      "methods": {},
      "doc": "Return an iterator of overlapping pairs taken from the input iterator.",
      "module": "eudplib.core.variable.eudv"
    },
    "permutations": {
      "methods": {},
      "doc": "Return successive r-length permutations of elements in the iterable.",
      "module": "itertools"
    },
    "product": {
      "methods": {},
      "doc": "product(*iterables, repeat=1) --> product object",
      "module": "itertools"
    },
    "repeat": {
      "methods": {},
      "doc": "repeat(object [,times]) -> create an iterator which returns the object",
      "module": "calendar"
    },
    "starmap": {
      "methods": {},
      "doc": "Return an iterator whose values are returned from the function evaluated with an argument tuple taken from the given sequence.",
      "module": "itertools"
    },
    "takewhile": {
      "methods": {},
      "doc": "Return successive entries from an iterable as long as the predicate evaluates to true for each entry.",
      "module": "itertools"
    },
    "zip_longest": {
      "methods": {},
      "doc": "zip_longest(iter1 [,iter2 [...]], [fillvalue=None]) --> zip_longest object",
      "module": "itertools"
    },
    "attrgetter": {
      "methods": {},
      "doc": "attrgetter(attr, ...) --> attrgetter object",
      "module": "pathlib"
    },
    "itemgetter": {
      "methods": {},
      "doc": "itemgetter(item, ...) --> itemgetter object",
      "module": "operator"
    },
    "methodcaller": {
      "methods": {},
      "doc": "methodcaller(name, ...) --> methodcaller object",
      "module": "operator"
    },
    "Repr": {
      "methods": {
        "repr": {
          "signature": "(self, x)",
          "doc": ""
        },
        "repr1": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_array": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_deque": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_dict": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_frozenset": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_instance": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_int": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_list": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_set": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_str": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_tuple": {
          "signature": "(self, x, level)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "reprlib"
    },
    "ChainMap": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": ""
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "get": {
          "signature": "(self, key, default=None)",
          "doc": ""
        },
        "items": {
          "signature": "(self)",
          "doc": "D.items() -> a set-like object providing a view on D's items"
        },
        "keys": {
          "signature": "(self)",
          "doc": "D.keys() -> a set-like object providing a view on D's keys"
        },
        "new_child": {
          "signature": "(self, m=None, **kwargs)",
          "doc": ""
        },
        "pop": {
          "signature": "(self, key, *args)",
          "doc": ""
        },
        "popitem": {
          "signature": "(self)",
          "doc": ""
        },
        "setdefault": {
          "signature": "(self, key, default=None)",
          "doc": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D"
        },
        "update": {
          "signature": "(self, other=(), /, **kwds)",
          "doc": " D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F."
        },
        "values": {
          "signature": "(self)",
          "doc": "D.values() -> an object providing a view on D's values"
        }
      },
      "doc": "",
      "module": "collections"
    },
    "Counter": {
      "methods": {
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "elements": {
          "signature": "(self)",
          "doc": ""
        },
        "most_common": {
          "signature": "(self, n=None)",
          "doc": ""
        },
        "subtract": {
          "signature": "(self, iterable=None, /, **kwds)",
          "doc": ""
        },
        "total": {
          "signature": "(self)",
          "doc": ""
        },
        "update": {
          "signature": "(self, iterable=None, /, **kwds)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "collections"
    },
    "OrderedDict": {
      "methods": {},
      "doc": "Dictionary that remembers insertion order",
      "module": "readconfig"
    },
    "UserDict": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": "D.clear() -> None.  Remove all items from D."
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "get": {
          "signature": "(self, key, default=None)",
          "doc": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None."
        },
        "items": {
          "signature": "(self)",
          "doc": "D.items() -> a set-like object providing a view on D's items"
        },
        "keys": {
          "signature": "(self)",
          "doc": "D.keys() -> a set-like object providing a view on D's keys"
        },
        "pop": {
          "signature": "(self, key, default=<object object at 0x0000014D00B040C0>)",
          "doc": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value."
        },
        "popitem": {
          "signature": "(self)",
          "doc": "D.popitem() -> (k, v), remove and return some (key, value) pair"
        },
        "setdefault": {
          "signature": "(self, key, default=None)",
          "doc": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D"
        },
        "update": {
          "signature": "(self, other=(), /, **kwds)",
          "doc": " D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F."
        },
        "values": {
          "signature": "(self)",
          "doc": "D.values() -> an object providing a view on D's values"
        }
      },
      "doc": "",
      "module": "collections"
    },
    "UserList": {
      "methods": {
        "append": {
          "signature": "(self, item)",
          "doc": ""
        },
        "clear": {
          "signature": "(self)",
          "doc": ""
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "count": {
          "signature": "(self, item)",
          "doc": ""
        },
        "extend": {
          "signature": "(self, other)",
          "doc": ""
        },
        "index": {
          "signature": "(self, item, *args)",
          "doc": ""
        },
        "insert": {
          "signature": "(self, i, item)",
          "doc": ""
        },
        "pop": {
          "signature": "(self, i=-1)",
          "doc": ""
        },
        "remove": {
          "signature": "(self, item)",
          "doc": ""
        },
        "reverse": {
          "signature": "(self)",
          "doc": ""
        },
        "sort": {
          "signature": "(self, /, *args, **kwds)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "collections"
    },
    "UserString": {
      "methods": {
        "capitalize": {
          "signature": "(self)",
          "doc": ""
        },
        "casefold": {
          "signature": "(self)",
          "doc": ""
        },
        "center": {
          "signature": "(self, width, *args)",
          "doc": ""
        },
        "count": {
          "signature": "(self, sub, start=0, end=9223372036854775807)",
          "doc": ""
        },
        "encode": {
          "signature": "(self, encoding='utf-8', errors='strict')",
          "doc": ""
        },
        "endswith": {
          "signature": "(self, suffix, start=0, end=9223372036854775807)",
          "doc": ""
        },
        "expandtabs": {
          "signature": "(self, tabsize=8)",
          "doc": ""
        },
        "find": {
          "signature": "(self, sub, start=0, end=9223372036854775807)",
          "doc": ""
        },
        "format": {
          "signature": "(self, /, *args, **kwds)",
          "doc": ""
        },
        "format_map": {
          "signature": "(self, mapping)",
          "doc": ""
        },
        "index": {
          "signature": "(self, sub, start=0, end=9223372036854775807)",
          "doc": ""
        },
        "isalnum": {
          "signature": "(self)",
          "doc": ""
        },
        "isalpha": {
          "signature": "(self)",
          "doc": ""
        },
        "isascii": {
          "signature": "(self)",
          "doc": ""
        },
        "isdecimal": {
          "signature": "(self)",
          "doc": ""
        },
        "isdigit": {
          "signature": "(self)",
          "doc": ""
        },
        "isidentifier": {
          "signature": "(self)",
          "doc": ""
        },
        "islower": {
          "signature": "(self)",
          "doc": ""
        },
        "isnumeric": {
          "signature": "(self)",
          "doc": ""
        },
        "isprintable": {
          "signature": "(self)",
          "doc": ""
        },
        "isspace": {
          "signature": "(self)",
          "doc": ""
        },
        "istitle": {
          "signature": "(self)",
          "doc": ""
        },
        "isupper": {
          "signature": "(self)",
          "doc": ""
        },
        "join": {
          "signature": "(self, seq)",
          "doc": ""
        },
        "ljust": {
          "signature": "(self, width, *args)",
          "doc": ""
        },
        "lower": {
          "signature": "(self)",
          "doc": ""
        },
        "lstrip": {
          "signature": "(self, chars=None)",
          "doc": ""
        },
        "partition": {
          "signature": "(self, sep)",
          "doc": ""
        },
        "removeprefix": {
          "signature": "(self, prefix, /)",
          "doc": ""
        },
        "removesuffix": {
          "signature": "(self, suffix, /)",
          "doc": ""
        },
        "replace": {
          "signature": "(self, old, new, maxsplit=-1)",
          "doc": ""
        },
        "rfind": {
          "signature": "(self, sub, start=0, end=9223372036854775807)",
          "doc": ""
        },
        "rindex": {
          "signature": "(self, sub, start=0, end=9223372036854775807)",
          "doc": ""
        },
        "rjust": {
          "signature": "(self, width, *args)",
          "doc": ""
        },
        "rpartition": {
          "signature": "(self, sep)",
          "doc": ""
        },
        "rsplit": {
          "signature": "(self, sep=None, maxsplit=-1)",
          "doc": ""
        },
        "rstrip": {
          "signature": "(self, chars=None)",
          "doc": ""
        },
        "split": {
          "signature": "(self, sep=None, maxsplit=-1)",
          "doc": ""
        },
        "splitlines": {
          "signature": "(self, keepends=False)",
          "doc": ""
        },
        "startswith": {
          "signature": "(self, prefix, start=0, end=9223372036854775807)",
          "doc": ""
        },
        "strip": {
          "signature": "(self, chars=None)",
          "doc": ""
        },
        "swapcase": {
          "signature": "(self)",
          "doc": ""
        },
        "title": {
          "signature": "(self)",
          "doc": ""
        },
        "translate": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "upper": {
          "signature": "(self)",
          "doc": ""
        },
        "zfill": {
          "signature": "(self, width)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "collections"
    },
    "defaultdict": {
      "methods": {},
      "doc": "defaultdict(default_factory=None, /, [...]) --> dict with default factory",
      "module": "typing"
    },
    "deque": {
      "methods": {},
      "doc": "deque([iterable[, maxlen]]) --> deque object",
      "module": "email.feedparser"
    },
    "AsyncGeneratorType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "BuiltinFunctionType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'builtin_function_or_method' objects>",
      "module": "types"
    },
    "BuiltinMethodType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'builtin_function_or_method' objects>",
      "module": "types"
    },
    "CellType": {
      "methods": {},
      "doc": "Create a new cell object.",
      "module": "types"
    },
    "ClassMethodDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'classmethod_descriptor' objects>",
      "module": "types"
    },
    "CodeType": {
      "methods": {},
      "doc": "Create a code object.  Not for the faint of heart.",
      "module": "types"
    },
    "CoroutineType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "DynamicClassAttribute": {
      "methods": {
        "deleter": {
          "signature": "(self, fdel)",
          "doc": ""
        },
        "getter": {
          "signature": "(self, fget)",
          "doc": ""
        },
        "setter": {
          "signature": "(self, fset)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "enum"
    },
    "EllipsisType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "FrameType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "FunctionType": {
      "methods": {},
      "doc": "Create a function object.",
      "module": "dataclasses"
    },
    "GeneratorType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "GetSetDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'getset_descriptor' objects>",
      "module": "types"
    },
    "LambdaType": {
      "methods": {},
      "doc": "Create a function object.",
      "module": "types"
    },
    "MappingProxyType": {
      "methods": {},
      "doc": "",
      "module": "enum"
    },
    "MemberDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'member_descriptor' objects>",
      "module": "types"
    },
    "MethodDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'method_descriptor' objects>",
      "module": "typing"
    },
    "MethodType": {
      "methods": {},
      "doc": "Create a bound instance method object.",
      "module": "contextlib"
    },
    "MethodWrapperType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'method-wrapper' objects>",
      "module": "typing"
    },
    "ModuleType": {
      "methods": {},
      "doc": "Create a module object.",
      "module": "pkgutil"
    },
    "NoneType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "NotImplementedType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "SimpleNamespace": {
      "methods": {},
      "doc": "A simple attribute-based namespace.",
      "module": "types"
    },
    "TracebackType": {
      "methods": {},
      "doc": "TracebackType(tb_next, tb_frame, tb_lasti, tb_lineno)",
      "module": "eudplib.localize"
    },
    "UnionType": {
      "methods": {},
      "doc": "Represent a PEP 604 union type",
      "module": "types"
    },
    "WrapperDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'wrapper_descriptor' objects>",
      "module": "typing"
    },
    "RLock": {
      "methods": {},
      "doc": "",
      "module": "functools"
    },
    "cached_property": {
      "methods": {},
      "doc": "",
      "module": "functools"
    },
    "partial": {
      "methods": {},
      "doc": "partial(func, *args, **keywords) - new function with partial application",
      "module": "email.charset"
    },
    "partialmethod": {
      "methods": {},
      "doc": "",
      "module": "functools"
    },
    "singledispatchmethod": {
      "methods": {
        "register": {
          "signature": "(self, cls, method=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "functools"
    },
    "AbstractAsyncContextManager": {
      "methods": {},
      "doc": "",
      "module": "contextlib"
    },
    "AbstractContextManager": {
      "methods": {},
      "doc": "",
      "module": "contextlib"
    },
    "AsyncContextDecorator": {
      "methods": {},
      "doc": "",
      "module": "contextlib"
    },
    "AsyncExitStack": {
      "methods": {
        "aclose": {
          "signature": "(self)",
          "doc": ""
        },
        "callback": {
          "signature": "(self, callback, /, *args, **kwds)",
          "doc": ""
        },
        "enter_async_context": {
          "signature": "(self, cm)",
          "doc": ""
        },
        "enter_context": {
          "signature": "(self, cm)",
          "doc": ""
        },
        "pop_all": {
          "signature": "(self)",
          "doc": ""
        },
        "push": {
          "signature": "(self, exit)",
          "doc": ""
        },
        "push_async_callback": {
          "signature": "(self, callback, /, *args, **kwds)",
          "doc": ""
        },
        "push_async_exit": {
          "signature": "(self, exit)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "contextlib"
    },
    "ContextDecorator": {
      "methods": {},
      "doc": "",
      "module": "contextlib"
    },
    "ExitStack": {
      "methods": {
        "callback": {
          "signature": "(self, callback, /, *args, **kwds)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "enter_context": {
          "signature": "(self, cm)",
          "doc": ""
        },
        "pop_all": {
          "signature": "(self)",
          "doc": ""
        },
        "push": {
          "signature": "(self, exit)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "contextlib"
    },
    "aclosing": {
      "methods": {},
      "doc": "",
      "module": "contextlib"
    },
    "chdir": {
      "methods": {},
      "doc": "",
      "module": "contextlib"
    },
    "closing": {
      "methods": {},
      "doc": "",
      "module": "contextlib"
    },
    "nullcontext": {
      "methods": {},
      "doc": "",
      "module": "ast"
    },
    "redirect_stderr": {
      "methods": {},
      "doc": "",
      "module": "contextlib"
    },
    "redirect_stdout": {
      "methods": {},
      "doc": "",
      "module": "contextlib"
    },
    "suppress": {
      "methods": {},
      "doc": "",
      "module": "traceback"
    },
    "Enum": {
      "methods": {},
      "doc": "",
      "module": "enum"
    },
    "EnumCheck": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "enum"
    },
    "EnumMeta": {
      "methods": {},
      "doc": "",
      "module": "enum"
    },
    "EnumType": {
      "methods": {},
      "doc": "",
      "module": "enum"
    },
    "Flag": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.weapon"
    },
    "FlagBoundary": {
      "methods": {},
      "doc": "",
      "module": "enum"
    },
    "IntEnum": {
      "methods": {},
      "doc": "",
      "module": "http"
    },
    "IntFlag": {
      "methods": {},
      "doc": "",
      "module": "socket"
    },
    "ReprEnum": {
      "methods": {},
      "doc": "",
      "module": "enum"
    },
    "StrEnum": {
      "methods": {},
      "doc": "",
      "module": "http"
    },
    "auto": {
      "methods": {},
      "doc": "",
      "module": "ast"
    },
    "member": {
      "methods": {},
      "doc": "",
      "module": "enum"
    },
    "nonmember": {
      "methods": {},
      "doc": "",
      "module": "enum"
    },
    "verify": {
      "methods": {},
      "doc": "",
      "module": "enum"
    },
    "State": {
      "methods": {
        "checkgroup": {
          "signature": "(self, gid)",
          "doc": ""
        },
        "checklookbehindgroup": {
          "signature": "(self, gid, source)",
          "doc": ""
        },
        "closegroup": {
          "signature": "(self, gid, p)",
          "doc": ""
        },
        "opengroup": {
          "signature": "(self, name=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "re._parser"
    },
    "SubPattern": {
      "methods": {
        "append": {
          "signature": "(self, code)",
          "doc": ""
        },
        "dump": {
          "signature": "(self, level=0)",
          "doc": ""
        },
        "getwidth": {
          "signature": "(self)",
          "doc": ""
        },
        "insert": {
          "signature": "(self, index, code)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "re._parser"
    },
    "Tokenizer": {
      "methods": {
        "checkgroupname": {
          "signature": "(self, name, offset, nested)",
          "doc": ""
        },
        "error": {
          "signature": "(self, msg, offset=0)",
          "doc": ""
        },
        "get": {
          "signature": "(self)",
          "doc": ""
        },
        "getuntil": {
          "signature": "(self, terminator, name)",
          "doc": ""
        },
        "getwhile": {
          "signature": "(self, n, charset)",
          "doc": ""
        },
        "match": {
          "signature": "(self, char)",
          "doc": ""
        },
        "seek": {
          "signature": "(self, index)",
          "doc": ""
        },
        "tell": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "re._parser"
    },
    "Match": {
      "methods": {},
      "doc": "Match(a, b, size)",
      "module": "difflib"
    },
    "Pattern": {
      "methods": {},
      "doc": "Compiled regular expression object.",
      "module": "re"
    },
    "RegexFlag": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "re"
    },
    "Scanner": {
      "methods": {
        "scan": {
          "signature": "(self, string)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "re"
    },
    "Formatter": {
      "methods": {
        "check_unused_args": {
          "signature": "(self, used_args, args, kwargs)",
          "doc": ""
        },
        "convert_field": {
          "signature": "(self, value, conversion)",
          "doc": ""
        },
        "format": {
          "signature": "(self, format_string, /, *args, **kwargs)",
          "doc": ""
        },
        "format_field": {
          "signature": "(self, value, format_spec)",
          "doc": ""
        },
        "get_field": {
          "signature": "(self, field_name, args, kwargs)",
          "doc": ""
        },
        "get_value": {
          "signature": "(self, key, args, kwargs)",
          "doc": ""
        },
        "parse": {
          "signature": "(self, format_string)",
          "doc": ""
        },
        "vformat": {
          "signature": "(self, format_string, args, kwargs)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "string"
    },
    "Template": {
      "methods": {
        "get_identifiers": {
          "signature": "(self)",
          "doc": ""
        },
        "is_valid": {
          "signature": "(self)",
          "doc": ""
        },
        "safe_substitute": {
          "signature": "(self, mapping={}, /, **kws)",
          "doc": ""
        },
        "substitute": {
          "signature": "(self, mapping={}, /, **kws)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "string"
    },
    "BuiltinImporter": {
      "methods": {
        "create_module": {
          "signature": "(spec)",
          "doc": "Create a built-in module"
        },
        "exec_module": {
          "signature": "(module)",
          "doc": "Exec a built-in module"
        },
        "module_repr": {
          "signature": "(module)",
          "doc": "Return repr for the module."
        }
      },
      "doc": "Meta path import for built-in modules.",
      "module": "importlib.machinery"
    },
    "FrozenImporter": {
      "methods": {
        "create_module": {
          "signature": "(spec)",
          "doc": "Set __file__, if able."
        },
        "exec_module": {
          "signature": "(module)",
          "doc": ""
        },
        "module_repr": {
          "signature": "(m)",
          "doc": "Return repr for the module."
        }
      },
      "doc": "Meta path import for frozen modules.",
      "module": "importlib.machinery"
    },
    "ModuleSpec": {
      "methods": {},
      "doc": "The specification for a module, used for loading.",
      "module": "importlib.machinery"
    },
    "ExtensionFileLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Create an uninitialized extension module"
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Initialize an extension module"
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "Return None as an extension module cannot create a code object."
        },
        "get_data": {
          "signature": "(self, path)",
          "doc": "Return the data from path as raw bytes."
        },
        "get_filename": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Return the path to the source file as found by the finder."
        },
        "get_resource_reader": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Return None as extension modules have no source code."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Return True if the extension module is a package."
        },
        "load_module": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Load a module from a file."
        }
      },
      "doc": "Loader for extension modules.",
      "module": "importlib.machinery"
    },
    "FileFinder": {
      "methods": {
        "find_loader": {
          "signature": "(self, fullname)",
          "doc": "Try to find a loader for the specified module, or the namespace"
        },
        "find_module": {
          "signature": "(self, fullname)",
          "doc": "Try to find a loader for the specified module by delegating to"
        },
        "find_spec": {
          "signature": "(self, fullname, target=None)",
          "doc": "Try to find a spec for the specified module."
        },
        "invalidate_caches": {
          "signature": "(self)",
          "doc": "Invalidate the directory mtime."
        }
      },
      "doc": "File-based finder.",
      "module": "eudplib.epscript.epsimp"
    },
    "FileLoader": {
      "methods": {
        "get_data": {
          "signature": "(self, path)",
          "doc": "Return the data from path as raw bytes."
        },
        "get_filename": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Return the path to the source file as found by the finder."
        },
        "get_resource_reader": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": ""
        },
        "load_module": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Load a module from a file."
        }
      },
      "doc": "Base file loader class which implements the loader protocol methods that",
      "module": "importlib._bootstrap_external"
    },
    "NamespaceLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Use default semantics for module creation."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": ""
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": ""
        },
        "get_resource_reader": {
          "signature": "(self, module)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": ""
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": ""
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": "Load a namespace module."
        },
        "module_repr": {
          "signature": "(module)",
          "doc": "Return repr for the module."
        }
      },
      "doc": "",
      "module": "importlib.machinery"
    },
    "PathFinder": {
      "methods": {
        "find_distributions": {
          "signature": "(*args, **kwargs)",
          "doc": ""
        },
        "invalidate_caches": {
          "signature": "()",
          "doc": "Call the invalidate_caches() method on all path entry finders"
        }
      },
      "doc": "Meta path finder for sys.path and package __path__ attributes.",
      "module": "importlib.machinery"
    },
    "SourceFileLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Use default semantics for module creation."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_code."
        },
        "get_data": {
          "signature": "(self, path)",
          "doc": "Return the data from path as raw bytes."
        },
        "get_filename": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Return the path to the source file as found by the finder."
        },
        "get_resource_reader": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_source."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.is_package by checking if"
        },
        "load_module": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Load a module from a file."
        },
        "path_mtime": {
          "signature": "(self, path)",
          "doc": "Optional method that returns the modification time (an int) for the"
        },
        "path_stats": {
          "signature": "(self, path)",
          "doc": "Return the metadata for the path."
        },
        "set_data": {
          "signature": "(self, path, data, *, _mode=438)",
          "doc": "Write bytes data to a file."
        },
        "source_to_code": {
          "signature": "(self, data, path, *, _optimize=-1)",
          "doc": "Return the code object compiled from source."
        }
      },
      "doc": "Concrete implementation of SourceLoader using the file system.",
      "module": "pluginLoader"
    },
    "SourceLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Use default semantics for module creation."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_code."
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_source."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.is_package by checking if"
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": "This method is deprecated."
        },
        "path_mtime": {
          "signature": "(self, path)",
          "doc": "Optional method that returns the modification time (an int) for the"
        },
        "path_stats": {
          "signature": "(self, path)",
          "doc": "Optional method returning a metadata dict for the specified"
        },
        "set_data": {
          "signature": "(self, path, data)",
          "doc": "Optional method which writes data (bytes) to a file path (a str)."
        },
        "source_to_code": {
          "signature": "(self, data, path, *, _optimize=-1)",
          "doc": "Return the code object compiled from source."
        }
      },
      "doc": "",
      "module": "importlib._bootstrap_external"
    },
    "SourcelessFileLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Use default semantics for module creation."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": ""
        },
        "get_data": {
          "signature": "(self, path)",
          "doc": "Return the data from path as raw bytes."
        },
        "get_filename": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Return the path to the source file as found by the finder."
        },
        "get_resource_reader": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Return None as there is no source code."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.is_package by checking if"
        },
        "load_module": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Load a module from a file."
        }
      },
      "doc": "Loader which handles sourceless file imports.",
      "module": "importlib.machinery"
    },
    "WindowsRegistryFinder": {
      "methods": {},
      "doc": "Meta path finder for modules declared in the Windows registry.",
      "module": "importlib.machinery"
    },
    "WarningMessage": {
      "methods": {},
      "doc": "",
      "module": "warnings"
    },
    "catch_warnings": {
      "methods": {},
      "doc": "",
      "module": "warnings"
    },
    "Loader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": ""
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": ""
        },
        "module_repr": {
          "signature": "(self, module)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "importlib.util"
    },
    "Barrier": {
      "methods": {
        "abort": {
          "signature": "(self)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "wait": {
          "signature": "(self, timeout=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "threading"
    },
    "BoundedSemaphore": {
      "methods": {
        "acquire": {
          "signature": "(self, blocking=True, timeout=None)",
          "doc": ""
        },
        "release": {
          "signature": "(self, n=1)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "threading"
    },
    "BrokenBarrierError": {
      "methods": {},
      "doc": "",
      "module": "threading"
    },
    "Condition": {
      "methods": {
        "CheckArgs": {
          "signature": "(self, i: 'int') -> 'None'",
          "doc": ""
        },
        "CollectDependency": {
          "signature": "(self, pbuffer: 'ObjCollector') -> 'None'",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> 'RlocInt_C'",
          "doc": ""
        },
        "SetParentTrigger": {
          "signature": "(self, trg: 'RawTrigger', index: 'int') -> 'None'",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, pbuffer: '_PayloadBuffer') -> 'None'",
          "doc": ""
        },
        "disable": {
          "signature": "(self) -> 'None'",
          "doc": ""
        },
        "negate": {
          "signature": "(self) -> 'None'",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "Event": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": ""
        },
        "isSet": {
          "signature": "(self)",
          "doc": ""
        },
        "is_set": {
          "signature": "(self)",
          "doc": ""
        },
        "set": {
          "signature": "(self)",
          "doc": ""
        },
        "wait": {
          "signature": "(self, timeout=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "threading"
    },
    "ExceptHookArgs": {
      "methods": {},
      "doc": "ExceptHookArgs",
      "module": "threading"
    },
    "Semaphore": {
      "methods": {
        "acquire": {
          "signature": "(self, blocking=True, timeout=None)",
          "doc": ""
        },
        "release": {
          "signature": "(self, n=1)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "threading"
    },
    "Thread": {
      "methods": {
        "getName": {
          "signature": "(self)",
          "doc": ""
        },
        "isDaemon": {
          "signature": "(self)",
          "doc": ""
        },
        "is_alive": {
          "signature": "(self)",
          "doc": ""
        },
        "join": {
          "signature": "(self, timeout=None)",
          "doc": ""
        },
        "run": {
          "signature": "(self)",
          "doc": ""
        },
        "setDaemon": {
          "signature": "(self, daemonic)",
          "doc": ""
        },
        "setName": {
          "signature": "(self, name)",
          "doc": ""
        },
        "start": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "autoupdate"
    },
    "ThreadError": {
      "methods": {},
      "doc": "Unspecified run-time error.",
      "module": "threading"
    },
    "Timer": {
      "methods": {
        "cancel": {
          "signature": "(self)",
          "doc": ""
        },
        "getName": {
          "signature": "(self)",
          "doc": ""
        },
        "isDaemon": {
          "signature": "(self)",
          "doc": ""
        },
        "is_alive": {
          "signature": "(self)",
          "doc": ""
        },
        "join": {
          "signature": "(self, timeout=None)",
          "doc": ""
        },
        "run": {
          "signature": "(self)",
          "doc": ""
        },
        "setDaemon": {
          "signature": "(self, daemonic)",
          "doc": ""
        },
        "setName": {
          "signature": "(self, name)",
          "doc": ""
        },
        "start": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "threading"
    },
    "WeakSet": {
      "methods": {
        "add": {
          "signature": "(self, item)",
          "doc": ""
        },
        "clear": {
          "signature": "(self)",
          "doc": ""
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "difference": {
          "signature": "(self, other)",
          "doc": ""
        },
        "difference_update": {
          "signature": "(self, other)",
          "doc": ""
        },
        "discard": {
          "signature": "(self, item)",
          "doc": ""
        },
        "intersection": {
          "signature": "(self, other)",
          "doc": ""
        },
        "intersection_update": {
          "signature": "(self, other)",
          "doc": ""
        },
        "isdisjoint": {
          "signature": "(self, other)",
          "doc": ""
        },
        "issubset": {
          "signature": "(self, other)",
          "doc": ""
        },
        "issuperset": {
          "signature": "(self, other)",
          "doc": ""
        },
        "pop": {
          "signature": "(self)",
          "doc": ""
        },
        "remove": {
          "signature": "(self, item)",
          "doc": ""
        },
        "symmetric_difference": {
          "signature": "(self, other)",
          "doc": ""
        },
        "symmetric_difference_update": {
          "signature": "(self, other)",
          "doc": ""
        },
        "union": {
          "signature": "(self, other)",
          "doc": ""
        },
        "update": {
          "signature": "(self, other)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "weakref"
    },
    "local": {
      "methods": {},
      "doc": "Thread-local data",
      "module": "threading"
    },
    "LazyLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": ""
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Make the module load lazily."
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": ""
        },
        "module_repr": {
          "signature": "(self, module)",
          "doc": ""
        }
      },
      "doc": "A loader that creates a module which defers loading until attribute access.",
      "module": "importlib.util"
    },
    "Handlers": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "signal"
    },
    "Signals": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "signal"
    },
    "AuthenticationString": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing.process"
    },
    "BaseProcess": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "is_alive": {
          "signature": "(self)",
          "doc": ""
        },
        "join": {
          "signature": "(self, timeout=None)",
          "doc": ""
        },
        "kill": {
          "signature": "(self)",
          "doc": ""
        },
        "run": {
          "signature": "(self)",
          "doc": ""
        },
        "start": {
          "signature": "(self)",
          "doc": ""
        },
        "terminate": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing.process"
    },
    "Struct": {
      "methods": {},
      "doc": "Struct(fmt) --> compiled struct object",
      "module": "struct"
    },
    "PickleBuffer": {
      "methods": {},
      "doc": "Wrapper for potentially out-of-band buffers",
      "module": "pickle"
    },
    "PickleError": {
      "methods": {},
      "doc": "",
      "module": "pickle"
    },
    "Pickler": {
      "methods": {},
      "doc": "This takes a binary file for writing a pickle data stream.",
      "module": "pickle"
    },
    "PicklingError": {
      "methods": {},
      "doc": "",
      "module": "pickle"
    },
    "Unpickler": {
      "methods": {},
      "doc": "This takes a binary file for reading a pickle data stream.",
      "module": "pickle"
    },
    "UnpicklingError": {
      "methods": {},
      "doc": "",
      "module": "pickle"
    },
    "AsyncGenerator": {
      "methods": {
        "aclose": {
          "signature": "(self)",
          "doc": "Raise GeneratorExit inside coroutine."
        },
        "asend": {
          "signature": "(self, value)",
          "doc": "Send a value into the asynchronous generator."
        },
        "athrow": {
          "signature": "(self, typ, val=None, tb=None)",
          "doc": "Raise an exception in the asynchronous generator."
        }
      },
      "doc": "",
      "module": "collections.abc"
    },
    "AsyncIterable": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "AsyncIterator": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "Awaitable": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "ByteString": {
      "methods": {
        "count": {
          "signature": "(self, value)",
          "doc": "S.count(value) -> integer -- return number of occurrences of value"
        },
        "index": {
          "signature": "(self, value, start=0, stop=None)",
          "doc": "S.index(value, [start, [stop]]) -> integer -- return first index of value."
        }
      },
      "doc": "This unifies bytes and bytearray.",
      "module": "eudplib.maprw.injector.payload_init"
    },
    "Callable": {
      "methods": {},
      "doc": "",
      "module": "eudplib.epscript.linetable_calculator"
    },
    "Collection": {
      "methods": {},
      "doc": "",
      "module": "eudplib.maprw.inlinecode.btinliner"
    },
    "Container": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "Coroutine": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Raise GeneratorExit inside coroutine."
        },
        "send": {
          "signature": "(self, value)",
          "doc": "Send a value into the coroutine."
        },
        "throw": {
          "signature": "(self, typ, val=None, tb=None)",
          "doc": "Raise an exception in the coroutine."
        }
      },
      "doc": "",
      "module": "collections.abc"
    },
    "Generator": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Raise GeneratorExit inside generator."
        },
        "send": {
          "signature": "(self, value)",
          "doc": "Send a value into the generator."
        },
        "throw": {
          "signature": "(self, typ, val=None, tb=None)",
          "doc": "Raise an exception in the generator."
        }
      },
      "doc": "",
      "module": "collections.abc"
    },
    "Hashable": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "ItemsView": {
      "methods": {
        "isdisjoint": {
          "signature": "(self, other)",
          "doc": "Return True if two sets have a null intersection."
        }
      },
      "doc": "",
      "module": "collections.abc"
    },
    "Iterable": {
      "methods": {},
      "doc": "",
      "module": "eudplib.trigger.ptrigger"
    },
    "Iterator": {
      "methods": {},
      "doc": "",
      "module": "eudplib.epscript.linetable_calculator"
    },
    "KeysView": {
      "methods": {
        "isdisjoint": {
          "signature": "(self, other)",
          "doc": "Return True if two sets have a null intersection."
        }
      },
      "doc": "",
      "module": "collections.abc"
    },
    "MappingView": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "MutableSequence": {
      "methods": {
        "append": {
          "signature": "(self, value)",
          "doc": "S.append(value) -- append value to the end of the sequence"
        },
        "clear": {
          "signature": "(self)",
          "doc": "S.clear() -> None -- remove all items from S"
        },
        "count": {
          "signature": "(self, value)",
          "doc": "S.count(value) -> integer -- return number of occurrences of value"
        },
        "extend": {
          "signature": "(self, values)",
          "doc": "S.extend(iterable) -- extend sequence by appending elements from the iterable"
        },
        "index": {
          "signature": "(self, value, start=0, stop=None)",
          "doc": "S.index(value, [start, [stop]]) -> integer -- return first index of value."
        },
        "insert": {
          "signature": "(self, index, value)",
          "doc": "S.insert(index, value) -- insert value before index"
        },
        "pop": {
          "signature": "(self, index=-1)",
          "doc": "S.pop([index]) -> item -- remove and return item at index (default last)."
        },
        "remove": {
          "signature": "(self, value)",
          "doc": "S.remove(value) -- remove first occurrence of value."
        },
        "reverse": {
          "signature": "(self)",
          "doc": "S.reverse() -- reverse *IN PLACE*"
        }
      },
      "doc": "All the operations on a read-write sequence.",
      "module": "collections.abc"
    },
    "MutableSet": {
      "methods": {
        "add": {
          "signature": "(self, value)",
          "doc": "Add an element."
        },
        "clear": {
          "signature": "(self)",
          "doc": "This is slow (creates N new iterators!) but effective."
        },
        "discard": {
          "signature": "(self, value)",
          "doc": "Remove an element.  Do not raise an exception if absent."
        },
        "isdisjoint": {
          "signature": "(self, other)",
          "doc": "Return True if two sets have a null intersection."
        },
        "pop": {
          "signature": "(self)",
          "doc": "Return the popped value.  Raise KeyError if empty."
        },
        "remove": {
          "signature": "(self, value)",
          "doc": "Remove an element. If not a member, raise a KeyError."
        }
      },
      "doc": "A mutable set is a finite, iterable container.",
      "module": "collections.abc"
    },
    "Reversible": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "Sequence": {
      "methods": {
        "count": {
          "signature": "(self, value)",
          "doc": "S.count(value) -> integer -- return number of occurrences of value"
        },
        "index": {
          "signature": "(self, value, start=0, stop=None)",
          "doc": "S.index(value, [start, [stop]]) -> integer -- return first index of value."
        }
      },
      "doc": "All the operations on a read-only sequence.",
      "module": "pathlib"
    },
    "Set": {
      "methods": {},
      "doc": "Set(expr* elts)",
      "module": "ast"
    },
    "Sized": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "ValuesView": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "BaseSelector": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "get_key": {
          "signature": "(self, fileobj)",
          "doc": ""
        },
        "get_map": {
          "signature": "(self)",
          "doc": ""
        },
        "modify": {
          "signature": "(self, fileobj, events, data=None)",
          "doc": ""
        },
        "register": {
          "signature": "(self, fileobj, events, data=None)",
          "doc": ""
        },
        "select": {
          "signature": "(self, timeout=None)",
          "doc": ""
        },
        "unregister": {
          "signature": "(self, fileobj)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "selectors"
    },
    "DefaultSelector": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "get_key": {
          "signature": "(self, fileobj)",
          "doc": ""
        },
        "get_map": {
          "signature": "(self)",
          "doc": ""
        },
        "modify": {
          "signature": "(self, fileobj, events, data=None)",
          "doc": ""
        },
        "register": {
          "signature": "(self, fileobj, events, data=None)",
          "doc": ""
        },
        "select": {
          "signature": "(self, timeout=None)",
          "doc": ""
        },
        "unregister": {
          "signature": "(self, fileobj)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "selectors"
    },
    "SelectSelector": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "get_key": {
          "signature": "(self, fileobj)",
          "doc": ""
        },
        "get_map": {
          "signature": "(self)",
          "doc": ""
        },
        "modify": {
          "signature": "(self, fileobj, events, data=None)",
          "doc": ""
        },
        "register": {
          "signature": "(self, fileobj, events, data=None)",
          "doc": ""
        },
        "select": {
          "signature": "(self, timeout=None)",
          "doc": ""
        },
        "unregister": {
          "signature": "(self, fileobj)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "selectors"
    },
    "SelectorKey": {
      "methods": {},
      "doc": "SelectorKey(fileobj, fd, events, data)",
      "module": "selectors"
    },
    "AddressFamily": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "socket"
    },
    "AddressInfo": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "socket"
    },
    "MsgFlag": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "socket"
    },
    "SocketIO": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "fileno": {
          "signature": "(self)",
          "doc": ""
        },
        "readable": {
          "signature": "(self)",
          "doc": ""
        },
        "readinto": {
          "signature": "(self, b)",
          "doc": ""
        },
        "seekable": {
          "signature": "(self)",
          "doc": ""
        },
        "writable": {
          "signature": "(self)",
          "doc": ""
        },
        "write": {
          "signature": "(self, b)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "socket"
    },
    "SocketKind": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "socket"
    },
    "SocketType": {
      "methods": {},
      "doc": "socket(family=AF_INET, type=SOCK_STREAM, proto=0) -> socket object",
      "module": "socket"
    },
    "gaierror": {
      "methods": {},
      "doc": "",
      "module": "socket"
    },
    "herror": {
      "methods": {},
      "doc": "",
      "module": "socket"
    },
    "socket": {
      "methods": {
        "accept": {
          "signature": "(self)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "detach": {
          "signature": "(self)",
          "doc": ""
        },
        "dup": {
          "signature": "(self)",
          "doc": ""
        },
        "get_inheritable": {
          "signature": "(self)",
          "doc": "Get the inheritable flag of the socket"
        },
        "makefile": {
          "signature": "(self, mode='r', buffering=None, *, encoding=None, errors=None, newline=None)",
          "doc": ""
        },
        "sendfile": {
          "signature": "(self, file, offset=0, count=None)",
          "doc": ""
        },
        "set_inheritable": {
          "signature": "(self, inheritable)",
          "doc": "Set the inheritable flag of the socket"
        }
      },
      "doc": "",
      "module": "ssl"
    },
    "timeout": {
      "methods": {},
      "doc": "Timeout expired.",
      "module": "socket"
    },
    "AbstractReducer": {
      "methods": {
        "dump": {
          "signature": "(obj, file, protocol=None)",
          "doc": ""
        },
        "duplicate": {
          "signature": "(handle, target_process=None, inheritable=False, *, source_process=None)",
          "doc": ""
        },
        "recv_handle": {
          "signature": "(conn)",
          "doc": ""
        },
        "send_handle": {
          "signature": "(conn, handle, destination_pid)",
          "doc": ""
        },
        "steal_handle": {
          "signature": "(source_pid, handle)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing.reduction"
    },
    "DupHandle": {
      "methods": {
        "detach": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing.reduction"
    },
    "ForkingPickler": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing.reduction"
    },
    "AuthenticationError": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing"
    },
    "BaseContext": {
      "methods": {
        "Array": {
          "signature": "(self, typecode_or_type, size_or_initializer, *, lock=True)",
          "doc": ""
        },
        "Barrier": {
          "signature": "(self, parties, action=None, timeout=None)",
          "doc": ""
        },
        "BoundedSemaphore": {
          "signature": "(self, value=1)",
          "doc": ""
        },
        "Condition": {
          "signature": "(self, lock=None)",
          "doc": ""
        },
        "Event": {
          "signature": "(self)",
          "doc": ""
        },
        "JoinableQueue": {
          "signature": "(self, maxsize=0)",
          "doc": ""
        },
        "Lock": {
          "signature": "(self)",
          "doc": ""
        },
        "Manager": {
          "signature": "(self)",
          "doc": ""
        },
        "Pipe": {
          "signature": "(self, duplex=True)",
          "doc": ""
        },
        "Pool": {
          "signature": "(self, processes=None, initializer=None, initargs=(), maxtasksperchild=None)",
          "doc": ""
        },
        "Queue": {
          "signature": "(self, maxsize=0)",
          "doc": ""
        },
        "RLock": {
          "signature": "(self)",
          "doc": ""
        },
        "RawArray": {
          "signature": "(self, typecode_or_type, size_or_initializer)",
          "doc": ""
        },
        "RawValue": {
          "signature": "(self, typecode_or_type, *args)",
          "doc": ""
        },
        "Semaphore": {
          "signature": "(self, value=1)",
          "doc": ""
        },
        "SimpleQueue": {
          "signature": "(self)",
          "doc": ""
        },
        "Value": {
          "signature": "(self, typecode_or_type, *args, lock=True)",
          "doc": ""
        },
        "active_children": {
          "signature": "()",
          "doc": ""
        },
        "allow_connection_pickling": {
          "signature": "(self)",
          "doc": ""
        },
        "cpu_count": {
          "signature": "(self)",
          "doc": ""
        },
        "current_process": {
          "signature": "()",
          "doc": ""
        },
        "freeze_support": {
          "signature": "(self)",
          "doc": ""
        },
        "get_context": {
          "signature": "(self, method=None)",
          "doc": ""
        },
        "get_logger": {
          "signature": "(self)",
          "doc": ""
        },
        "get_start_method": {
          "signature": "(self, allow_none=False)",
          "doc": ""
        },
        "log_to_stderr": {
          "signature": "(self, level=None)",
          "doc": ""
        },
        "parent_process": {
          "signature": "()",
          "doc": ""
        },
        "set_executable": {
          "signature": "(self, executable)",
          "doc": ""
        },
        "set_forkserver_preload": {
          "signature": "(self, module_names)",
          "doc": ""
        },
        "set_start_method": {
          "signature": "(self, method, force=False)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing.context"
    },
    "BufferTooShort": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing"
    },
    "DefaultContext": {
      "methods": {
        "Array": {
          "signature": "(self, typecode_or_type, size_or_initializer, *, lock=True)",
          "doc": ""
        },
        "Barrier": {
          "signature": "(self, parties, action=None, timeout=None)",
          "doc": ""
        },
        "BoundedSemaphore": {
          "signature": "(self, value=1)",
          "doc": ""
        },
        "Condition": {
          "signature": "(self, lock=None)",
          "doc": ""
        },
        "Event": {
          "signature": "(self)",
          "doc": ""
        },
        "JoinableQueue": {
          "signature": "(self, maxsize=0)",
          "doc": ""
        },
        "Lock": {
          "signature": "(self)",
          "doc": ""
        },
        "Manager": {
          "signature": "(self)",
          "doc": ""
        },
        "Pipe": {
          "signature": "(self, duplex=True)",
          "doc": ""
        },
        "Pool": {
          "signature": "(self, processes=None, initializer=None, initargs=(), maxtasksperchild=None)",
          "doc": ""
        },
        "Queue": {
          "signature": "(self, maxsize=0)",
          "doc": ""
        },
        "RLock": {
          "signature": "(self)",
          "doc": ""
        },
        "RawArray": {
          "signature": "(self, typecode_or_type, size_or_initializer)",
          "doc": ""
        },
        "RawValue": {
          "signature": "(self, typecode_or_type, *args)",
          "doc": ""
        },
        "Semaphore": {
          "signature": "(self, value=1)",
          "doc": ""
        },
        "SimpleQueue": {
          "signature": "(self)",
          "doc": ""
        },
        "Value": {
          "signature": "(self, typecode_or_type, *args, lock=True)",
          "doc": ""
        },
        "active_children": {
          "signature": "()",
          "doc": ""
        },
        "allow_connection_pickling": {
          "signature": "(self)",
          "doc": ""
        },
        "cpu_count": {
          "signature": "(self)",
          "doc": ""
        },
        "current_process": {
          "signature": "()",
          "doc": ""
        },
        "freeze_support": {
          "signature": "(self)",
          "doc": ""
        },
        "get_all_start_methods": {
          "signature": "(self)",
          "doc": ""
        },
        "get_context": {
          "signature": "(self, method=None)",
          "doc": ""
        },
        "get_logger": {
          "signature": "(self)",
          "doc": ""
        },
        "get_start_method": {
          "signature": "(self, allow_none=False)",
          "doc": ""
        },
        "log_to_stderr": {
          "signature": "(self, level=None)",
          "doc": ""
        },
        "parent_process": {
          "signature": "()",
          "doc": ""
        },
        "set_executable": {
          "signature": "(self, executable)",
          "doc": ""
        },
        "set_forkserver_preload": {
          "signature": "(self, module_names)",
          "doc": ""
        },
        "set_start_method": {
          "signature": "(self, method, force=False)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing.context"
    },
    "Process": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "is_alive": {
          "signature": "(self)",
          "doc": ""
        },
        "join": {
          "signature": "(self, timeout=None)",
          "doc": ""
        },
        "kill": {
          "signature": "(self)",
          "doc": ""
        },
        "run": {
          "signature": "(self)",
          "doc": ""
        },
        "start": {
          "signature": "(self)",
          "doc": ""
        },
        "terminate": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing"
    },
    "ProcessError": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing"
    },
    "SpawnContext": {
      "methods": {
        "Array": {
          "signature": "(self, typecode_or_type, size_or_initializer, *, lock=True)",
          "doc": ""
        },
        "Barrier": {
          "signature": "(self, parties, action=None, timeout=None)",
          "doc": ""
        },
        "BoundedSemaphore": {
          "signature": "(self, value=1)",
          "doc": ""
        },
        "Condition": {
          "signature": "(self, lock=None)",
          "doc": ""
        },
        "Event": {
          "signature": "(self)",
          "doc": ""
        },
        "JoinableQueue": {
          "signature": "(self, maxsize=0)",
          "doc": ""
        },
        "Lock": {
          "signature": "(self)",
          "doc": ""
        },
        "Manager": {
          "signature": "(self)",
          "doc": ""
        },
        "Pipe": {
          "signature": "(self, duplex=True)",
          "doc": ""
        },
        "Pool": {
          "signature": "(self, processes=None, initializer=None, initargs=(), maxtasksperchild=None)",
          "doc": ""
        },
        "Queue": {
          "signature": "(self, maxsize=0)",
          "doc": ""
        },
        "RLock": {
          "signature": "(self)",
          "doc": ""
        },
        "RawArray": {
          "signature": "(self, typecode_or_type, size_or_initializer)",
          "doc": ""
        },
        "RawValue": {
          "signature": "(self, typecode_or_type, *args)",
          "doc": ""
        },
        "Semaphore": {
          "signature": "(self, value=1)",
          "doc": ""
        },
        "SimpleQueue": {
          "signature": "(self)",
          "doc": ""
        },
        "Value": {
          "signature": "(self, typecode_or_type, *args, lock=True)",
          "doc": ""
        },
        "active_children": {
          "signature": "()",
          "doc": ""
        },
        "allow_connection_pickling": {
          "signature": "(self)",
          "doc": ""
        },
        "cpu_count": {
          "signature": "(self)",
          "doc": ""
        },
        "current_process": {
          "signature": "()",
          "doc": ""
        },
        "freeze_support": {
          "signature": "(self)",
          "doc": ""
        },
        "get_context": {
          "signature": "(self, method=None)",
          "doc": ""
        },
        "get_logger": {
          "signature": "(self)",
          "doc": ""
        },
        "get_start_method": {
          "signature": "(self, allow_none=False)",
          "doc": ""
        },
        "log_to_stderr": {
          "signature": "(self, level=None)",
          "doc": ""
        },
        "parent_process": {
          "signature": "()",
          "doc": ""
        },
        "set_executable": {
          "signature": "(self, executable)",
          "doc": ""
        },
        "set_forkserver_preload": {
          "signature": "(self, module_names)",
          "doc": ""
        },
        "set_start_method": {
          "signature": "(self, method, force=False)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing.context"
    },
    "SpawnProcess": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "is_alive": {
          "signature": "(self)",
          "doc": ""
        },
        "join": {
          "signature": "(self, timeout=None)",
          "doc": ""
        },
        "kill": {
          "signature": "(self)",
          "doc": ""
        },
        "run": {
          "signature": "(self)",
          "doc": ""
        },
        "start": {
          "signature": "(self)",
          "doc": ""
        },
        "terminate": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing.context"
    },
    "BinaryIO": {
      "methods": {
        "close": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "fileno": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "flush": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "isatty": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "read": {
          "signature": "(self, n: int = -1) -> ~AnyStr",
          "doc": ""
        },
        "readable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "readline": {
          "signature": "(self, limit: int = -1) -> ~AnyStr",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, hint: int = -1) -> List[~AnyStr]",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset: int, whence: int = 0) -> int",
          "doc": ""
        },
        "seekable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "tell": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "truncate": {
          "signature": "(self, size: int = None) -> int",
          "doc": ""
        },
        "writable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "write": {
          "signature": "(self, s: Union[bytes, bytearray]) -> int",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, lines: List[~AnyStr]) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "typing_extensions"
    },
    "IO": {
      "methods": {
        "close": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "fileno": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "flush": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "isatty": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "read": {
          "signature": "(self, n: int = -1) -> ~AnyStr",
          "doc": ""
        },
        "readable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "readline": {
          "signature": "(self, limit: int = -1) -> ~AnyStr",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, hint: int = -1) -> List[~AnyStr]",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset: int, whence: int = 0) -> int",
          "doc": ""
        },
        "seekable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "tell": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "truncate": {
          "signature": "(self, size: int = None) -> int",
          "doc": ""
        },
        "writable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "write": {
          "signature": "(self, s: ~AnyStr) -> int",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, lines: List[~AnyStr]) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "typing_extensions"
    },
    "TextIO": {
      "methods": {
        "close": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "fileno": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "flush": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "isatty": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "read": {
          "signature": "(self, n: int = -1) -> ~AnyStr",
          "doc": ""
        },
        "readable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "readline": {
          "signature": "(self, limit: int = -1) -> ~AnyStr",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, hint: int = -1) -> List[~AnyStr]",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset: int, whence: int = 0) -> int",
          "doc": ""
        },
        "seekable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "tell": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "truncate": {
          "signature": "(self, size: int = None) -> int",
          "doc": ""
        },
        "writable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "write": {
          "signature": "(self, s: ~AnyStr) -> int",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, lines: List[~AnyStr]) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "typing_extensions"
    },
    "Annotated": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "Any": {
      "methods": {},
      "doc": "",
      "module": "eudplib.epscript.linetable_calculator"
    },
    "ForwardRef": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "Generic": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "NamedTupleMeta": {
      "methods": {},
      "doc": "",
      "module": "typing"
    },
    "NewType": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "ParamSpec": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "ParamSpecArgs": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "ParamSpecKwargs": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "Protocol": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "SupportsAbs": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "SupportsBytes": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "SupportsComplex": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "SupportsFloat": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "SupportsIndex": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "SupportsInt": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "SupportsRound": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "Text": {
      "methods": {},
      "doc": "str(object='') -> str",
      "module": "typing_extensions"
    },
    "TypeVar": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.csprite"
    },
    "TypeVarTuple": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "io": {
      "methods": {},
      "doc": "",
      "module": "typing"
    },
    "re": {
      "methods": {},
      "doc": "",
      "module": "typing"
    },
    "GNUTranslations": {
      "methods": {
        "add_fallback": {
          "signature": "(self, fallback)",
          "doc": ""
        },
        "charset": {
          "signature": "(self)",
          "doc": ""
        },
        "gettext": {
          "signature": "(self, message)",
          "doc": ""
        },
        "info": {
          "signature": "(self)",
          "doc": ""
        },
        "install": {
          "signature": "(self, names=None)",
          "doc": ""
        },
        "ngettext": {
          "signature": "(self, msgid1, msgid2, n)",
          "doc": ""
        },
        "npgettext": {
          "signature": "(self, context, msgid1, msgid2, n)",
          "doc": ""
        },
        "pgettext": {
          "signature": "(self, context, message)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "gettext"
    },
    "NullTranslations": {
      "methods": {
        "add_fallback": {
          "signature": "(self, fallback)",
          "doc": ""
        },
        "charset": {
          "signature": "(self)",
          "doc": ""
        },
        "gettext": {
          "signature": "(self, message)",
          "doc": ""
        },
        "info": {
          "signature": "(self)",
          "doc": ""
        },
        "install": {
          "signature": "(self, names=None)",
          "doc": ""
        },
        "ngettext": {
          "signature": "(self, msgid1, msgid2, n)",
          "doc": ""
        },
        "npgettext": {
          "signature": "(self, context, msgid1, msgid2, n)",
          "doc": ""
        },
        "pgettext": {
          "signature": "(self, context, message)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "gettext"
    },
    "Error": {
      "methods": {},
      "doc": "",
      "module": "binascii"
    },
    "EPError": {
      "methods": {},
      "doc": "",
      "module": "freeze.freeze"
    },
    "EPWarning": {
      "methods": {},
      "doc": "",
      "module": "freeze.freeze"
    },
    "TriggerScopeError": {
      "methods": {},
      "doc": "",
      "module": "freeze.freeze"
    },
    "BlockStruManager": {
      "methods": {
        "empty": {
          "signature": "(self) -> bool",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.maprw.injector.apply_injector"
    },
    "Random": {
      "methods": {
        "betavariate": {
          "signature": "(self, alpha, beta)",
          "doc": ""
        },
        "choice": {
          "signature": "(self, seq)",
          "doc": ""
        },
        "choices": {
          "signature": "(self, population, weights=None, *, cum_weights=None, k=1)",
          "doc": ""
        },
        "expovariate": {
          "signature": "(self, lambd)",
          "doc": ""
        },
        "gammavariate": {
          "signature": "(self, alpha, beta)",
          "doc": ""
        },
        "gauss": {
          "signature": "(self, mu=0.0, sigma=1.0)",
          "doc": ""
        },
        "getstate": {
          "signature": "(self)",
          "doc": ""
        },
        "lognormvariate": {
          "signature": "(self, mu, sigma)",
          "doc": ""
        },
        "normalvariate": {
          "signature": "(self, mu=0.0, sigma=1.0)",
          "doc": ""
        },
        "paretovariate": {
          "signature": "(self, alpha)",
          "doc": ""
        },
        "randbytes": {
          "signature": "(self, n)",
          "doc": ""
        },
        "randint": {
          "signature": "(self, a, b)",
          "doc": ""
        },
        "randrange": {
          "signature": "(self, start, stop=None, step=1)",
          "doc": ""
        },
        "sample": {
          "signature": "(self, population, k, *, counts=None)",
          "doc": ""
        },
        "seed": {
          "signature": "(self, a=None, version=2)",
          "doc": ""
        },
        "setstate": {
          "signature": "(self, state)",
          "doc": ""
        },
        "shuffle": {
          "signature": "(self, x)",
          "doc": ""
        },
        "triangular": {
          "signature": "(self, low=0.0, high=1.0, mode=None)",
          "doc": ""
        },
        "uniform": {
          "signature": "(self, a, b)",
          "doc": ""
        },
        "vonmisesvariate": {
          "signature": "(self, mu, kappa)",
          "doc": ""
        },
        "weibullvariate": {
          "signature": "(self, alpha, beta)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "random"
    },
    "SystemRandom": {
      "methods": {
        "betavariate": {
          "signature": "(self, alpha, beta)",
          "doc": ""
        },
        "choice": {
          "signature": "(self, seq)",
          "doc": ""
        },
        "choices": {
          "signature": "(self, population, weights=None, *, cum_weights=None, k=1)",
          "doc": ""
        },
        "expovariate": {
          "signature": "(self, lambd)",
          "doc": ""
        },
        "gammavariate": {
          "signature": "(self, alpha, beta)",
          "doc": ""
        },
        "gauss": {
          "signature": "(self, mu=0.0, sigma=1.0)",
          "doc": ""
        },
        "getrandbits": {
          "signature": "(self, k)",
          "doc": ""
        },
        "getstate": {
          "signature": "(self, *args, **kwds)",
          "doc": ""
        },
        "lognormvariate": {
          "signature": "(self, mu, sigma)",
          "doc": ""
        },
        "normalvariate": {
          "signature": "(self, mu=0.0, sigma=1.0)",
          "doc": ""
        },
        "paretovariate": {
          "signature": "(self, alpha)",
          "doc": ""
        },
        "randbytes": {
          "signature": "(self, n)",
          "doc": ""
        },
        "randint": {
          "signature": "(self, a, b)",
          "doc": ""
        },
        "random": {
          "signature": "(self)",
          "doc": ""
        },
        "randrange": {
          "signature": "(self, start, stop=None, step=1)",
          "doc": ""
        },
        "sample": {
          "signature": "(self, population, k, *, counts=None)",
          "doc": ""
        },
        "seed": {
          "signature": "(self, *args, **kwds)",
          "doc": ""
        },
        "setstate": {
          "signature": "(self, *args, **kwds)",
          "doc": ""
        },
        "shuffle": {
          "signature": "(self, x)",
          "doc": ""
        },
        "triangular": {
          "signature": "(self, low=0.0, high=1.0, mode=None)",
          "doc": ""
        },
        "uniform": {
          "signature": "(self, a, b)",
          "doc": ""
        },
        "vonmisesvariate": {
          "signature": "(self, mu, kappa)",
          "doc": ""
        },
        "weibullvariate": {
          "signature": "(self, alpha, beta)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "random"
    },
    "ExprProxy": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "classproperty": {
      "methods": {
        "getter": {
          "signature": "(self, method)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "RlocInt_C": {
      "methods": {},
      "doc": "Relocatable int",
      "module": "freeze.freeze"
    },
    "ConstExpr": {
      "methods": {},
      "doc": "Class for general expression with rlocints.",
      "module": "freeze.freeze"
    },
    "Forward": {
      "methods": {},
      "doc": "Class for forward definition.",
      "module": "freeze.freeze"
    },
    "Payload": {
      "methods": {},
      "doc": "",
      "module": "eudplib.maprw.injector.vector_reloc"
    },
    "ObjCollector": {
      "methods": {
        "EndWrite": {
          "signature": "(self) -> 'None'",
          "doc": ""
        },
        "StartWrite": {
          "signature": "(self) -> 'None'",
          "doc": ""
        },
        "WriteByte": {
          "signature": "(self, number: 'int') -> 'None'",
          "doc": ""
        },
        "WriteBytes": {
          "signature": "(self, b: 'bytes') -> 'None'",
          "doc": ""
        },
        "WriteDword": {
          "signature": "(self, obj: 'Evaluable') -> 'None'",
          "doc": ""
        },
        "WritePack": {
          "signature": "(self, structformat: 'str', arglist: 'list[Evaluable]') -> 'None'",
          "doc": ""
        },
        "WriteSpace": {
          "signature": "(self, spacesize: 'int') -> 'None'",
          "doc": ""
        },
        "WriteWord": {
          "signature": "(self, number: 'int') -> 'None'",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.rawtrigger.rawtriggerdef"
    },
    "AST": {
      "methods": {},
      "doc": "",
      "module": "ast"
    },
    "Add": {
      "methods": {},
      "doc": "Add",
      "module": "ast"
    },
    "And": {
      "methods": {},
      "doc": "And",
      "module": "ast"
    },
    "AnnAssign": {
      "methods": {},
      "doc": "AnnAssign(expr target, expr annotation, expr? value, int simple)",
      "module": "ast"
    },
    "Assert": {
      "methods": {},
      "doc": "Assert(expr test, expr? msg)",
      "module": "ast"
    },
    "Assign": {
      "methods": {},
      "doc": "Assign(expr* targets, expr value, string? type_comment)",
      "module": "ast"
    },
    "AsyncFor": {
      "methods": {},
      "doc": "AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)",
      "module": "ast"
    },
    "AsyncFunctionDef": {
      "methods": {},
      "doc": "AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)",
      "module": "ast"
    },
    "AsyncWith": {
      "methods": {},
      "doc": "AsyncWith(withitem* items, stmt* body, string? type_comment)",
      "module": "ast"
    },
    "Attribute": {
      "methods": {},
      "doc": "Attribute(name, kind, defining_class, object)",
      "module": "inspect"
    },
    "AugAssign": {
      "methods": {},
      "doc": "AugAssign(expr target, operator op, expr value)",
      "module": "ast"
    },
    "AugLoad": {
      "methods": {},
      "doc": "",
      "module": "ast"
    },
    "AugStore": {
      "methods": {},
      "doc": "",
      "module": "ast"
    },
    "Await": {
      "methods": {},
      "doc": "Await(expr value)",
      "module": "ast"
    },
    "BinOp": {
      "methods": {},
      "doc": "BinOp(expr left, operator op, expr right)",
      "module": "ast"
    },
    "BitAnd": {
      "methods": {},
      "doc": "BitAnd",
      "module": "ast"
    },
    "BitOr": {
      "methods": {},
      "doc": "BitOr",
      "module": "ast"
    },
    "BitXor": {
      "methods": {},
      "doc": "BitXor",
      "module": "ast"
    },
    "BoolOp": {
      "methods": {},
      "doc": "BoolOp(boolop op, expr* values)",
      "module": "ast"
    },
    "Break": {
      "methods": {},
      "doc": "Break",
      "module": "ast"
    },
    "Bytes": {
      "methods": {},
      "doc": "Deprecated AST node class. Use ast.Constant instead",
      "module": "ast"
    },
    "Call": {
      "methods": {},
      "doc": "Call(expr func, expr* args, keyword* keywords)",
      "module": "ast"
    },
    "ClassDef": {
      "methods": {},
      "doc": "ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list)",
      "module": "ast"
    },
    "Compare": {
      "methods": {},
      "doc": "Compare(expr left, cmpop* ops, expr* comparators)",
      "module": "ast"
    },
    "Constant": {
      "methods": {},
      "doc": "Constant(constant value, string? kind)",
      "module": "ast"
    },
    "Continue": {
      "methods": {},
      "doc": "Continue",
      "module": "ast"
    },
    "Del": {
      "methods": {},
      "doc": "Del",
      "module": "ast"
    },
    "Delete": {
      "methods": {},
      "doc": "Delete(expr* targets)",
      "module": "ast"
    },
    "Dict": {
      "methods": {},
      "doc": "Dict(expr* keys, expr* values)",
      "module": "ast"
    },
    "DictComp": {
      "methods": {},
      "doc": "DictComp(expr key, expr value, comprehension* generators)",
      "module": "ast"
    },
    "Div": {
      "methods": {},
      "doc": "Div",
      "module": "ast"
    },
    "Ellipsis": {
      "methods": {},
      "doc": "Deprecated AST node class. Use ast.Constant instead",
      "module": "ast"
    },
    "Eq": {
      "methods": {},
      "doc": "Eq",
      "module": "ast"
    },
    "ExceptHandler": {
      "methods": {},
      "doc": "ExceptHandler(expr? type, identifier? name, stmt* body)",
      "module": "ast"
    },
    "Expr": {
      "methods": {},
      "doc": "Expr(expr value)",
      "module": "ast"
    },
    "Expression": {
      "methods": {},
      "doc": "Expression(expr body)",
      "module": "ast"
    },
    "ExtSlice": {
      "methods": {},
      "doc": "",
      "module": "ast"
    },
    "FloorDiv": {
      "methods": {},
      "doc": "FloorDiv",
      "module": "ast"
    },
    "For": {
      "methods": {},
      "doc": "For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)",
      "module": "ast"
    },
    "FormattedValue": {
      "methods": {},
      "doc": "FormattedValue(expr value, int conversion, expr? format_spec)",
      "module": "ast"
    },
    "FunctionDef": {
      "methods": {},
      "doc": "FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)",
      "module": "ast"
    },
    "GeneratorExp": {
      "methods": {},
      "doc": "GeneratorExp(expr elt, comprehension* generators)",
      "module": "ast"
    },
    "Global": {
      "methods": {},
      "doc": "Global(identifier* names)",
      "module": "ast"
    },
    "Gt": {
      "methods": {},
      "doc": "Gt",
      "module": "ast"
    },
    "GtE": {
      "methods": {},
      "doc": "GtE",
      "module": "ast"
    },
    "If": {
      "methods": {},
      "doc": "If(expr test, stmt* body, stmt* orelse)",
      "module": "ast"
    },
    "IfExp": {
      "methods": {},
      "doc": "IfExp(expr test, expr body, expr orelse)",
      "module": "ast"
    },
    "Import": {
      "methods": {},
      "doc": "Import(alias* names)",
      "module": "ast"
    },
    "ImportFrom": {
      "methods": {},
      "doc": "ImportFrom(identifier? module, alias* names, int? level)",
      "module": "ast"
    },
    "In": {
      "methods": {},
      "doc": "In",
      "module": "ast"
    },
    "Index": {
      "methods": {},
      "doc": "",
      "module": "ast"
    },
    "Interactive": {
      "methods": {},
      "doc": "Interactive(stmt* body)",
      "module": "ast"
    },
    "Invert": {
      "methods": {},
      "doc": "Invert",
      "module": "ast"
    },
    "Is": {
      "methods": {},
      "doc": "Is",
      "module": "ast"
    },
    "IsNot": {
      "methods": {},
      "doc": "IsNot",
      "module": "ast"
    },
    "JoinedStr": {
      "methods": {},
      "doc": "JoinedStr(expr* values)",
      "module": "ast"
    },
    "LShift": {
      "methods": {},
      "doc": "LShift",
      "module": "ast"
    },
    "Lambda": {
      "methods": {},
      "doc": "Lambda(arguments args, expr body)",
      "module": "ast"
    },
    "List": {
      "methods": {},
      "doc": "List(expr* elts, expr_context ctx)",
      "module": "ast"
    },
    "ListComp": {
      "methods": {},
      "doc": "ListComp(expr elt, comprehension* generators)",
      "module": "ast"
    },
    "Load": {
      "methods": {},
      "doc": "Load",
      "module": "ast"
    },
    "Lt": {
      "methods": {},
      "doc": "Lt",
      "module": "ast"
    },
    "LtE": {
      "methods": {},
      "doc": "LtE",
      "module": "ast"
    },
    "MatMult": {
      "methods": {},
      "doc": "MatMult",
      "module": "ast"
    },
    "MatchAs": {
      "methods": {},
      "doc": "MatchAs(pattern? pattern, identifier? name)",
      "module": "ast"
    },
    "MatchClass": {
      "methods": {},
      "doc": "MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, pattern* kwd_patterns)",
      "module": "ast"
    },
    "MatchMapping": {
      "methods": {},
      "doc": "MatchMapping(expr* keys, pattern* patterns, identifier? rest)",
      "module": "ast"
    },
    "MatchOr": {
      "methods": {},
      "doc": "MatchOr(pattern* patterns)",
      "module": "ast"
    },
    "MatchSequence": {
      "methods": {},
      "doc": "MatchSequence(pattern* patterns)",
      "module": "ast"
    },
    "MatchSingleton": {
      "methods": {},
      "doc": "MatchSingleton(constant value)",
      "module": "ast"
    },
    "MatchStar": {
      "methods": {},
      "doc": "MatchStar(identifier? name)",
      "module": "ast"
    },
    "MatchValue": {
      "methods": {},
      "doc": "MatchValue(expr value)",
      "module": "ast"
    },
    "Mod": {
      "methods": {},
      "doc": "Mod",
      "module": "ast"
    },
    "Module": {
      "methods": {},
      "doc": "Module(stmt* body, type_ignore* type_ignores)",
      "module": "ast"
    },
    "Mult": {
      "methods": {},
      "doc": "Mult",
      "module": "ast"
    },
    "Name": {
      "methods": {},
      "doc": "Name(identifier id, expr_context ctx)",
      "module": "ast"
    },
    "NameConstant": {
      "methods": {},
      "doc": "Deprecated AST node class. Use ast.Constant instead",
      "module": "ast"
    },
    "NamedExpr": {
      "methods": {},
      "doc": "NamedExpr(expr target, expr value)",
      "module": "ast"
    },
    "NodeTransformer": {
      "methods": {
        "generic_visit": {
          "signature": "(self, node)",
          "doc": ""
        },
        "visit": {
          "signature": "(self, node)",
          "doc": ""
        },
        "visit_Constant": {
          "signature": "(self, node)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "ast"
    },
    "NodeVisitor": {
      "methods": {
        "generic_visit": {
          "signature": "(self, node)",
          "doc": ""
        },
        "visit": {
          "signature": "(self, node)",
          "doc": ""
        },
        "visit_Constant": {
          "signature": "(self, node)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "ast"
    },
    "Nonlocal": {
      "methods": {},
      "doc": "Nonlocal(identifier* names)",
      "module": "ast"
    },
    "Not": {
      "methods": {},
      "doc": "Not",
      "module": "ast"
    },
    "NotEq": {
      "methods": {},
      "doc": "NotEq",
      "module": "ast"
    },
    "NotIn": {
      "methods": {},
      "doc": "NotIn",
      "module": "ast"
    },
    "Num": {
      "methods": {},
      "doc": "Deprecated AST node class. Use ast.Constant instead",
      "module": "ast"
    },
    "Or": {
      "methods": {},
      "doc": "Or",
      "module": "ast"
    },
    "Param": {
      "methods": {},
      "doc": "",
      "module": "ast"
    },
    "Pass": {
      "methods": {},
      "doc": "Pass",
      "module": "ast"
    },
    "Pow": {
      "methods": {},
      "doc": "Pow",
      "module": "ast"
    },
    "RShift": {
      "methods": {},
      "doc": "RShift",
      "module": "ast"
    },
    "Raise": {
      "methods": {},
      "doc": "Raise(expr? exc, expr? cause)",
      "module": "ast"
    },
    "Return": {
      "methods": {},
      "doc": "Return(expr? value)",
      "module": "ast"
    },
    "SetComp": {
      "methods": {},
      "doc": "SetComp(expr elt, comprehension* generators)",
      "module": "ast"
    },
    "Slice": {
      "methods": {},
      "doc": "Slice(expr? lower, expr? upper, expr? step)",
      "module": "ast"
    },
    "Starred": {
      "methods": {},
      "doc": "Starred(expr value, expr_context ctx)",
      "module": "ast"
    },
    "Store": {
      "methods": {},
      "doc": "Store",
      "module": "ast"
    },
    "Str": {
      "methods": {},
      "doc": "Deprecated AST node class. Use ast.Constant instead",
      "module": "ast"
    },
    "Sub": {
      "methods": {},
      "doc": "Sub",
      "module": "ast"
    },
    "Subscript": {
      "methods": {},
      "doc": "Subscript(expr value, expr slice, expr_context ctx)",
      "module": "ast"
    },
    "Suite": {
      "methods": {},
      "doc": "",
      "module": "ast"
    },
    "Try": {
      "methods": {},
      "doc": "Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)",
      "module": "ast"
    },
    "TryStar": {
      "methods": {},
      "doc": "TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)",
      "module": "ast"
    },
    "Tuple": {
      "methods": {},
      "doc": "Tuple(expr* elts, expr_context ctx)",
      "module": "ast"
    },
    "TypeIgnore": {
      "methods": {},
      "doc": "TypeIgnore(int lineno, string tag)",
      "module": "ast"
    },
    "UAdd": {
      "methods": {},
      "doc": "UAdd",
      "module": "ast"
    },
    "USub": {
      "methods": {},
      "doc": "USub",
      "module": "ast"
    },
    "UnaryOp": {
      "methods": {},
      "doc": "UnaryOp(unaryop op, expr operand)",
      "module": "ast"
    },
    "While": {
      "methods": {},
      "doc": "While(expr test, stmt* body, stmt* orelse)",
      "module": "ast"
    },
    "With": {
      "methods": {},
      "doc": "With(withitem* items, stmt* body, string? type_comment)",
      "module": "ast"
    },
    "Yield": {
      "methods": {},
      "doc": "Yield(expr? value)",
      "module": "ast"
    },
    "YieldFrom": {
      "methods": {},
      "doc": "YieldFrom(expr value)",
      "module": "ast"
    },
    "alias": {
      "methods": {},
      "doc": "alias(identifier name, identifier? asname)",
      "module": "ast"
    },
    "arg": {
      "methods": {},
      "doc": "arg(identifier arg, expr? annotation, string? type_comment)",
      "module": "ast"
    },
    "arguments": {
      "methods": {},
      "doc": "arguments(arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs, expr* kw_defaults, arg? kwarg, expr* defaults)",
      "module": "ast"
    },
    "boolop": {
      "methods": {},
      "doc": "boolop = And | Or",
      "module": "ast"
    },
    "cmpop": {
      "methods": {},
      "doc": "cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn",
      "module": "ast"
    },
    "comprehension": {
      "methods": {},
      "doc": "comprehension(expr target, expr iter, expr* ifs, int is_async)",
      "module": "ast"
    },
    "excepthandler": {
      "methods": {},
      "doc": "excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)",
      "module": "ast"
    },
    "expr": {
      "methods": {},
      "doc": "expr = BoolOp(boolop op, expr* values)",
      "module": "ast"
    },
    "expr_context": {
      "methods": {},
      "doc": "expr_context = Load | Store | Del",
      "module": "ast"
    },
    "keyword": {
      "methods": {},
      "doc": "keyword(identifier? arg, expr value)",
      "module": "ast"
    },
    "match_case": {
      "methods": {},
      "doc": "match_case(pattern pattern, expr? guard, stmt* body)",
      "module": "ast"
    },
    "mod": {
      "methods": {},
      "doc": "mod = Module(stmt* body, type_ignore* type_ignores)",
      "module": "ast"
    },
    "operator": {
      "methods": {},
      "doc": "operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift | RShift | BitOr | BitXor | BitAnd | FloorDiv",
      "module": "ast"
    },
    "pattern": {
      "methods": {},
      "doc": "pattern = MatchValue(expr value)",
      "module": "ast"
    },
    "stmt": {
      "methods": {},
      "doc": "stmt = FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)",
      "module": "ast"
    },
    "type_ignore": {
      "methods": {},
      "doc": "type_ignore = TypeIgnore(int lineno, string tag)",
      "module": "ast"
    },
    "unaryop": {
      "methods": {},
      "doc": "unaryop = Invert | Not | UAdd | USub",
      "module": "ast"
    },
    "withitem": {
      "methods": {},
      "doc": "withitem(expr context_expr, expr? optional_vars)",
      "module": "ast"
    },
    "Bytecode": {
      "methods": {
        "dis": {
          "signature": "(self)",
          "doc": ""
        },
        "info": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "dis"
    },
    "Instruction": {
      "methods": {},
      "doc": "",
      "module": "eudplib.epscript.linetable_calculator"
    },
    "Positions": {
      "methods": {},
      "doc": "Positions(lineno, end_lineno, col_offset, end_col_offset)",
      "module": "dis"
    },
    "StopTokenizing": {
      "methods": {},
      "doc": "",
      "module": "tokenize"
    },
    "TokenError": {
      "methods": {},
      "doc": "",
      "module": "tokenize"
    },
    "TokenInfo": {
      "methods": {},
      "doc": "",
      "module": "tokenize"
    },
    "Untokenizer": {
      "methods": {
        "add_whitespace": {
          "signature": "(self, start)",
          "doc": ""
        },
        "compat": {
          "signature": "(self, token, iterable)",
          "doc": ""
        },
        "untokenize": {
          "signature": "(self, iterable)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "tokenize"
    },
    "ArgInfo": {
      "methods": {},
      "doc": "ArgInfo(args, varargs, keywords, locals)",
      "module": "inspect"
    },
    "Arguments": {
      "methods": {},
      "doc": "Arguments(args, varargs, varkw)",
      "module": "inspect"
    },
    "BlockFinder": {
      "methods": {
        "tokeneater": {
          "signature": "(self, type, token, srowcol, erowcol, line)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "inspect"
    },
    "BoundArguments": {
      "methods": {
        "apply_defaults": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "inspect"
    },
    "ClassFoundException": {
      "methods": {},
      "doc": "",
      "module": "inspect"
    },
    "ClosureVars": {
      "methods": {},
      "doc": "ClosureVars(nonlocals, globals, builtins, unbound)",
      "module": "inspect"
    },
    "EndOfBlock": {
      "methods": {},
      "doc": "",
      "module": "inspect"
    },
    "FrameInfo": {
      "methods": {},
      "doc": "",
      "module": "inspect"
    },
    "FullArgSpec": {
      "methods": {},
      "doc": "FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)",
      "module": "inspect"
    },
    "Parameter": {
      "methods": {
        "replace": {
          "signature": "(self, *, name=<class 'inspect._void'>, kind=<class 'inspect._void'>, annotation=<class 'inspect._void'>, default=<class 'inspect._void'>)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "inspect"
    },
    "Signature": {
      "methods": {
        "bind": {
          "signature": "(self, /, *args, **kwargs)",
          "doc": ""
        },
        "bind_partial": {
          "signature": "(self, /, *args, **kwargs)",
          "doc": ""
        },
        "replace": {
          "signature": "(self, *, parameters=<class 'inspect._void'>, return_annotation=<class 'inspect._void'>)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "inspect"
    },
    "Traceback": {
      "methods": {},
      "doc": "",
      "module": "inspect"
    },
    "Buffer": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "CapsuleType": {
      "methods": {},
      "doc": "Capsule objects let you wrap a C \"void *\" pointer in a Python",
      "module": "typing_extensions"
    },
    "Doc": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "GenericMeta": {
      "methods": {},
      "doc": "type(object) -> the object's type",
      "module": "typing_extensions"
    },
    "TypeAliasType": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "deprecated": {
      "methods": {},
      "doc": "",
      "module": "typing_extensions"
    },
    "ConstType": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.scdata.weapon"
    },
    "Action": {
      "methods": {
        "CheckArgs": {
          "signature": "(self, i: 'int') -> 'None'",
          "doc": ""
        },
        "CollectDependency": {
          "signature": "(self, pbuffer: 'ObjCollector') -> 'None'",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> 'RlocInt_C'",
          "doc": ""
        },
        "SetParentTrigger": {
          "signature": "(self, trg: 'RawTrigger', index: 'int') -> 'None'",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, pbuffer: '_PayloadBuffer') -> 'None'",
          "doc": ""
        },
        "disable": {
          "signature": "(self) -> 'None'",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "CHK": {
      "methods": {
        "clone": {
          "signature": "(self) -> 'CHK'",
          "doc": ""
        },
        "delsection": {
          "signature": "(self, sectionname: 'str | bytes') -> 'None'",
          "doc": ""
        },
        "enumsection": {
          "signature": "(self) -> 'list[bytes]'",
          "doc": ""
        },
        "getsection": {
          "signature": "(self, sectionname: 'str | bytes') -> 'bytes'",
          "doc": ""
        },
        "loadblank": {
          "signature": "(self) -> 'None'",
          "doc": ""
        },
        "loadchk": {
          "signature": "(self, b: 'bytes') -> 'bool'",
          "doc": ""
        },
        "optimize": {
          "signature": "(self) -> 'None'",
          "doc": ""
        },
        "savechk": {
          "signature": "(self) -> 'bytes'",
          "doc": ""
        },
        "setsection": {
          "signature": "(self, sectionname: 'str | bytes', b: 'bytes') -> 'None'",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.mapdata.fixmapdata"
    },
    "PlayerInfo": {
      "methods": {},
      "doc": "",
      "module": "eudplib.trigger.ptrigger"
    },
    "ArgumentError": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "Array": {
      "methods": {},
      "doc": "XXX to be provided",
      "module": "ctypes"
    },
    "BigEndianStructure": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "BigEndianUnion": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "CDLL": {
      "methods": {},
      "doc": "",
      "module": "eudplib.epscript.epscompile"
    },
    "HRESULT": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "LibraryLoader": {
      "methods": {
        "LoadLibrary": {
          "signature": "(self, name)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "ctypes"
    },
    "LittleEndianStructure": {
      "methods": {},
      "doc": "Structure base class",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "LittleEndianUnion": {
      "methods": {},
      "doc": "Union base class",
      "module": "ctypes"
    },
    "OleDLL": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "PyDLL": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "Structure": {
      "methods": {},
      "doc": "Structure base class",
      "module": "ctypes"
    },
    "Union": {
      "methods": {},
      "doc": "Union base class",
      "module": "ctypes"
    },
    "WinDLL": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_bool": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_byte": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_char": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_char_p": {
      "methods": {},
      "doc": "",
      "module": "eudplib.epscript.epscompile"
    },
    "c_double": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_float": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_int": {
      "methods": {},
      "doc": "",
      "module": "msgbox"
    },
    "c_long": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_longdouble": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_longlong": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_short": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_size_t": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_ssize_t": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_ubyte": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_uint": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_ulong": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_ulonglong": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_ushort": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_void_p": {
      "methods": {},
      "doc": "",
      "module": "eudplib.epscript.epscompile"
    },
    "c_voidp": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_wchar": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_wchar_p": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "py_object": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_int16": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_int32": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_int64": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_int8": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_uint16": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_uint32": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_uint64": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "c_uint8": {
      "methods": {},
      "doc": "",
      "module": "ctypes"
    },
    "UnitProperty": {
      "methods": {},
      "doc": "",
      "module": "freeze.freeze"
    },
    "TBL": {
      "methods": {
        "AddString": {
          "signature": "(self, string: 'str | bytes') -> 'int'",
          "doc": ""
        },
        "ForceAddString": {
          "signature": "(self, string: 'str | bytes') -> 'int'",
          "doc": ""
        },
        "GetString": {
          "signature": "(self, index: 'int') -> 'bytes | None'",
          "doc": ""
        },
        "GetStringIndex": {
          "signature": "(self, string: 'str | bytes') -> 'int'",
          "doc": ""
        },
        "finalize": {
          "signature": "(self) -> 'tuple[bytes, list[int]]'",
          "doc": ""
        },
        "load_tbl": {
          "signature": "(self, content: 'bytes') -> 'None'",
          "doc": ""
        },
        "load_tbl_with_chk": {
          "signature": "(self, content: 'bytes', init_chkt: 'tuple[CHK, StringIdMap, StringIdMap, StringIdMap]') -> 'None'",
          "doc": ""
        },
        "save_tbl": {
          "signature": "(self) -> 'bytes'",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "StringIdMap": {
      "methods": {
        "GetStringIndex": {
          "signature": "(self, string: str | bytes) -> int",
          "doc": ""
        },
        "add_item": {
          "signature": "(self, string: str | bytes, strid: int) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.mapdata.stringmap"
    },
    "TrgAllyStatus": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrgComparison": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrgCount": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrgModifier": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrgOrder": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrgPropState": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrgProperty": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrgResource": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrgScore": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrgSwitchAction": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrgSwitchState": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDObject": {
      "methods": {},
      "doc": "Class for standalone object on memory",
      "module": "freeze.freeze"
    },
    "Db": {
      "methods": {
        "GetDataSize": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, pbuffer: eudplib.core.allocator.ObjAllocator | eudplib.core.allocator.PayloadBuffer) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "RawTrigger": {
      "methods": {
        "CollectDependency": {
          "signature": "(self, pbuffer: eudplib.core.allocator.payload.ObjCollector) -> None",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self) -> int",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "Differ": {
      "methods": {
        "compare": {
          "signature": "(self, a, b)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "difflib"
    },
    "HtmlDiff": {
      "methods": {
        "make_file": {
          "signature": "(self, fromlines, tolines, fromdesc='', todesc='', context=False, numlines=5, *, charset='utf-8')",
          "doc": ""
        },
        "make_table": {
          "signature": "(self, fromlines, tolines, fromdesc='', todesc='', context=False, numlines=5)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "difflib"
    },
    "SequenceMatcher": {
      "methods": {
        "find_longest_match": {
          "signature": "(self, alo=0, ahi=None, blo=0, bhi=None)",
          "doc": ""
        },
        "get_grouped_opcodes": {
          "signature": "(self, n=3)",
          "doc": ""
        },
        "get_matching_blocks": {
          "signature": "(self)",
          "doc": ""
        },
        "get_opcodes": {
          "signature": "(self)",
          "doc": ""
        },
        "quick_ratio": {
          "signature": "(self)",
          "doc": ""
        },
        "ratio": {
          "signature": "(self)",
          "doc": ""
        },
        "real_quick_ratio": {
          "signature": "(self)",
          "doc": ""
        },
        "set_seq1": {
          "signature": "(self, a)",
          "doc": ""
        },
        "set_seq2": {
          "signature": "(self, b)",
          "doc": ""
        },
        "set_seqs": {
          "signature": "(self, a, b)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "difflib"
    },
    "Icon": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "Iscript": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "Portrait": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "StatText": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrgAIScript": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrgLocation": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrgString": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TrgSwitch": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "VariableBase": {
      "methods": {
        "AddNumber": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "AddNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "Assign": {
          "signature": "(self: 'Self', value: 'Dword') -> 'Self'",
          "doc": ""
        },
        "AtLeast": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "AtLeastX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "AtMost": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "AtMostX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "Exactly": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "ExactlyX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "SetNumber": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SetNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SubtractNumber": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SubtractNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "getValueAddr": {
          "signature": "(self) -> 'ConstExpr'",
          "doc": ""
        },
        "iabs": {
          "signature": "(self: 'Self') -> 'Self'",
          "doc": ""
        },
        "iinvert": {
          "signature": "(self: 'Self') -> 'Self'",
          "doc": ""
        },
        "ineg": {
          "signature": "(self: 'Self', *, action: 'bool' = False) -> 'Self | list[bt.Action]'",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib.utilf.random"
    },
    "EUDLightBool": {
      "methods": {
        "Clear": {
          "signature": "(self)",
          "doc": ""
        },
        "IsCleared": {
          "signature": "(self)",
          "doc": ""
        },
        "IsSet": {
          "signature": "(self)",
          "doc": ""
        },
        "Set": {
          "signature": "(self)",
          "doc": ""
        },
        "Toggle": {
          "signature": "(self)",
          "doc": ""
        },
        "getValueAddr": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDLightVariable": {
      "methods": {
        "AddNumber": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "AddNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "Assign": {
          "signature": "(self: 'Self', value: 'Dword') -> 'Self'",
          "doc": ""
        },
        "AtLeast": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "AtLeastX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "AtMost": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "AtMostX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "Exactly": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "ExactlyX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "SetNumber": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SetNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SubtractNumber": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SubtractNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "checkNonRValue": {
          "signature": "(self)",
          "doc": ""
        },
        "getValueAddr": {
          "signature": "(self)",
          "doc": ""
        },
        "iabs": {
          "signature": "(self: 'Self') -> 'Self'",
          "doc": ""
        },
        "iinvert": {
          "signature": "(self: 'Self') -> 'Self'",
          "doc": ""
        },
        "ineg": {
          "signature": "(self: 'Self', *, action: 'bool' = False) -> 'Self | list[bt.Action]'",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TextWrapper": {
      "methods": {
        "fill": {
          "signature": "(self, text)",
          "doc": ""
        },
        "wrap": {
          "signature": "(self, text)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "textwrap"
    },
    "FrameSummary": {
      "methods": {},
      "doc": "",
      "module": "traceback"
    },
    "StackSummary": {
      "methods": {
        "format": {
          "signature": "(self)",
          "doc": ""
        },
        "format_frame_summary": {
          "signature": "(self, frame_summary)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "traceback"
    },
    "TracebackException": {
      "methods": {
        "format": {
          "signature": "(self, *, chain=True, _ctx=None)",
          "doc": ""
        },
        "format_exception_only": {
          "signature": "(self)",
          "doc": ""
        },
        "print": {
          "signature": "(self, *, file=None, chain=True)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "traceback"
    },
    "EUDCustomVarBuffer": {
      "methods": {
        "CollectDependency": {
          "signature": "(self, emitbuffer: 'ObjCollector')",
          "doc": ""
        },
        "DynamicConstructed": {
          "signature": "(self)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> 'RlocInt_C'",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self)",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, emitbuffer) -> 'None'",
          "doc": ""
        },
        "create_vartrigger": {
          "signature": "(self, v, initval)",
          "doc": ""
        },
        "create_vartriggers": {
          "signature": "(self, v, initvals)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.variable.vbuf"
    },
    "EUDVarBuffer": {
      "methods": {
        "CollectDependency": {
          "signature": "(self, emitbuffer: 'ObjCollector') -> 'None'",
          "doc": ""
        },
        "DynamicConstructed": {
          "signature": "(self) -> 'Literal[True]'",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> 'RlocInt_C'",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self) -> 'int'",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, emitbuffer) -> 'None'",
          "doc": ""
        },
        "create_vartrigger": {
          "signature": "(self, v, initval) -> 'ConstExpr'",
          "doc": ""
        },
        "create_vartriggers": {
          "signature": "(self, v, initvals) -> 'ConstExpr'",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.variable.vbuf"
    },
    "EUDVariable": {
      "methods": {
        "AddDest": {
          "signature": "(self, dest) -> 'bt.Action'",
          "doc": ""
        },
        "AddDestX": {
          "signature": "(self, dest, mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "AddMask": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "AddMaskX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "AddNumber": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "AddNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "Assign": {
          "signature": "(self, other: 'Dword') -> 'Self'",
          "doc": ""
        },
        "AtLeast": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "AtLeastX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "AtMost": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "AtMostX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "Exactly": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "ExactlyX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "GetVTable": {
          "signature": "(self) -> 'ConstExpr'",
          "doc": ""
        },
        "MaskAtLeast": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "MaskAtLeastX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "MaskAtMost": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "MaskAtMostX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "MaskExactly": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "MaskExactlyX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "QueueAddTo": {
          "signature": "(self, dest) -> 'list[bt.Action]'",
          "doc": ""
        },
        "QueueAssignTo": {
          "signature": "(self, dest) -> 'list[bt.Action]'",
          "doc": ""
        },
        "QueueSubtractTo": {
          "signature": "(self, dest) -> 'list[bt.Action]'",
          "doc": ""
        },
        "SetDest": {
          "signature": "(self, dest) -> 'bt.Action'",
          "doc": ""
        },
        "SetDestX": {
          "signature": "(self, dest, mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SetMask": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SetMaskX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SetModifier": {
          "signature": "(self, modifier: 'TrgModifier') -> 'bt.Action'",
          "doc": ""
        },
        "SetNumber": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SetNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SubtractDest": {
          "signature": "(self, dest) -> 'bt.Action'",
          "doc": ""
        },
        "SubtractDestX": {
          "signature": "(self, dest, mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SubtractMask": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SubtractMaskX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SubtractNumber": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SubtractNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "checkNonRValue": {
          "signature": "(self) -> 'None'",
          "doc": ""
        },
        "getDestAddr": {
          "signature": "(self) -> 'ConstExpr'",
          "doc": ""
        },
        "getMaskAddr": {
          "signature": "(self) -> 'ConstExpr'",
          "doc": ""
        },
        "getValueAddr": {
          "signature": "(self) -> 'ConstExpr'",
          "doc": ""
        },
        "iabs": {
          "signature": "(self: 'Self') -> 'Self'",
          "doc": ""
        },
        "iinvert": {
          "signature": "(self: 'Self') -> 'Self'",
          "doc": ""
        },
        "ineg": {
          "signature": "(self: 'Self', *, action: 'bool' = False) -> 'Self | list[bt.Action]'",
          "doc": ""
        },
        "makeL": {
          "signature": "(self) -> 'Self'",
          "doc": ""
        },
        "makeR": {
          "signature": "(self) -> 'Self'",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "VariableTriggerForward": {
      "methods": {
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.variable.eudv"
    },
    "EUDXVariable": {
      "methods": {
        "AddDest": {
          "signature": "(self, dest) -> 'bt.Action'",
          "doc": ""
        },
        "AddDestX": {
          "signature": "(self, dest, mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "AddMask": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "AddMaskX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "AddNumber": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "AddNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "Assign": {
          "signature": "(self, other: 'Dword') -> 'Self'",
          "doc": ""
        },
        "AtLeast": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "AtLeastX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "AtMost": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "AtMostX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "Exactly": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "ExactlyX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "GetVTable": {
          "signature": "(self) -> 'ConstExpr'",
          "doc": ""
        },
        "MaskAtLeast": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "MaskAtLeastX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "MaskAtMost": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "MaskAtMostX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "MaskExactly": {
          "signature": "(self, value: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "MaskExactlyX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Condition'",
          "doc": ""
        },
        "QueueAddTo": {
          "signature": "(self, dest) -> 'list[bt.Action]'",
          "doc": ""
        },
        "QueueAssignTo": {
          "signature": "(self, dest) -> 'list[bt.Action]'",
          "doc": ""
        },
        "QueueSubtractTo": {
          "signature": "(self, dest) -> 'list[bt.Action]'",
          "doc": ""
        },
        "SetDest": {
          "signature": "(self, dest) -> 'bt.Action'",
          "doc": ""
        },
        "SetDestX": {
          "signature": "(self, dest, mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SetMask": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SetMaskX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SetModifier": {
          "signature": "(self, modifier: 'TrgModifier') -> 'bt.Action'",
          "doc": ""
        },
        "SetNumber": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SetNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SubtractDest": {
          "signature": "(self, dest) -> 'bt.Action'",
          "doc": ""
        },
        "SubtractDestX": {
          "signature": "(self, dest, mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SubtractMask": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SubtractMaskX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SubtractNumber": {
          "signature": "(self, value: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "SubtractNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> 'bt.Action'",
          "doc": ""
        },
        "checkNonRValue": {
          "signature": "(self) -> 'None'",
          "doc": ""
        },
        "getDestAddr": {
          "signature": "(self) -> 'ConstExpr'",
          "doc": ""
        },
        "getMaskAddr": {
          "signature": "(self) -> 'ConstExpr'",
          "doc": ""
        },
        "getValueAddr": {
          "signature": "(self) -> 'ConstExpr'",
          "doc": ""
        },
        "iabs": {
          "signature": "(self: 'Self') -> 'Self'",
          "doc": ""
        },
        "iinvert": {
          "signature": "(self: 'Self') -> 'Self'",
          "doc": ""
        },
        "ineg": {
          "signature": "(self: 'Self', *, action: 'bool' = False) -> 'Self | list[bt.Action]'",
          "doc": ""
        },
        "makeL": {
          "signature": "(self) -> 'Self'",
          "doc": ""
        },
        "makeR": {
          "signature": "(self) -> 'Self'",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "XVariableTriggerForward": {
      "methods": {
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.variable.eudxv"
    },
    "EUDFuncN": {
      "methods": {
        "size": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.obfpatch"
    },
    "EUDFullFuncN": {
      "methods": {
        "size": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.eudfunc.eudf"
    },
    "EUDTypedFuncN": {
      "methods": {
        "size": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.memio.memifgen"
    },
    "EUDXTypedFuncN": {
      "methods": {
        "size": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.eudfunc.eudf"
    },
    "selftype": {
      "methods": {
        "cast": {
          "signature": "(_from)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "BitsTrg": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.eudstruct.vararray"
    },
    "EUDVArray": {
      "methods": {
        "cast": {
          "signature": "(self, _from)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDStructArray": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "copyto": {
          "signature": "(self, inst)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.eudstruct.structarr"
    },
    "EUDStruct": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "constructor": {
          "signature": "(self)",
          "doc": ""
        },
        "constructor_static": {
          "signature": "(self, *args, **kwargs)",
          "doc": ""
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "copyto": {
          "signature": "(self, inst)",
          "doc": ""
        },
        "destructor": {
          "signature": "(self)",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getfield": {
          "signature": "(self, name)",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "setall": {
          "signature": "(self, values)",
          "doc": ""
        },
        "setfield": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "CtrlStruOpener": {
      "methods": {},
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDJumpBuffer": {
      "methods": {
        "CollectDependency": {
          "signature": "(self, emitbuffer) -> None",
          "doc": ""
        },
        "DynamicConstructed": {
          "signature": "(self) -> Literal[True]",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> eudplib.core.allocator.RlocInt_C",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, emitbuffer) -> None",
          "doc": ""
        },
        "create_jump_trigger": {
          "signature": "(self, v, nextptr) -> eudplib.core.allocator.ConstExpr",
          "doc": ""
        },
        "create_jump_triggers": {
          "signature": "(self, v, nextptrs) -> eudplib.core.allocator.ConstExpr",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.ctrlstru.jumptable"
    },
    "JumpTriggerForward": {
      "methods": {
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.ctrlstru.swblock"
    },
    "EUDSCAnd": {
      "methods": {
        "patch": {
          "signature": "(self) -> 'None'",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDSCOr": {
      "methods": {},
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDByteReader": {
      "methods": {
        "readbyte": {
          "signature": "(self, *, ret=None)",
          "doc": ""
        },
        "seekepd": {
          "signature": "(self, epdoffset, *, subp=0, operation=False)",
          "doc": ""
        },
        "seekoffset": {
          "signature": "(self, offset, *, operation=False)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDByteStream": {
      "methods": {
        "copyto": {
          "signature": "(self, bytestream)",
          "doc": ""
        },
        "flushdword": {
          "signature": "(self)",
          "doc": ""
        },
        "readbyte": {
          "signature": "(self)",
          "doc": ""
        },
        "seekepd": {
          "signature": "(self, epdoffset)",
          "doc": ""
        },
        "seekoffset": {
          "signature": "(self, offset)",
          "doc": ""
        },
        "writebyte": {
          "signature": "(self, byte)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDByteWriter": {
      "methods": {
        "flushdword": {
          "signature": "(self)",
          "doc": ""
        },
        "seekepd": {
          "signature": "(self, epdoffset, *, subp=0, operation=False)",
          "doc": ""
        },
        "seekoffset": {
          "signature": "(self, offset, *, operation=False)",
          "doc": ""
        },
        "writebyte": {
          "signature": "(self, byte)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "CPByteWriter": {
      "methods": {
        "flushdword": {
          "signature": "(self)",
          "doc": ""
        },
        "writebyte": {
          "signature": "(self, byte)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDVArrayReader": {
      "methods": {
        "read": {
          "signature": "(self, acts=[])",
          "doc": ""
        },
        "seek": {
          "signature": "(self, varr_ptr, varr_epd, eudv, acts=[])",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "EUDArray": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "eqitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "geitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "get": {
          "signature": "(self, key) -> eudplib.core.variable.eudv.EUDVariable",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "gtitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "iadditem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "ianditem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "ifloordivitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "iinvertitem": {
          "signature": "(self, key)",
          "doc": ""
        },
        "ilshiftitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "imoditem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "imulitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "inotitem": {
          "signature": "(self, key)",
          "doc": ""
        },
        "ioritem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "ipowitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "irshiftitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "isubitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "isubtractitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "ixoritem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "leitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "ltitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "neitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "set": {
          "signature": "(self, key, item)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.collections.objpool"
    },
    "EUDArrayData": {
      "methods": {
        "GetArraySize": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, buf) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.collections.eudarray"
    },
    "PVariable": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "get": {
          "signature": "(self, i, **kwargs)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "set": {
          "signature": "(self, i, value, **kwargs)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "EPDOffsetMap": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> eudplib.core.variable.eudv.EUDVariable",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.scdata.weapon"
    },
    "BaseKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "MemberKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap"
    },
    "ArrayMember": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.weapon"
    },
    "BaseMember": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap"
    },
    "NotImplementedMember": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.unit"
    },
    "StructMember": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.cunit"
    },
    "UnsupportedMember": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.cunit"
    },
    "ArrayEnumMember": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.scdata.weapon"
    },
    "EnumMember": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.scdata.offsetmap.enummember"
    },
    "StructEnumMember": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.scdata.cunit"
    },
    "AnimationKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "Bit0Kind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "Bit1Kind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "ByteKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "CSpriteKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "CUnitKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "DamageTypeKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "DrawingFunctionKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "DwordKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "ExplosionTypeKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "FlingyKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "IconKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "ImageKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "IscriptKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "MapStringKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "MovementControlKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "PlayerKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "PortraitKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "PositionKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "PositionXKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "PositionYKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "RaceResearchKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "RankKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "RightClickActionKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "SelfKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "SfxDataKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "SpriteKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "StatTextKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "TechKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "UnitKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "UnitOrderKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "UnitSizeKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "UpgradeKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "WeaponBehaviorKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "WeaponKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "WordKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "WorkerCarryTypeKind": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "CSprite": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> eudplib.core.variable.eudv.EUDVariable",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "CSpriteFlags": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.scdata.csprite"
    },
    "Mk": {
      "methods": {},
      "doc": "",
      "module": "eudplib.scdata.weapon"
    },
    "TrgPlayer": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> eudplib.core.variable.eudv.EUDVariable",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "AvailabilityFlags": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.scdata.unit"
    },
    "BaseProperty": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.scdata.unit"
    },
    "GroupFlags": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.scdata.unit"
    },
    "MovementFlags": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.scdata.cunit"
    },
    "TrgUnit": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> eudplib.core.variable.eudv.EUDVariable",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "CUnit": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "are_buildq_empty": {
          "signature": "(self) -> list[eudplib.core.rawtrigger.condition.Condition]",
          "doc": ""
        },
        "cgive": {
          "signature": "(self, new_owner, *, ignore_subunit=False) -> None",
          "doc": ""
        },
        "check_buildq": {
          "signature": "(self, unit_type) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "check_status_flag": {
          "signature": "(self, value, mask=None) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "clear_gathering": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "clear_hallucination": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "clear_invincible": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "clear_noclip": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "clear_speed_upgrade": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "clear_status_flag": {
          "signature": "(self, mask) -> None",
          "doc": ""
        },
        "die": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> eudplib.core.variable.eudv.EUDVariable",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "is_air": {
          "signature": "(self)",
          "doc": ""
        },
        "is_burrowed": {
          "signature": "(self) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "is_completed": {
          "signature": "(self) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "is_dying": {
          "signature": "(self) -> tuple[eudplib.core.rawtrigger.condition.Condition, eudplib.core.rawtrigger.condition.Condition]",
          "doc": ""
        },
        "is_hallucination": {
          "signature": "(self) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "is_in_building": {
          "signature": "(self) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "is_in_transport": {
          "signature": "(self) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "power": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "remove": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "remove_collision": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "reset_buildq": {
          "signature": "(self, q1=228) -> None",
          "doc": ""
        },
        "set_air": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_collision": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_color": {
          "signature": "(self, color_player) -> None",
          "doc": ""
        },
        "set_gathering": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_ground": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_hallucination": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_invincible": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_noclip": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_speed_upgrade": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_status_flag": {
          "signature": "(self, value, mask=None) -> None",
          "doc": ""
        },
        "setloc": {
          "signature": "(self, location) -> None",
          "doc": ""
        },
        "unpower": {
          "signature": "(self) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "EPDCUnitMap": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "are_buildq_empty": {
          "signature": "(self) -> list[eudplib.core.rawtrigger.condition.Condition]",
          "doc": ""
        },
        "cgive": {
          "signature": "(self, new_owner, *, ignore_subunit=False) -> None",
          "doc": ""
        },
        "check_buildq": {
          "signature": "(self, unit_type) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "check_status_flag": {
          "signature": "(self, value, mask=None) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "clear_gathering": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "clear_hallucination": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "clear_invincible": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "clear_noclip": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "clear_speed_upgrade": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "clear_status_flag": {
          "signature": "(self, mask) -> None",
          "doc": ""
        },
        "die": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> eudplib.core.variable.eudv.EUDVariable",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "is_air": {
          "signature": "(self)",
          "doc": ""
        },
        "is_burrowed": {
          "signature": "(self) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "is_completed": {
          "signature": "(self) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "is_dying": {
          "signature": "(self) -> tuple[eudplib.core.rawtrigger.condition.Condition, eudplib.core.rawtrigger.condition.Condition]",
          "doc": ""
        },
        "is_hallucination": {
          "signature": "(self) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "is_in_building": {
          "signature": "(self) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "is_in_transport": {
          "signature": "(self) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "power": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "remove": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "remove_collision": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "reset_buildq": {
          "signature": "(self, q1=228) -> None",
          "doc": ""
        },
        "set_air": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_collision": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_color": {
          "signature": "(self, color_player) -> None",
          "doc": ""
        },
        "set_gathering": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_ground": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_hallucination": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_invincible": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_noclip": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_speed_upgrade": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "set_status_flag": {
          "signature": "(self, value, mask=None) -> None",
          "doc": ""
        },
        "setloc": {
          "signature": "(self, location) -> None",
          "doc": ""
        },
        "unpower": {
          "signature": "(self) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "PathingFlags": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.scdata.cunit"
    },
    "StatusFlags": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.scdata.cunit"
    },
    "Flingy": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> eudplib.core.variable.eudv.EUDVariable",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "Image": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> eudplib.core.variable.eudv.EUDVariable",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "Sprite": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> eudplib.core.variable.eudv.EUDVariable",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "Tech": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> eudplib.core.variable.eudv.EUDVariable",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "UnitOrder": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> eudplib.core.variable.eudv.EUDVariable",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "Upgrade": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> eudplib.core.variable.eudv.EUDVariable",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "TargetFlags": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.scdata.weapon"
    },
    "Weapon": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> eudplib.core.variable.eudv.EUDVariable",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "UnitGroup": {
      "methods": {
        "add": {
          "signature": "(self, unit_epd) -> 'None'",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "CallableProxyType": {
      "methods": {},
      "doc": "",
      "module": "weakref"
    },
    "KeyedRef": {
      "methods": {},
      "doc": "",
      "module": "weakref"
    },
    "ProxyType": {
      "methods": {},
      "doc": "",
      "module": "weakref"
    },
    "ReferenceType": {
      "methods": {},
      "doc": "",
      "module": "weakref"
    },
    "WeakKeyDictionary": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": "D.clear() -> None.  Remove all items from D."
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "get": {
          "signature": "(self, key, default=None)",
          "doc": ""
        },
        "items": {
          "signature": "(self)",
          "doc": ""
        },
        "keyrefs": {
          "signature": "(self)",
          "doc": ""
        },
        "keys": {
          "signature": "(self)",
          "doc": ""
        },
        "pop": {
          "signature": "(self, key, *args)",
          "doc": ""
        },
        "popitem": {
          "signature": "(self)",
          "doc": ""
        },
        "setdefault": {
          "signature": "(self, key, default=None)",
          "doc": ""
        },
        "update": {
          "signature": "(self, dict=None, /, **kwargs)",
          "doc": ""
        },
        "values": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "weakref"
    },
    "WeakMethod": {
      "methods": {},
      "doc": "",
      "module": "weakref"
    },
    "WeakValueDictionary": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": "D.clear() -> None.  Remove all items from D."
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "get": {
          "signature": "(self, key, default=None)",
          "doc": ""
        },
        "items": {
          "signature": "(self)",
          "doc": ""
        },
        "itervaluerefs": {
          "signature": "(self)",
          "doc": ""
        },
        "keys": {
          "signature": "(self)",
          "doc": ""
        },
        "pop": {
          "signature": "(self, key, *args)",
          "doc": ""
        },
        "popitem": {
          "signature": "(self)",
          "doc": ""
        },
        "setdefault": {
          "signature": "(self, key, default=None)",
          "doc": ""
        },
        "update": {
          "signature": "(self, other=None, /, **kwargs)",
          "doc": ""
        },
        "valuerefs": {
          "signature": "(self)",
          "doc": ""
        },
        "values": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "weakref"
    },
    "finalize": {
      "methods": {
        "detach": {
          "signature": "(self)",
          "doc": ""
        },
        "peek": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "weakref"
    },
    "ref": {
      "methods": {},
      "doc": "",
      "module": "weakref"
    },
    "Field": {
      "methods": {},
      "doc": "",
      "module": "dataclasses"
    },
    "FrozenInstanceError": {
      "methods": {},
      "doc": "",
      "module": "dataclasses"
    },
    "InitVar": {
      "methods": {},
      "doc": "",
      "module": "dataclasses"
    },
    "UserPBuffer": {
      "methods": {
        "GetDataSize": {
          "signature": "(self)",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, pbuf)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib.utilf.userpl"
    },
    "CPString": {
      "methods": {
        "Display": {
          "signature": "(self, action=[])",
          "doc": ""
        },
        "GetVTable": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.string.cpprint"
    },
    "ObfuscatedBytes": {
      "methods": {
        "DynamicConstructed": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, pbuffer) -> None",
          "doc": ""
        },
        "cp_print": {
          "signature": "(self, b: bytes) -> None",
          "doc": ""
        },
        "dbstr_print": {
          "signature": "(self, b: bytes) -> None",
          "doc": ""
        },
        "find": {
          "signature": "(self, bb: bytes) -> int",
          "doc": ""
        },
        "find_or_add": {
          "signature": "(self, b: bytes) -> eudplib.core.allocator.ConstExpr",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.string.strcommon"
    },
    "epd2s": {
      "methods": {},
      "doc": "",
      "module": "freeze.freeze"
    },
    "hptr": {
      "methods": {},
      "doc": "",
      "module": "freeze.freeze"
    },
    "ptr2s": {
      "methods": {},
      "doc": "",
      "module": "freeze.freeze"
    },
    "DBString": {
      "methods": {
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "Display": {
          "signature": "(self)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "GetStringMemoryAddr": {
          "signature": "(self)",
          "doc": ""
        },
        "Play": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.string.fmtprint"
    },
    "DBStringData": {
      "methods": {
        "GetDataSize": {
          "signature": "(self)",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, pbuf)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.string.eudprint"
    },
    "FixedText": {
      "methods": {},
      "doc": "",
      "module": "freeze.freeze"
    },
    "StringBuffer": {
      "methods": {
        "Assign": {
          "signature": "(self, other) -> Self",
          "doc": ""
        },
        "Display": {
          "signature": "(self)",
          "doc": ""
        },
        "DisplayAt": {
          "signature": "(self, line, _f={})",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "Play": {
          "signature": "(self)",
          "doc": ""
        },
        "append": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "appendf": {
          "signature": "(self, format_string, *args)",
          "doc": ""
        },
        "constructor": {
          "signature": "(self, *args, **kwargs)",
          "doc": ""
        },
        "constructor_static": {
          "signature": "(self, *args, **kwargs)",
          "doc": ""
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "copyto": {
          "signature": "(self, inst)",
          "doc": ""
        },
        "delete": {
          "signature": "(self, start, length=1)",
          "doc": ""
        },
        "destructor": {
          "signature": "(self)",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "fadeIn": {
          "signature": "(self, *args, color=None, wait=1, reset=True, line=-1, tag=None)",
          "doc": ""
        },
        "fadeInf": {
          "signature": "(self, format_string, *args, color=None, wait=1, reset=True, line=-1, tag=None)",
          "doc": ""
        },
        "fadeOut": {
          "signature": "(self, *args, color=None, wait=1, reset=True, line=-1, tag=None)",
          "doc": ""
        },
        "fadeOutf": {
          "signature": "(self, format_string, *args, color=None, wait=1, reset=True, line=-1, tag=None)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getfield": {
          "signature": "(self, name)",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "insert": {
          "signature": "(self, index, *args)",
          "doc": ""
        },
        "insertf": {
          "signature": "(self, index, format_string, *args)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "length": {
          "signature": "(self)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "print": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "printAt": {
          "signature": "(self, line, *args)",
          "doc": ""
        },
        "printf": {
          "signature": "(self, format_string, *args)",
          "doc": ""
        },
        "printfAt": {
          "signature": "(self, line, format_string, *args)",
          "doc": ""
        },
        "setall": {
          "signature": "(self, values)",
          "doc": ""
        },
        "setfield": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "tagprint": {
          "signature": "(self, format_string, *args, line=-1, tag=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "BZ2Compressor": {
      "methods": {},
      "doc": "Create a compressor object for compressing data incrementally.",
      "module": "bz2"
    },
    "BZ2Decompressor": {
      "methods": {},
      "doc": "Create a decompressor object for decompressing data incrementally.",
      "module": "bz2"
    },
    "BZ2File": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "fileno": {
          "signature": "(self)",
          "doc": ""
        },
        "peek": {
          "signature": "(self, n=0)",
          "doc": ""
        },
        "read": {
          "signature": "(self, size=-1)",
          "doc": ""
        },
        "read1": {
          "signature": "(self, size=-1)",
          "doc": ""
        },
        "readable": {
          "signature": "(self)",
          "doc": ""
        },
        "readinto": {
          "signature": "(self, b)",
          "doc": ""
        },
        "readline": {
          "signature": "(self, size=-1)",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, size=-1)",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": ""
        },
        "seekable": {
          "signature": "(self)",
          "doc": ""
        },
        "tell": {
          "signature": "(self)",
          "doc": ""
        },
        "writable": {
          "signature": "(self)",
          "doc": ""
        },
        "write": {
          "signature": "(self, data)",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, seq)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "bz2"
    },
    "LZMACompressor": {
      "methods": {
        "compress": {
          "signature": "(self, data)",
          "doc": ""
        },
        "flush": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "zipfile"
    },
    "LZMADecompressor": {
      "methods": {
        "decompress": {
          "signature": "(self, data)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "zipfile"
    },
    "LZMAError": {
      "methods": {},
      "doc": "Call to liblzma failed.",
      "module": "lzma"
    },
    "LZMAFile": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "fileno": {
          "signature": "(self)",
          "doc": ""
        },
        "peek": {
          "signature": "(self, size=-1)",
          "doc": ""
        },
        "read": {
          "signature": "(self, size=-1)",
          "doc": ""
        },
        "read1": {
          "signature": "(self, size=-1)",
          "doc": ""
        },
        "readable": {
          "signature": "(self)",
          "doc": ""
        },
        "readline": {
          "signature": "(self, size=-1)",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": ""
        },
        "seekable": {
          "signature": "(self)",
          "doc": ""
        },
        "tell": {
          "signature": "(self)",
          "doc": ""
        },
        "writable": {
          "signature": "(self)",
          "doc": ""
        },
        "write": {
          "signature": "(self, data)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "lzma"
    },
    "ExecError": {
      "methods": {},
      "doc": "",
      "module": "shutil"
    },
    "ReadError": {
      "methods": {},
      "doc": "",
      "module": "shutil"
    },
    "RegistryError": {
      "methods": {},
      "doc": "",
      "module": "shutil"
    },
    "SameFileError": {
      "methods": {},
      "doc": "",
      "module": "shutil"
    },
    "SpecialFileError": {
      "methods": {},
      "doc": "",
      "module": "shutil"
    },
    "SpooledTemporaryFile": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "detach": {
          "signature": "(self)",
          "doc": ""
        },
        "fileno": {
          "signature": "(self)",
          "doc": ""
        },
        "flush": {
          "signature": "(self)",
          "doc": ""
        },
        "isatty": {
          "signature": "(self)",
          "doc": ""
        },
        "read": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "read1": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "readable": {
          "signature": "(self)",
          "doc": ""
        },
        "readinto": {
          "signature": "(self, b)",
          "doc": ""
        },
        "readinto1": {
          "signature": "(self, b)",
          "doc": ""
        },
        "readline": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "rollover": {
          "signature": "(self)",
          "doc": ""
        },
        "seek": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "seekable": {
          "signature": "(self)",
          "doc": ""
        },
        "tell": {
          "signature": "(self)",
          "doc": ""
        },
        "truncate": {
          "signature": "(self, size=None)",
          "doc": ""
        },
        "writable": {
          "signature": "(self)",
          "doc": ""
        },
        "write": {
          "signature": "(self, s)",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, iterable)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "tempfile"
    },
    "TemporaryDirectory": {
      "methods": {
        "cleanup": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "tempfile"
    },
    "Incomplete": {
      "methods": {},
      "doc": "",
      "module": "binascii"
    },
    "InitialWireframe": {
      "methods": {},
      "doc": "",
      "module": "freeze.freeze"
    },
    "CalledProcessError": {
      "methods": {},
      "doc": "",
      "module": "subprocess"
    },
    "CompletedProcess": {
      "methods": {
        "check_returncode": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "subprocess"
    },
    "Handle": {
      "methods": {
        "Close": {
          "signature": "(self, CloseHandle=<built-in function CloseHandle>)",
          "doc": ""
        },
        "Detach": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "subprocess"
    },
    "Popen": {
      "methods": {
        "communicate": {
          "signature": "(self, input=None, timeout=None)",
          "doc": ""
        },
        "kill": {
          "signature": "(self)",
          "doc": ""
        },
        "poll": {
          "signature": "(self)",
          "doc": ""
        },
        "send_signal": {
          "signature": "(self, sig)",
          "doc": ""
        },
        "terminate": {
          "signature": "(self)",
          "doc": ""
        },
        "wait": {
          "signature": "(self, timeout=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "subprocess"
    },
    "STARTUPINFO": {
      "methods": {
        "copy": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "subprocess"
    },
    "SubprocessError": {
      "methods": {},
      "doc": "",
      "module": "subprocess"
    },
    "TimeoutExpired": {
      "methods": {},
      "doc": "",
      "module": "subprocess"
    },
    "EPSFinder": {
      "methods": {
        "find_spec": {
          "signature": "(self, fullname, path, target=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.epscript.epsimp"
    },
    "EPSLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": ""
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_code."
        },
        "get_data": {
          "signature": "(self, path)",
          "doc": ""
        },
        "get_filename": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Return the path to the source file as found by the finder."
        },
        "get_resource_reader": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_source."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.is_package by checking if"
        },
        "load_module": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Load a module from a file."
        },
        "path_mtime": {
          "signature": "(self, path)",
          "doc": "Optional method that returns the modification time (an int) for the"
        },
        "path_stats": {
          "signature": "(self, path)",
          "doc": "Return the metadata for the path."
        },
        "set_data": {
          "signature": "(self, path, data, *, _mode=438)",
          "doc": "Write bytes data to a file."
        },
        "source_to_code": {
          "signature": "(self, data, path, *, _optimize=-1)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.freeze"
    },
    "QueueGameCommandHelper": {
      "methods": {},
      "doc": "",
      "module": "eudplib.qgc.qgc"
    },
    "AddressValueError": {
      "methods": {},
      "doc": "",
      "module": "ipaddress"
    },
    "IPv4Address": {
      "methods": {},
      "doc": "",
      "module": "ipaddress"
    },
    "IPv4Interface": {
      "methods": {},
      "doc": "",
      "module": "ipaddress"
    },
    "IPv4Network": {
      "methods": {
        "address_exclude": {
          "signature": "(self, other)",
          "doc": ""
        },
        "compare_networks": {
          "signature": "(self, other)",
          "doc": ""
        },
        "hosts": {
          "signature": "(self)",
          "doc": ""
        },
        "overlaps": {
          "signature": "(self, other)",
          "doc": ""
        },
        "subnet_of": {
          "signature": "(self, other)",
          "doc": ""
        },
        "subnets": {
          "signature": "(self, prefixlen_diff=1, new_prefix=None)",
          "doc": ""
        },
        "supernet": {
          "signature": "(self, prefixlen_diff=1, new_prefix=None)",
          "doc": ""
        },
        "supernet_of": {
          "signature": "(self, other)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "ipaddress"
    },
    "IPv6Address": {
      "methods": {},
      "doc": "",
      "module": "ipaddress"
    },
    "IPv6Interface": {
      "methods": {},
      "doc": "",
      "module": "ipaddress"
    },
    "IPv6Network": {
      "methods": {
        "address_exclude": {
          "signature": "(self, other)",
          "doc": ""
        },
        "compare_networks": {
          "signature": "(self, other)",
          "doc": ""
        },
        "hosts": {
          "signature": "(self)",
          "doc": ""
        },
        "overlaps": {
          "signature": "(self, other)",
          "doc": ""
        },
        "subnet_of": {
          "signature": "(self, other)",
          "doc": ""
        },
        "subnets": {
          "signature": "(self, prefixlen_diff=1, new_prefix=None)",
          "doc": ""
        },
        "supernet": {
          "signature": "(self, prefixlen_diff=1, new_prefix=None)",
          "doc": ""
        },
        "supernet_of": {
          "signature": "(self, other)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "ipaddress"
    },
    "NetmaskValueError": {
      "methods": {},
      "doc": "",
      "module": "ipaddress"
    },
    "DefragResult": {
      "methods": {
        "encode": {
          "signature": "(self, encoding='ascii', errors='strict')",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.parse"
    },
    "DefragResultBytes": {
      "methods": {
        "decode": {
          "signature": "(self, encoding='ascii', errors='strict')",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.parse"
    },
    "ParseResult": {
      "methods": {
        "encode": {
          "signature": "(self, encoding='ascii', errors='strict')",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.parse"
    },
    "ParseResultBytes": {
      "methods": {
        "decode": {
          "signature": "(self, encoding='ascii', errors='strict')",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.parse"
    },
    "ResultBase": {
      "methods": {
        "encode": {
          "signature": "(self, encoding='ascii', errors='strict')",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.parse"
    },
    "SplitResult": {
      "methods": {
        "encode": {
          "signature": "(self, encoding='ascii', errors='strict')",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.parse"
    },
    "SplitResultBytes": {
      "methods": {
        "decode": {
          "signature": "(self, encoding='ascii', errors='strict')",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.parse"
    },
    "Path": {
      "methods": {
        "absolute": {
          "signature": "(self)",
          "doc": ""
        },
        "as_posix": {
          "signature": "(self)",
          "doc": ""
        },
        "as_uri": {
          "signature": "(self)",
          "doc": ""
        },
        "chmod": {
          "signature": "(self, mode, *, follow_symlinks=True)",
          "doc": ""
        },
        "exists": {
          "signature": "(self)",
          "doc": ""
        },
        "expanduser": {
          "signature": "(self)",
          "doc": ""
        },
        "glob": {
          "signature": "(self, pattern)",
          "doc": ""
        },
        "group": {
          "signature": "(self)",
          "doc": ""
        },
        "hardlink_to": {
          "signature": "(self, target)",
          "doc": ""
        },
        "is_absolute": {
          "signature": "(self)",
          "doc": ""
        },
        "is_block_device": {
          "signature": "(self)",
          "doc": ""
        },
        "is_char_device": {
          "signature": "(self)",
          "doc": ""
        },
        "is_dir": {
          "signature": "(self)",
          "doc": ""
        },
        "is_fifo": {
          "signature": "(self)",
          "doc": ""
        },
        "is_file": {
          "signature": "(self)",
          "doc": ""
        },
        "is_mount": {
          "signature": "(self)",
          "doc": ""
        },
        "is_relative_to": {
          "signature": "(self, *other)",
          "doc": ""
        },
        "is_reserved": {
          "signature": "(self)",
          "doc": ""
        },
        "is_socket": {
          "signature": "(self)",
          "doc": ""
        },
        "is_symlink": {
          "signature": "(self)",
          "doc": ""
        },
        "iterdir": {
          "signature": "(self)",
          "doc": ""
        },
        "joinpath": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "lchmod": {
          "signature": "(self, mode)",
          "doc": ""
        },
        "link_to": {
          "signature": "(self, target)",
          "doc": ""
        },
        "lstat": {
          "signature": "(self)",
          "doc": ""
        },
        "match": {
          "signature": "(self, path_pattern)",
          "doc": ""
        },
        "mkdir": {
          "signature": "(self, mode=511, parents=False, exist_ok=False)",
          "doc": ""
        },
        "open": {
          "signature": "(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)",
          "doc": ""
        },
        "owner": {
          "signature": "(self)",
          "doc": ""
        },
        "read_bytes": {
          "signature": "(self)",
          "doc": ""
        },
        "read_text": {
          "signature": "(self, encoding=None, errors=None)",
          "doc": ""
        },
        "readlink": {
          "signature": "(self)",
          "doc": ""
        },
        "relative_to": {
          "signature": "(self, *other)",
          "doc": ""
        },
        "rename": {
          "signature": "(self, target)",
          "doc": ""
        },
        "replace": {
          "signature": "(self, target)",
          "doc": ""
        },
        "resolve": {
          "signature": "(self, strict=False)",
          "doc": ""
        },
        "rglob": {
          "signature": "(self, pattern)",
          "doc": ""
        },
        "rmdir": {
          "signature": "(self)",
          "doc": ""
        },
        "samefile": {
          "signature": "(self, other_path)",
          "doc": ""
        },
        "stat": {
          "signature": "(self, *, follow_symlinks=True)",
          "doc": ""
        },
        "symlink_to": {
          "signature": "(self, target, target_is_directory=False)",
          "doc": ""
        },
        "touch": {
          "signature": "(self, mode=438, exist_ok=True)",
          "doc": ""
        },
        "unlink": {
          "signature": "(self, missing_ok=False)",
          "doc": ""
        },
        "with_name": {
          "signature": "(self, name)",
          "doc": ""
        },
        "with_stem": {
          "signature": "(self, stem)",
          "doc": ""
        },
        "with_suffix": {
          "signature": "(self, suffix)",
          "doc": ""
        },
        "write_bytes": {
          "signature": "(self, data)",
          "doc": ""
        },
        "write_text": {
          "signature": "(self, data, encoding=None, errors=None, newline=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "main"
    },
    "PosixPath": {
      "methods": {
        "absolute": {
          "signature": "(self)",
          "doc": ""
        },
        "as_posix": {
          "signature": "(self)",
          "doc": ""
        },
        "as_uri": {
          "signature": "(self)",
          "doc": ""
        },
        "chmod": {
          "signature": "(self, mode, *, follow_symlinks=True)",
          "doc": ""
        },
        "exists": {
          "signature": "(self)",
          "doc": ""
        },
        "expanduser": {
          "signature": "(self)",
          "doc": ""
        },
        "glob": {
          "signature": "(self, pattern)",
          "doc": ""
        },
        "group": {
          "signature": "(self)",
          "doc": ""
        },
        "hardlink_to": {
          "signature": "(self, target)",
          "doc": ""
        },
        "is_absolute": {
          "signature": "(self)",
          "doc": ""
        },
        "is_block_device": {
          "signature": "(self)",
          "doc": ""
        },
        "is_char_device": {
          "signature": "(self)",
          "doc": ""
        },
        "is_dir": {
          "signature": "(self)",
          "doc": ""
        },
        "is_fifo": {
          "signature": "(self)",
          "doc": ""
        },
        "is_file": {
          "signature": "(self)",
          "doc": ""
        },
        "is_mount": {
          "signature": "(self)",
          "doc": ""
        },
        "is_relative_to": {
          "signature": "(self, *other)",
          "doc": ""
        },
        "is_reserved": {
          "signature": "(self)",
          "doc": ""
        },
        "is_socket": {
          "signature": "(self)",
          "doc": ""
        },
        "is_symlink": {
          "signature": "(self)",
          "doc": ""
        },
        "iterdir": {
          "signature": "(self)",
          "doc": ""
        },
        "joinpath": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "lchmod": {
          "signature": "(self, mode)",
          "doc": ""
        },
        "link_to": {
          "signature": "(self, target)",
          "doc": ""
        },
        "lstat": {
          "signature": "(self)",
          "doc": ""
        },
        "match": {
          "signature": "(self, path_pattern)",
          "doc": ""
        },
        "mkdir": {
          "signature": "(self, mode=511, parents=False, exist_ok=False)",
          "doc": ""
        },
        "open": {
          "signature": "(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)",
          "doc": ""
        },
        "owner": {
          "signature": "(self)",
          "doc": ""
        },
        "read_bytes": {
          "signature": "(self)",
          "doc": ""
        },
        "read_text": {
          "signature": "(self, encoding=None, errors=None)",
          "doc": ""
        },
        "readlink": {
          "signature": "(self)",
          "doc": ""
        },
        "relative_to": {
          "signature": "(self, *other)",
          "doc": ""
        },
        "rename": {
          "signature": "(self, target)",
          "doc": ""
        },
        "replace": {
          "signature": "(self, target)",
          "doc": ""
        },
        "resolve": {
          "signature": "(self, strict=False)",
          "doc": ""
        },
        "rglob": {
          "signature": "(self, pattern)",
          "doc": ""
        },
        "rmdir": {
          "signature": "(self)",
          "doc": ""
        },
        "samefile": {
          "signature": "(self, other_path)",
          "doc": ""
        },
        "stat": {
          "signature": "(self, *, follow_symlinks=True)",
          "doc": ""
        },
        "symlink_to": {
          "signature": "(self, target, target_is_directory=False)",
          "doc": ""
        },
        "touch": {
          "signature": "(self, mode=438, exist_ok=True)",
          "doc": ""
        },
        "unlink": {
          "signature": "(self, missing_ok=False)",
          "doc": ""
        },
        "with_name": {
          "signature": "(self, name)",
          "doc": ""
        },
        "with_stem": {
          "signature": "(self, stem)",
          "doc": ""
        },
        "with_suffix": {
          "signature": "(self, suffix)",
          "doc": ""
        },
        "write_bytes": {
          "signature": "(self, data)",
          "doc": ""
        },
        "write_text": {
          "signature": "(self, data, encoding=None, errors=None, newline=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "pathlib"
    },
    "PurePath": {
      "methods": {
        "as_posix": {
          "signature": "(self)",
          "doc": ""
        },
        "as_uri": {
          "signature": "(self)",
          "doc": ""
        },
        "is_absolute": {
          "signature": "(self)",
          "doc": ""
        },
        "is_relative_to": {
          "signature": "(self, *other)",
          "doc": ""
        },
        "is_reserved": {
          "signature": "(self)",
          "doc": ""
        },
        "joinpath": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "match": {
          "signature": "(self, path_pattern)",
          "doc": ""
        },
        "relative_to": {
          "signature": "(self, *other)",
          "doc": ""
        },
        "with_name": {
          "signature": "(self, name)",
          "doc": ""
        },
        "with_stem": {
          "signature": "(self, stem)",
          "doc": ""
        },
        "with_suffix": {
          "signature": "(self, suffix)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "pathlib"
    },
    "PurePosixPath": {
      "methods": {
        "as_posix": {
          "signature": "(self)",
          "doc": ""
        },
        "as_uri": {
          "signature": "(self)",
          "doc": ""
        },
        "is_absolute": {
          "signature": "(self)",
          "doc": ""
        },
        "is_relative_to": {
          "signature": "(self, *other)",
          "doc": ""
        },
        "is_reserved": {
          "signature": "(self)",
          "doc": ""
        },
        "joinpath": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "match": {
          "signature": "(self, path_pattern)",
          "doc": ""
        },
        "relative_to": {
          "signature": "(self, *other)",
          "doc": ""
        },
        "with_name": {
          "signature": "(self, name)",
          "doc": ""
        },
        "with_stem": {
          "signature": "(self, stem)",
          "doc": ""
        },
        "with_suffix": {
          "signature": "(self, suffix)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "pathlib"
    },
    "PureWindowsPath": {
      "methods": {
        "as_posix": {
          "signature": "(self)",
          "doc": ""
        },
        "as_uri": {
          "signature": "(self)",
          "doc": ""
        },
        "is_absolute": {
          "signature": "(self)",
          "doc": ""
        },
        "is_relative_to": {
          "signature": "(self, *other)",
          "doc": ""
        },
        "is_reserved": {
          "signature": "(self)",
          "doc": ""
        },
        "joinpath": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "match": {
          "signature": "(self, path_pattern)",
          "doc": ""
        },
        "relative_to": {
          "signature": "(self, *other)",
          "doc": ""
        },
        "with_name": {
          "signature": "(self, name)",
          "doc": ""
        },
        "with_stem": {
          "signature": "(self, stem)",
          "doc": ""
        },
        "with_suffix": {
          "signature": "(self, suffix)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "pathlib"
    },
    "WindowsPath": {
      "methods": {
        "absolute": {
          "signature": "(self)",
          "doc": ""
        },
        "as_posix": {
          "signature": "(self)",
          "doc": ""
        },
        "as_uri": {
          "signature": "(self)",
          "doc": ""
        },
        "chmod": {
          "signature": "(self, mode, *, follow_symlinks=True)",
          "doc": ""
        },
        "exists": {
          "signature": "(self)",
          "doc": ""
        },
        "expanduser": {
          "signature": "(self)",
          "doc": ""
        },
        "glob": {
          "signature": "(self, pattern)",
          "doc": ""
        },
        "group": {
          "signature": "(self)",
          "doc": ""
        },
        "hardlink_to": {
          "signature": "(self, target)",
          "doc": ""
        },
        "is_absolute": {
          "signature": "(self)",
          "doc": ""
        },
        "is_block_device": {
          "signature": "(self)",
          "doc": ""
        },
        "is_char_device": {
          "signature": "(self)",
          "doc": ""
        },
        "is_dir": {
          "signature": "(self)",
          "doc": ""
        },
        "is_fifo": {
          "signature": "(self)",
          "doc": ""
        },
        "is_file": {
          "signature": "(self)",
          "doc": ""
        },
        "is_mount": {
          "signature": "(self)",
          "doc": ""
        },
        "is_relative_to": {
          "signature": "(self, *other)",
          "doc": ""
        },
        "is_reserved": {
          "signature": "(self)",
          "doc": ""
        },
        "is_socket": {
          "signature": "(self)",
          "doc": ""
        },
        "is_symlink": {
          "signature": "(self)",
          "doc": ""
        },
        "iterdir": {
          "signature": "(self)",
          "doc": ""
        },
        "joinpath": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "lchmod": {
          "signature": "(self, mode)",
          "doc": ""
        },
        "link_to": {
          "signature": "(self, target)",
          "doc": ""
        },
        "lstat": {
          "signature": "(self)",
          "doc": ""
        },
        "match": {
          "signature": "(self, path_pattern)",
          "doc": ""
        },
        "mkdir": {
          "signature": "(self, mode=511, parents=False, exist_ok=False)",
          "doc": ""
        },
        "open": {
          "signature": "(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)",
          "doc": ""
        },
        "owner": {
          "signature": "(self)",
          "doc": ""
        },
        "read_bytes": {
          "signature": "(self)",
          "doc": ""
        },
        "read_text": {
          "signature": "(self, encoding=None, errors=None)",
          "doc": ""
        },
        "readlink": {
          "signature": "(self)",
          "doc": ""
        },
        "relative_to": {
          "signature": "(self, *other)",
          "doc": ""
        },
        "rename": {
          "signature": "(self, target)",
          "doc": ""
        },
        "replace": {
          "signature": "(self, target)",
          "doc": ""
        },
        "resolve": {
          "signature": "(self, strict=False)",
          "doc": ""
        },
        "rglob": {
          "signature": "(self, pattern)",
          "doc": ""
        },
        "rmdir": {
          "signature": "(self)",
          "doc": ""
        },
        "samefile": {
          "signature": "(self, other_path)",
          "doc": ""
        },
        "stat": {
          "signature": "(self, *, follow_symlinks=True)",
          "doc": ""
        },
        "symlink_to": {
          "signature": "(self, target, target_is_directory=False)",
          "doc": ""
        },
        "touch": {
          "signature": "(self, mode=438, exist_ok=True)",
          "doc": ""
        },
        "unlink": {
          "signature": "(self, missing_ok=False)",
          "doc": ""
        },
        "with_name": {
          "signature": "(self, name)",
          "doc": ""
        },
        "with_stem": {
          "signature": "(self, stem)",
          "doc": ""
        },
        "with_suffix": {
          "signature": "(self, suffix)",
          "doc": ""
        },
        "write_bytes": {
          "signature": "(self, data)",
          "doc": ""
        },
        "write_text": {
          "signature": "(self, data, encoding=None, errors=None, newline=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "pathlib"
    },
    "BadZipFile": {
      "methods": {},
      "doc": "",
      "module": "zipfile"
    },
    "BadZipfile": {
      "methods": {},
      "doc": "",
      "module": "zipfile"
    },
    "CompleteDirs": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "extract": {
          "signature": "(self, member, path=None, pwd=None)",
          "doc": ""
        },
        "extractall": {
          "signature": "(self, path=None, members=None, pwd=None)",
          "doc": ""
        },
        "getinfo": {
          "signature": "(self, name)",
          "doc": ""
        },
        "infolist": {
          "signature": "(self)",
          "doc": ""
        },
        "mkdir": {
          "signature": "(self, zinfo_or_directory_name, mode=511)",
          "doc": ""
        },
        "namelist": {
          "signature": "(self)",
          "doc": ""
        },
        "open": {
          "signature": "(self, name, mode='r', pwd=None, *, force_zip64=False)",
          "doc": ""
        },
        "printdir": {
          "signature": "(self, file=None)",
          "doc": ""
        },
        "read": {
          "signature": "(self, name, pwd=None)",
          "doc": ""
        },
        "resolve_dir": {
          "signature": "(self, name)",
          "doc": ""
        },
        "setpassword": {
          "signature": "(self, pwd)",
          "doc": ""
        },
        "testzip": {
          "signature": "(self)",
          "doc": ""
        },
        "write": {
          "signature": "(self, filename, arcname=None, compress_type=None, compresslevel=None)",
          "doc": ""
        },
        "writestr": {
          "signature": "(self, zinfo_or_arcname, data, compress_type=None, compresslevel=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "zipfile"
    },
    "FastLookup": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "extract": {
          "signature": "(self, member, path=None, pwd=None)",
          "doc": ""
        },
        "extractall": {
          "signature": "(self, path=None, members=None, pwd=None)",
          "doc": ""
        },
        "getinfo": {
          "signature": "(self, name)",
          "doc": ""
        },
        "infolist": {
          "signature": "(self)",
          "doc": ""
        },
        "mkdir": {
          "signature": "(self, zinfo_or_directory_name, mode=511)",
          "doc": ""
        },
        "namelist": {
          "signature": "(self)",
          "doc": ""
        },
        "open": {
          "signature": "(self, name, mode='r', pwd=None, *, force_zip64=False)",
          "doc": ""
        },
        "printdir": {
          "signature": "(self, file=None)",
          "doc": ""
        },
        "read": {
          "signature": "(self, name, pwd=None)",
          "doc": ""
        },
        "resolve_dir": {
          "signature": "(self, name)",
          "doc": ""
        },
        "setpassword": {
          "signature": "(self, pwd)",
          "doc": ""
        },
        "testzip": {
          "signature": "(self)",
          "doc": ""
        },
        "write": {
          "signature": "(self, filename, arcname=None, compress_type=None, compresslevel=None)",
          "doc": ""
        },
        "writestr": {
          "signature": "(self, zinfo_or_arcname, data, compress_type=None, compresslevel=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "zipfile"
    },
    "LargeZipFile": {
      "methods": {},
      "doc": "",
      "module": "zipfile"
    },
    "PyZipFile": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "extract": {
          "signature": "(self, member, path=None, pwd=None)",
          "doc": ""
        },
        "extractall": {
          "signature": "(self, path=None, members=None, pwd=None)",
          "doc": ""
        },
        "getinfo": {
          "signature": "(self, name)",
          "doc": ""
        },
        "infolist": {
          "signature": "(self)",
          "doc": ""
        },
        "mkdir": {
          "signature": "(self, zinfo_or_directory_name, mode=511)",
          "doc": ""
        },
        "namelist": {
          "signature": "(self)",
          "doc": ""
        },
        "open": {
          "signature": "(self, name, mode='r', pwd=None, *, force_zip64=False)",
          "doc": ""
        },
        "printdir": {
          "signature": "(self, file=None)",
          "doc": ""
        },
        "read": {
          "signature": "(self, name, pwd=None)",
          "doc": ""
        },
        "setpassword": {
          "signature": "(self, pwd)",
          "doc": ""
        },
        "testzip": {
          "signature": "(self)",
          "doc": ""
        },
        "write": {
          "signature": "(self, filename, arcname=None, compress_type=None, compresslevel=None)",
          "doc": ""
        },
        "writepy": {
          "signature": "(self, pathname, basename='', filterfunc=None)",
          "doc": ""
        },
        "writestr": {
          "signature": "(self, zinfo_or_arcname, data, compress_type=None, compresslevel=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "zipfile"
    },
    "ZipExtFile": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "peek": {
          "signature": "(self, n=1)",
          "doc": ""
        },
        "read": {
          "signature": "(self, n=-1)",
          "doc": ""
        },
        "read1": {
          "signature": "(self, n)",
          "doc": ""
        },
        "readable": {
          "signature": "(self)",
          "doc": ""
        },
        "readline": {
          "signature": "(self, limit=-1)",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": ""
        },
        "seekable": {
          "signature": "(self)",
          "doc": ""
        },
        "tell": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "zipfile"
    },
    "ZipFile": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "extract": {
          "signature": "(self, member, path=None, pwd=None)",
          "doc": ""
        },
        "extractall": {
          "signature": "(self, path=None, members=None, pwd=None)",
          "doc": ""
        },
        "getinfo": {
          "signature": "(self, name)",
          "doc": ""
        },
        "infolist": {
          "signature": "(self)",
          "doc": ""
        },
        "mkdir": {
          "signature": "(self, zinfo_or_directory_name, mode=511)",
          "doc": ""
        },
        "namelist": {
          "signature": "(self)",
          "doc": ""
        },
        "open": {
          "signature": "(self, name, mode='r', pwd=None, *, force_zip64=False)",
          "doc": ""
        },
        "printdir": {
          "signature": "(self, file=None)",
          "doc": ""
        },
        "read": {
          "signature": "(self, name, pwd=None)",
          "doc": ""
        },
        "setpassword": {
          "signature": "(self, pwd)",
          "doc": ""
        },
        "testzip": {
          "signature": "(self)",
          "doc": ""
        },
        "write": {
          "signature": "(self, filename, arcname=None, compress_type=None, compresslevel=None)",
          "doc": ""
        },
        "writestr": {
          "signature": "(self, zinfo_or_arcname, data, compress_type=None, compresslevel=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "zipfile"
    },
    "ZipInfo": {
      "methods": {
        "FileHeader": {
          "signature": "(self, zip64=None)",
          "doc": ""
        },
        "is_dir": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "zipfile"
    },
    "addbase": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.response"
    },
    "addclosehook": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "addinfo": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "info": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.response"
    },
    "addinfourl": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "getcode": {
          "signature": "(self)",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        },
        "info": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "ContentTooShortError": {
      "methods": {},
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPError": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "getcode": {
          "signature": "(self)",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        },
        "info": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "URLError": {
      "methods": {},
      "doc": "",
      "module": "autoupdate"
    },
    "blake2b": {
      "methods": {},
      "doc": "Return a new BLAKE2b hash object.",
      "module": "hashlib"
    },
    "blake2s": {
      "methods": {},
      "doc": "Return a new BLAKE2s hash object.",
      "module": "hashlib"
    },
    "HTTPMethod": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "http"
    },
    "HTTPStatus": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "http"
    },
    "BoundaryError": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "CharsetError": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "CloseBoundaryNotFoundDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "FirstHeaderLineIsContinuationDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "HeaderDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "HeaderMissingRequiredValue": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "HeaderParseError": {
      "methods": {},
      "doc": "",
      "module": "email.header"
    },
    "InvalidBase64CharactersDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "InvalidBase64LengthDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "InvalidBase64PaddingDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "InvalidDateDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "InvalidHeaderDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "InvalidMultipartContentTransferEncodingDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "MalformedHeaderDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "MessageDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "MessageError": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "MessageParseError": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "MisplacedEnvelopeHeaderDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "MissingHeaderBodySeparatorDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "MultipartConversionError": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "MultipartInvariantViolationDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "NoBoundaryInMultipartDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "NonASCIILocalPartDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "NonPrintableDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "ObsoleteHeaderDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "StartBoundaryNotFoundDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "UndecodableBytesDefect": {
      "methods": {},
      "doc": "",
      "module": "email.errors"
    },
    "Charset": {
      "methods": {
        "body_encode": {
          "signature": "(self, string)",
          "doc": ""
        },
        "get_body_encoding": {
          "signature": "(self)",
          "doc": ""
        },
        "get_output_charset": {
          "signature": "(self)",
          "doc": ""
        },
        "header_encode": {
          "signature": "(self, string)",
          "doc": ""
        },
        "header_encode_lines": {
          "signature": "(self, string, maxlengths)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.message"
    },
    "Header": {
      "methods": {
        "append": {
          "signature": "(self, s, charset=None, errors='strict')",
          "doc": ""
        },
        "encode": {
          "signature": "(self, splitchars=';, \\t', maxlinelen=None, linesep='\\n')",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.header"
    },
    "date": {
      "methods": {},
      "doc": "date(year, month, day) --> date object",
      "module": "datetime"
    },
    "datetime": {
      "methods": {},
      "doc": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "module": "datetime"
    },
    "time": {
      "methods": {},
      "doc": "time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) --> a time object",
      "module": "datetime"
    },
    "timedelta": {
      "methods": {},
      "doc": "Difference between two datetime values.",
      "module": "datetime"
    },
    "timezone": {
      "methods": {},
      "doc": "Fixed offset from UTC implementation of tzinfo.",
      "module": "datetime"
    },
    "tzinfo": {
      "methods": {},
      "doc": "Abstract base class for time zone info objects.",
      "module": "datetime"
    },
    "Calendar": {
      "methods": {
        "getfirstweekday": {
          "signature": "(self)",
          "doc": ""
        },
        "itermonthdates": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays2": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays3": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays4": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "iterweekdays": {
          "signature": "(self)",
          "doc": ""
        },
        "monthdatescalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdays2calendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdayscalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "setfirstweekday": {
          "signature": "(self, firstweekday)",
          "doc": ""
        },
        "yeardatescalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardays2calendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardayscalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "calendar"
    },
    "HTMLCalendar": {
      "methods": {
        "formatday": {
          "signature": "(self, day, weekday)",
          "doc": ""
        },
        "formatmonth": {
          "signature": "(self, theyear, themonth, withyear=True)",
          "doc": ""
        },
        "formatmonthname": {
          "signature": "(self, theyear, themonth, withyear=True)",
          "doc": ""
        },
        "formatweek": {
          "signature": "(self, theweek)",
          "doc": ""
        },
        "formatweekday": {
          "signature": "(self, day)",
          "doc": ""
        },
        "formatweekheader": {
          "signature": "(self)",
          "doc": ""
        },
        "formatyear": {
          "signature": "(self, theyear, width=3)",
          "doc": ""
        },
        "formatyearpage": {
          "signature": "(self, theyear, width=3, css='calendar.css', encoding=None)",
          "doc": ""
        },
        "getfirstweekday": {
          "signature": "(self)",
          "doc": ""
        },
        "itermonthdates": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays2": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays3": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays4": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "iterweekdays": {
          "signature": "(self)",
          "doc": ""
        },
        "monthdatescalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdays2calendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdayscalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "setfirstweekday": {
          "signature": "(self, firstweekday)",
          "doc": ""
        },
        "yeardatescalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardays2calendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardayscalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "calendar"
    },
    "IllegalMonthError": {
      "methods": {},
      "doc": "",
      "module": "calendar"
    },
    "IllegalWeekdayError": {
      "methods": {},
      "doc": "",
      "module": "calendar"
    },
    "LocaleHTMLCalendar": {
      "methods": {
        "formatday": {
          "signature": "(self, day, weekday)",
          "doc": ""
        },
        "formatmonth": {
          "signature": "(self, theyear, themonth, withyear=True)",
          "doc": ""
        },
        "formatmonthname": {
          "signature": "(self, theyear, themonth, withyear=True)",
          "doc": ""
        },
        "formatweek": {
          "signature": "(self, theweek)",
          "doc": ""
        },
        "formatweekday": {
          "signature": "(self, day)",
          "doc": ""
        },
        "formatweekheader": {
          "signature": "(self)",
          "doc": ""
        },
        "formatyear": {
          "signature": "(self, theyear, width=3)",
          "doc": ""
        },
        "formatyearpage": {
          "signature": "(self, theyear, width=3, css='calendar.css', encoding=None)",
          "doc": ""
        },
        "getfirstweekday": {
          "signature": "(self)",
          "doc": ""
        },
        "itermonthdates": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays2": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays3": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays4": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "iterweekdays": {
          "signature": "(self)",
          "doc": ""
        },
        "monthdatescalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdays2calendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdayscalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "setfirstweekday": {
          "signature": "(self, firstweekday)",
          "doc": ""
        },
        "yeardatescalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardays2calendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardayscalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "calendar"
    },
    "LocaleTextCalendar": {
      "methods": {
        "formatday": {
          "signature": "(self, day, weekday, width)",
          "doc": ""
        },
        "formatmonth": {
          "signature": "(self, theyear, themonth, w=0, l=0)",
          "doc": ""
        },
        "formatmonthname": {
          "signature": "(self, theyear, themonth, width, withyear=True)",
          "doc": ""
        },
        "formatweek": {
          "signature": "(self, theweek, width)",
          "doc": ""
        },
        "formatweekday": {
          "signature": "(self, day, width)",
          "doc": ""
        },
        "formatweekheader": {
          "signature": "(self, width)",
          "doc": ""
        },
        "formatyear": {
          "signature": "(self, theyear, w=2, l=1, c=6, m=3)",
          "doc": ""
        },
        "getfirstweekday": {
          "signature": "(self)",
          "doc": ""
        },
        "itermonthdates": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays2": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays3": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays4": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "iterweekdays": {
          "signature": "(self)",
          "doc": ""
        },
        "monthdatescalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdays2calendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdayscalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "prmonth": {
          "signature": "(self, theyear, themonth, w=0, l=0)",
          "doc": ""
        },
        "prweek": {
          "signature": "(self, theweek, width)",
          "doc": ""
        },
        "pryear": {
          "signature": "(self, theyear, w=0, l=0, c=6, m=3)",
          "doc": ""
        },
        "setfirstweekday": {
          "signature": "(self, firstweekday)",
          "doc": ""
        },
        "yeardatescalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardays2calendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardayscalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "calendar"
    },
    "TextCalendar": {
      "methods": {
        "formatday": {
          "signature": "(self, day, weekday, width)",
          "doc": ""
        },
        "formatmonth": {
          "signature": "(self, theyear, themonth, w=0, l=0)",
          "doc": ""
        },
        "formatmonthname": {
          "signature": "(self, theyear, themonth, width, withyear=True)",
          "doc": ""
        },
        "formatweek": {
          "signature": "(self, theweek, width)",
          "doc": ""
        },
        "formatweekday": {
          "signature": "(self, day, width)",
          "doc": ""
        },
        "formatweekheader": {
          "signature": "(self, width)",
          "doc": ""
        },
        "formatyear": {
          "signature": "(self, theyear, w=2, l=1, c=6, m=3)",
          "doc": ""
        },
        "getfirstweekday": {
          "signature": "(self)",
          "doc": ""
        },
        "itermonthdates": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays2": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays3": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays4": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "iterweekdays": {
          "signature": "(self)",
          "doc": ""
        },
        "monthdatescalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdays2calendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdayscalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "prmonth": {
          "signature": "(self, theyear, themonth, w=0, l=0)",
          "doc": ""
        },
        "prweek": {
          "signature": "(self, theweek, width)",
          "doc": ""
        },
        "pryear": {
          "signature": "(self, theyear, w=0, l=0, c=6, m=3)",
          "doc": ""
        },
        "setfirstweekday": {
          "signature": "(self, firstweekday)",
          "doc": ""
        },
        "yeardatescalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardays2calendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardayscalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "calendar"
    },
    "different_locale": {
      "methods": {},
      "doc": "",
      "module": "calendar"
    },
    "AddressList": {
      "methods": {
        "getaddress": {
          "signature": "(self)",
          "doc": ""
        },
        "getaddrlist": {
          "signature": "(self)",
          "doc": ""
        },
        "getaddrspec": {
          "signature": "(self)",
          "doc": ""
        },
        "getatom": {
          "signature": "(self, atomends=None)",
          "doc": ""
        },
        "getcomment": {
          "signature": "(self)",
          "doc": ""
        },
        "getdelimited": {
          "signature": "(self, beginchar, endchars, allowcomments=True)",
          "doc": ""
        },
        "getdomain": {
          "signature": "(self)",
          "doc": ""
        },
        "getdomainliteral": {
          "signature": "(self)",
          "doc": ""
        },
        "getphraselist": {
          "signature": "(self)",
          "doc": ""
        },
        "getquote": {
          "signature": "(self)",
          "doc": ""
        },
        "getrouteaddr": {
          "signature": "(self)",
          "doc": ""
        },
        "gotonext": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email._parseaddr"
    },
    "AddrlistClass": {
      "methods": {
        "getaddress": {
          "signature": "(self)",
          "doc": ""
        },
        "getaddrlist": {
          "signature": "(self)",
          "doc": ""
        },
        "getaddrspec": {
          "signature": "(self)",
          "doc": ""
        },
        "getatom": {
          "signature": "(self, atomends=None)",
          "doc": ""
        },
        "getcomment": {
          "signature": "(self)",
          "doc": ""
        },
        "getdelimited": {
          "signature": "(self, beginchar, endchars, allowcomments=True)",
          "doc": ""
        },
        "getdomain": {
          "signature": "(self)",
          "doc": ""
        },
        "getdomainliteral": {
          "signature": "(self)",
          "doc": ""
        },
        "getphraselist": {
          "signature": "(self)",
          "doc": ""
        },
        "getquote": {
          "signature": "(self)",
          "doc": ""
        },
        "getrouteaddr": {
          "signature": "(self)",
          "doc": ""
        },
        "gotonext": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email._parseaddr"
    },
    "Compat32": {
      "methods": {
        "clone": {
          "signature": "(self, **kw)",
          "doc": ""
        },
        "fold": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "fold_binary": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "handle_defect": {
          "signature": "(self, obj, defect)",
          "doc": ""
        },
        "header_fetch_parse": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "header_max_count": {
          "signature": "(self, name)",
          "doc": ""
        },
        "header_source_parse": {
          "signature": "(self, sourcelines)",
          "doc": ""
        },
        "header_store_parse": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "register_defect": {
          "signature": "(self, obj, defect)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email._policybase"
    },
    "Policy": {
      "methods": {
        "clone": {
          "signature": "(self, **kw)",
          "doc": ""
        },
        "fold": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "fold_binary": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "handle_defect": {
          "signature": "(self, obj, defect)",
          "doc": ""
        },
        "header_fetch_parse": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "header_max_count": {
          "signature": "(self, name)",
          "doc": ""
        },
        "header_source_parse": {
          "signature": "(self, sourcelines)",
          "doc": ""
        },
        "header_store_parse": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "register_defect": {
          "signature": "(self, obj, defect)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.message"
    },
    "BufferedSubFile": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "pop_eof_matcher": {
          "signature": "(self)",
          "doc": ""
        },
        "push": {
          "signature": "(self, data)",
          "doc": ""
        },
        "push_eof_matcher": {
          "signature": "(self, pred)",
          "doc": ""
        },
        "pushlines": {
          "signature": "(self, lines)",
          "doc": ""
        },
        "readline": {
          "signature": "(self)",
          "doc": ""
        },
        "unreadline": {
          "signature": "(self, line)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.feedparser"
    },
    "BytesFeedParser": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "feed": {
          "signature": "(self, data)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.parser"
    },
    "FeedParser": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "feed": {
          "signature": "(self, data)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.parser"
    },
    "BytesHeaderParser": {
      "methods": {
        "parse": {
          "signature": "(self, fp, headersonly=True)",
          "doc": ""
        },
        "parsebytes": {
          "signature": "(self, text, headersonly=True)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.parser"
    },
    "BytesParser": {
      "methods": {
        "parse": {
          "signature": "(self, fp, headersonly=False)",
          "doc": ""
        },
        "parsebytes": {
          "signature": "(self, text, headersonly=False)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.parser"
    },
    "HeaderParser": {
      "methods": {
        "parse": {
          "signature": "(self, fp, headersonly=True)",
          "doc": ""
        },
        "parsestr": {
          "signature": "(self, text, headersonly=True)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.parser"
    },
    "Parser": {
      "methods": {
        "parse": {
          "signature": "(self, fp, headersonly=False)",
          "doc": ""
        },
        "parsestr": {
          "signature": "(self, text, headersonly=False)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.parser"
    },
    "EmailMessage": {
      "methods": {
        "add_alternative": {
          "signature": "(self, *args, **kw)",
          "doc": ""
        },
        "add_attachment": {
          "signature": "(self, *args, **kw)",
          "doc": ""
        },
        "add_header": {
          "signature": "(self, _name, _value, **_params)",
          "doc": ""
        },
        "add_related": {
          "signature": "(self, *args, **kw)",
          "doc": ""
        },
        "as_bytes": {
          "signature": "(self, unixfrom=False, policy=None)",
          "doc": ""
        },
        "as_string": {
          "signature": "(self, unixfrom=False, maxheaderlen=None, policy=None)",
          "doc": ""
        },
        "attach": {
          "signature": "(self, payload)",
          "doc": ""
        },
        "clear": {
          "signature": "(self)",
          "doc": ""
        },
        "clear_content": {
          "signature": "(self)",
          "doc": ""
        },
        "del_param": {
          "signature": "(self, param, header='content-type', requote=True)",
          "doc": ""
        },
        "get": {
          "signature": "(self, name, failobj=None)",
          "doc": ""
        },
        "get_all": {
          "signature": "(self, name, failobj=None)",
          "doc": ""
        },
        "get_body": {
          "signature": "(self, preferencelist=('related', 'html', 'plain'))",
          "doc": ""
        },
        "get_boundary": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_charset": {
          "signature": "(self)",
          "doc": ""
        },
        "get_charsets": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_content": {
          "signature": "(self, *args, content_manager=None, **kw)",
          "doc": ""
        },
        "get_content_charset": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_content_disposition": {
          "signature": "(self)",
          "doc": ""
        },
        "get_content_maintype": {
          "signature": "(self)",
          "doc": ""
        },
        "get_content_subtype": {
          "signature": "(self)",
          "doc": ""
        },
        "get_content_type": {
          "signature": "(self)",
          "doc": ""
        },
        "get_default_type": {
          "signature": "(self)",
          "doc": ""
        },
        "get_filename": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_param": {
          "signature": "(self, param, failobj=None, header='content-type', unquote=True)",
          "doc": ""
        },
        "get_params": {
          "signature": "(self, failobj=None, header='content-type', unquote=True)",
          "doc": ""
        },
        "get_payload": {
          "signature": "(self, i=None, decode=False)",
          "doc": ""
        },
        "get_unixfrom": {
          "signature": "(self)",
          "doc": ""
        },
        "is_attachment": {
          "signature": "(self)",
          "doc": ""
        },
        "is_multipart": {
          "signature": "(self)",
          "doc": ""
        },
        "items": {
          "signature": "(self)",
          "doc": ""
        },
        "iter_attachments": {
          "signature": "(self)",
          "doc": ""
        },
        "iter_parts": {
          "signature": "(self)",
          "doc": ""
        },
        "keys": {
          "signature": "(self)",
          "doc": ""
        },
        "make_alternative": {
          "signature": "(self, boundary=None)",
          "doc": ""
        },
        "make_mixed": {
          "signature": "(self, boundary=None)",
          "doc": ""
        },
        "make_related": {
          "signature": "(self, boundary=None)",
          "doc": ""
        },
        "raw_items": {
          "signature": "(self)",
          "doc": ""
        },
        "replace_header": {
          "signature": "(self, _name, _value)",
          "doc": ""
        },
        "set_boundary": {
          "signature": "(self, boundary)",
          "doc": ""
        },
        "set_charset": {
          "signature": "(self, charset)",
          "doc": ""
        },
        "set_content": {
          "signature": "(self, *args, **kw)",
          "doc": ""
        },
        "set_default_type": {
          "signature": "(self, ctype)",
          "doc": ""
        },
        "set_param": {
          "signature": "(self, param, value, header='Content-Type', requote=True, charset=None, language='', replace=False)",
          "doc": ""
        },
        "set_payload": {
          "signature": "(self, payload, charset=None)",
          "doc": ""
        },
        "set_raw": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "set_type": {
          "signature": "(self, type, header='Content-Type', requote=True)",
          "doc": ""
        },
        "set_unixfrom": {
          "signature": "(self, unixfrom)",
          "doc": ""
        },
        "values": {
          "signature": "(self)",
          "doc": ""
        },
        "walk": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.message"
    },
    "MIMEPart": {
      "methods": {
        "add_alternative": {
          "signature": "(self, *args, **kw)",
          "doc": ""
        },
        "add_attachment": {
          "signature": "(self, *args, **kw)",
          "doc": ""
        },
        "add_header": {
          "signature": "(self, _name, _value, **_params)",
          "doc": ""
        },
        "add_related": {
          "signature": "(self, *args, **kw)",
          "doc": ""
        },
        "as_bytes": {
          "signature": "(self, unixfrom=False, policy=None)",
          "doc": ""
        },
        "as_string": {
          "signature": "(self, unixfrom=False, maxheaderlen=None, policy=None)",
          "doc": ""
        },
        "attach": {
          "signature": "(self, payload)",
          "doc": ""
        },
        "clear": {
          "signature": "(self)",
          "doc": ""
        },
        "clear_content": {
          "signature": "(self)",
          "doc": ""
        },
        "del_param": {
          "signature": "(self, param, header='content-type', requote=True)",
          "doc": ""
        },
        "get": {
          "signature": "(self, name, failobj=None)",
          "doc": ""
        },
        "get_all": {
          "signature": "(self, name, failobj=None)",
          "doc": ""
        },
        "get_body": {
          "signature": "(self, preferencelist=('related', 'html', 'plain'))",
          "doc": ""
        },
        "get_boundary": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_charset": {
          "signature": "(self)",
          "doc": ""
        },
        "get_charsets": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_content": {
          "signature": "(self, *args, content_manager=None, **kw)",
          "doc": ""
        },
        "get_content_charset": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_content_disposition": {
          "signature": "(self)",
          "doc": ""
        },
        "get_content_maintype": {
          "signature": "(self)",
          "doc": ""
        },
        "get_content_subtype": {
          "signature": "(self)",
          "doc": ""
        },
        "get_content_type": {
          "signature": "(self)",
          "doc": ""
        },
        "get_default_type": {
          "signature": "(self)",
          "doc": ""
        },
        "get_filename": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_param": {
          "signature": "(self, param, failobj=None, header='content-type', unquote=True)",
          "doc": ""
        },
        "get_params": {
          "signature": "(self, failobj=None, header='content-type', unquote=True)",
          "doc": ""
        },
        "get_payload": {
          "signature": "(self, i=None, decode=False)",
          "doc": ""
        },
        "get_unixfrom": {
          "signature": "(self)",
          "doc": ""
        },
        "is_attachment": {
          "signature": "(self)",
          "doc": ""
        },
        "is_multipart": {
          "signature": "(self)",
          "doc": ""
        },
        "items": {
          "signature": "(self)",
          "doc": ""
        },
        "iter_attachments": {
          "signature": "(self)",
          "doc": ""
        },
        "iter_parts": {
          "signature": "(self)",
          "doc": ""
        },
        "keys": {
          "signature": "(self)",
          "doc": ""
        },
        "make_alternative": {
          "signature": "(self, boundary=None)",
          "doc": ""
        },
        "make_mixed": {
          "signature": "(self, boundary=None)",
          "doc": ""
        },
        "make_related": {
          "signature": "(self, boundary=None)",
          "doc": ""
        },
        "raw_items": {
          "signature": "(self)",
          "doc": ""
        },
        "replace_header": {
          "signature": "(self, _name, _value)",
          "doc": ""
        },
        "set_boundary": {
          "signature": "(self, boundary)",
          "doc": ""
        },
        "set_charset": {
          "signature": "(self, charset)",
          "doc": ""
        },
        "set_content": {
          "signature": "(self, *args, content_manager=None, **kw)",
          "doc": ""
        },
        "set_default_type": {
          "signature": "(self, ctype)",
          "doc": ""
        },
        "set_param": {
          "signature": "(self, param, value, header='Content-Type', requote=True, charset=None, language='', replace=False)",
          "doc": ""
        },
        "set_payload": {
          "signature": "(self, payload, charset=None)",
          "doc": ""
        },
        "set_raw": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "set_type": {
          "signature": "(self, type, header='Content-Type', requote=True)",
          "doc": ""
        },
        "set_unixfrom": {
          "signature": "(self, unixfrom)",
          "doc": ""
        },
        "values": {
          "signature": "(self)",
          "doc": ""
        },
        "walk": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.message"
    },
    "Message": {
      "methods": {
        "add_header": {
          "signature": "(self, _name, _value, **_params)",
          "doc": ""
        },
        "as_bytes": {
          "signature": "(self, unixfrom=False, policy=None)",
          "doc": ""
        },
        "as_string": {
          "signature": "(self, unixfrom=False, maxheaderlen=0, policy=None)",
          "doc": ""
        },
        "attach": {
          "signature": "(self, payload)",
          "doc": ""
        },
        "del_param": {
          "signature": "(self, param, header='content-type', requote=True)",
          "doc": ""
        },
        "get": {
          "signature": "(self, name, failobj=None)",
          "doc": ""
        },
        "get_all": {
          "signature": "(self, name, failobj=None)",
          "doc": ""
        },
        "get_boundary": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_charset": {
          "signature": "(self)",
          "doc": ""
        },
        "get_charsets": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_content_charset": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_content_disposition": {
          "signature": "(self)",
          "doc": ""
        },
        "get_content_maintype": {
          "signature": "(self)",
          "doc": ""
        },
        "get_content_subtype": {
          "signature": "(self)",
          "doc": ""
        },
        "get_content_type": {
          "signature": "(self)",
          "doc": ""
        },
        "get_default_type": {
          "signature": "(self)",
          "doc": ""
        },
        "get_filename": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_param": {
          "signature": "(self, param, failobj=None, header='content-type', unquote=True)",
          "doc": ""
        },
        "get_params": {
          "signature": "(self, failobj=None, header='content-type', unquote=True)",
          "doc": ""
        },
        "get_payload": {
          "signature": "(self, i=None, decode=False)",
          "doc": ""
        },
        "get_unixfrom": {
          "signature": "(self)",
          "doc": ""
        },
        "is_multipart": {
          "signature": "(self)",
          "doc": ""
        },
        "items": {
          "signature": "(self)",
          "doc": ""
        },
        "keys": {
          "signature": "(self)",
          "doc": ""
        },
        "raw_items": {
          "signature": "(self)",
          "doc": ""
        },
        "replace_header": {
          "signature": "(self, _name, _value)",
          "doc": ""
        },
        "set_boundary": {
          "signature": "(self, boundary)",
          "doc": ""
        },
        "set_charset": {
          "signature": "(self, charset)",
          "doc": ""
        },
        "set_default_type": {
          "signature": "(self, ctype)",
          "doc": ""
        },
        "set_param": {
          "signature": "(self, param, value, header='Content-Type', requote=True, charset=None, language='', replace=False)",
          "doc": ""
        },
        "set_payload": {
          "signature": "(self, payload, charset=None)",
          "doc": ""
        },
        "set_raw": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "set_type": {
          "signature": "(self, type, header='Content-Type', requote=True)",
          "doc": ""
        },
        "set_unixfrom": {
          "signature": "(self, unixfrom)",
          "doc": ""
        },
        "values": {
          "signature": "(self)",
          "doc": ""
        },
        "walk": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.message"
    },
    "AlertDescription": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "ssl"
    },
    "CertificateError": {
      "methods": {},
      "doc": "A certificate could not be verified.",
      "module": "ssl"
    },
    "DefaultVerifyPaths": {
      "methods": {},
      "doc": "DefaultVerifyPaths(cafile, capath, openssl_cafile_env, openssl_cafile, openssl_capath_env, openssl_capath)",
      "module": "ssl"
    },
    "MemoryBIO": {
      "methods": {},
      "doc": "",
      "module": "ssl"
    },
    "Options": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "ssl"
    },
    "Purpose": {
      "methods": {},
      "doc": "",
      "module": "ssl"
    },
    "SSLCertVerificationError": {
      "methods": {},
      "doc": "A certificate could not be verified.",
      "module": "ssl"
    },
    "SSLContext": {
      "methods": {
        "load_default_certs": {
          "signature": "(self, purpose=<Purpose.SERVER_AUTH: _ASN1Object(nid=129, shortname='serverAuth', longname='TLS Web Server Authentication', oid='1.3.6.1.5.5.7.3.1')>)",
          "doc": ""
        },
        "set_alpn_protocols": {
          "signature": "(self, alpn_protocols)",
          "doc": ""
        },
        "set_npn_protocols": {
          "signature": "(self, npn_protocols)",
          "doc": ""
        },
        "set_servername_callback": {
          "signature": "(self, server_name_callback)",
          "doc": ""
        },
        "wrap_bio": {
          "signature": "(self, incoming, outgoing, server_side=False, server_hostname=None, session=None)",
          "doc": ""
        },
        "wrap_socket": {
          "signature": "(self, sock, server_side=False, do_handshake_on_connect=True, suppress_ragged_eofs=True, server_hostname=None, session=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "ssl"
    },
    "SSLEOFError": {
      "methods": {},
      "doc": "SSL/TLS connection terminated abruptly.",
      "module": "ssl"
    },
    "SSLError": {
      "methods": {},
      "doc": "An error occurred in the SSL implementation.",
      "module": "ssl"
    },
    "SSLErrorNumber": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "ssl"
    },
    "SSLObject": {
      "methods": {
        "cipher": {
          "signature": "(self)",
          "doc": ""
        },
        "compression": {
          "signature": "(self)",
          "doc": ""
        },
        "do_handshake": {
          "signature": "(self)",
          "doc": ""
        },
        "get_channel_binding": {
          "signature": "(self, cb_type='tls-unique')",
          "doc": ""
        },
        "getpeercert": {
          "signature": "(self, binary_form=False)",
          "doc": ""
        },
        "pending": {
          "signature": "(self)",
          "doc": ""
        },
        "read": {
          "signature": "(self, len=1024, buffer=None)",
          "doc": ""
        },
        "selected_alpn_protocol": {
          "signature": "(self)",
          "doc": ""
        },
        "selected_npn_protocol": {
          "signature": "(self)",
          "doc": ""
        },
        "shared_ciphers": {
          "signature": "(self)",
          "doc": ""
        },
        "unwrap": {
          "signature": "(self)",
          "doc": ""
        },
        "verify_client_post_handshake": {
          "signature": "(self)",
          "doc": ""
        },
        "version": {
          "signature": "(self)",
          "doc": ""
        },
        "write": {
          "signature": "(self, data)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "ssl"
    },
    "SSLSession": {
      "methods": {},
      "doc": "",
      "module": "ssl"
    },
    "SSLSocket": {
      "methods": {
        "accept": {
          "signature": "(self)",
          "doc": ""
        },
        "cipher": {
          "signature": "(self)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "compression": {
          "signature": "(self)",
          "doc": ""
        },
        "connect": {
          "signature": "(self, addr)",
          "doc": ""
        },
        "connect_ex": {
          "signature": "(self, addr)",
          "doc": ""
        },
        "detach": {
          "signature": "(self)",
          "doc": ""
        },
        "do_handshake": {
          "signature": "(self, block=False)",
          "doc": ""
        },
        "dup": {
          "signature": "(self)",
          "doc": ""
        },
        "get_channel_binding": {
          "signature": "(self, cb_type='tls-unique')",
          "doc": ""
        },
        "get_inheritable": {
          "signature": "(self)",
          "doc": "Get the inheritable flag of the socket"
        },
        "getpeercert": {
          "signature": "(self, binary_form=False)",
          "doc": ""
        },
        "makefile": {
          "signature": "(self, mode='r', buffering=None, *, encoding=None, errors=None, newline=None)",
          "doc": ""
        },
        "pending": {
          "signature": "(self)",
          "doc": ""
        },
        "read": {
          "signature": "(self, len=1024, buffer=None)",
          "doc": ""
        },
        "recv": {
          "signature": "(self, buflen=1024, flags=0)",
          "doc": ""
        },
        "recv_into": {
          "signature": "(self, buffer, nbytes=None, flags=0)",
          "doc": ""
        },
        "recvfrom": {
          "signature": "(self, buflen=1024, flags=0)",
          "doc": ""
        },
        "recvfrom_into": {
          "signature": "(self, buffer, nbytes=None, flags=0)",
          "doc": ""
        },
        "recvmsg": {
          "signature": "(self, *args, **kwargs)",
          "doc": ""
        },
        "recvmsg_into": {
          "signature": "(self, *args, **kwargs)",
          "doc": ""
        },
        "selected_alpn_protocol": {
          "signature": "(self)",
          "doc": ""
        },
        "selected_npn_protocol": {
          "signature": "(self)",
          "doc": ""
        },
        "send": {
          "signature": "(self, data, flags=0)",
          "doc": ""
        },
        "sendall": {
          "signature": "(self, data, flags=0)",
          "doc": ""
        },
        "sendfile": {
          "signature": "(self, file, offset=0, count=None)",
          "doc": ""
        },
        "sendmsg": {
          "signature": "(self, *args, **kwargs)",
          "doc": ""
        },
        "sendto": {
          "signature": "(self, data, flags_or_addr, addr=None)",
          "doc": ""
        },
        "set_inheritable": {
          "signature": "(self, inheritable)",
          "doc": "Set the inheritable flag of the socket"
        },
        "shared_ciphers": {
          "signature": "(self)",
          "doc": ""
        },
        "shutdown": {
          "signature": "(self, how)",
          "doc": ""
        },
        "unwrap": {
          "signature": "(self)",
          "doc": ""
        },
        "verify_client_post_handshake": {
          "signature": "(self)",
          "doc": ""
        },
        "version": {
          "signature": "(self)",
          "doc": ""
        },
        "write": {
          "signature": "(self, data)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "ssl"
    },
    "SSLSyscallError": {
      "methods": {},
      "doc": "System error when attempting SSL operation.",
      "module": "ssl"
    },
    "SSLWantReadError": {
      "methods": {},
      "doc": "Non-blocking SSL socket needs to read more data",
      "module": "ssl"
    },
    "SSLWantWriteError": {
      "methods": {},
      "doc": "Non-blocking SSL socket needs to write more data",
      "module": "ssl"
    },
    "SSLZeroReturnError": {
      "methods": {},
      "doc": "SSL/TLS session closed cleanly.",
      "module": "ssl"
    },
    "TLSVersion": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "ssl"
    },
    "VerifyFlags": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "ssl"
    },
    "VerifyMode": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "ssl"
    },
    "socket_error": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "ssl"
    },
    "BadStatusLine": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "CannotSendHeader": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "CannotSendRequest": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "HTTPConnection": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "connect": {
          "signature": "(self)",
          "doc": ""
        },
        "endheaders": {
          "signature": "(self, message_body=None, *, encode_chunked=False)",
          "doc": ""
        },
        "getresponse": {
          "signature": "(self)",
          "doc": ""
        },
        "putheader": {
          "signature": "(self, header, *values)",
          "doc": ""
        },
        "putrequest": {
          "signature": "(self, method, url, skip_host=False, skip_accept_encoding=False)",
          "doc": ""
        },
        "request": {
          "signature": "(self, method, url, body=None, headers={}, *, encode_chunked=False)",
          "doc": ""
        },
        "send": {
          "signature": "(self, data)",
          "doc": ""
        },
        "set_debuglevel": {
          "signature": "(self, level)",
          "doc": ""
        },
        "set_tunnel": {
          "signature": "(self, host, port=None, headers=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "http.client"
    },
    "HTTPException": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "HTTPMessage": {
      "methods": {
        "add_header": {
          "signature": "(self, _name, _value, **_params)",
          "doc": ""
        },
        "as_bytes": {
          "signature": "(self, unixfrom=False, policy=None)",
          "doc": ""
        },
        "as_string": {
          "signature": "(self, unixfrom=False, maxheaderlen=0, policy=None)",
          "doc": ""
        },
        "attach": {
          "signature": "(self, payload)",
          "doc": ""
        },
        "del_param": {
          "signature": "(self, param, header='content-type', requote=True)",
          "doc": ""
        },
        "get": {
          "signature": "(self, name, failobj=None)",
          "doc": ""
        },
        "get_all": {
          "signature": "(self, name, failobj=None)",
          "doc": ""
        },
        "get_boundary": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_charset": {
          "signature": "(self)",
          "doc": ""
        },
        "get_charsets": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_content_charset": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_content_disposition": {
          "signature": "(self)",
          "doc": ""
        },
        "get_content_maintype": {
          "signature": "(self)",
          "doc": ""
        },
        "get_content_subtype": {
          "signature": "(self)",
          "doc": ""
        },
        "get_content_type": {
          "signature": "(self)",
          "doc": ""
        },
        "get_default_type": {
          "signature": "(self)",
          "doc": ""
        },
        "get_filename": {
          "signature": "(self, failobj=None)",
          "doc": ""
        },
        "get_param": {
          "signature": "(self, param, failobj=None, header='content-type', unquote=True)",
          "doc": ""
        },
        "get_params": {
          "signature": "(self, failobj=None, header='content-type', unquote=True)",
          "doc": ""
        },
        "get_payload": {
          "signature": "(self, i=None, decode=False)",
          "doc": ""
        },
        "get_unixfrom": {
          "signature": "(self)",
          "doc": ""
        },
        "getallmatchingheaders": {
          "signature": "(self, name)",
          "doc": ""
        },
        "is_multipart": {
          "signature": "(self)",
          "doc": ""
        },
        "items": {
          "signature": "(self)",
          "doc": ""
        },
        "keys": {
          "signature": "(self)",
          "doc": ""
        },
        "raw_items": {
          "signature": "(self)",
          "doc": ""
        },
        "replace_header": {
          "signature": "(self, _name, _value)",
          "doc": ""
        },
        "set_boundary": {
          "signature": "(self, boundary)",
          "doc": ""
        },
        "set_charset": {
          "signature": "(self, charset)",
          "doc": ""
        },
        "set_default_type": {
          "signature": "(self, ctype)",
          "doc": ""
        },
        "set_param": {
          "signature": "(self, param, value, header='Content-Type', requote=True, charset=None, language='', replace=False)",
          "doc": ""
        },
        "set_payload": {
          "signature": "(self, payload, charset=None)",
          "doc": ""
        },
        "set_raw": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "set_type": {
          "signature": "(self, type, header='Content-Type', requote=True)",
          "doc": ""
        },
        "set_unixfrom": {
          "signature": "(self, unixfrom)",
          "doc": ""
        },
        "values": {
          "signature": "(self)",
          "doc": ""
        },
        "walk": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "http.client"
    },
    "HTTPResponse": {
      "methods": {
        "begin": {
          "signature": "(self)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "fileno": {
          "signature": "(self)",
          "doc": ""
        },
        "flush": {
          "signature": "(self)",
          "doc": ""
        },
        "getcode": {
          "signature": "(self)",
          "doc": ""
        },
        "getheader": {
          "signature": "(self, name, default=None)",
          "doc": ""
        },
        "getheaders": {
          "signature": "(self)",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        },
        "info": {
          "signature": "(self)",
          "doc": ""
        },
        "isclosed": {
          "signature": "(self)",
          "doc": ""
        },
        "peek": {
          "signature": "(self, n=-1)",
          "doc": ""
        },
        "read": {
          "signature": "(self, amt=None)",
          "doc": ""
        },
        "read1": {
          "signature": "(self, n=-1)",
          "doc": ""
        },
        "readable": {
          "signature": "(self)",
          "doc": ""
        },
        "readinto": {
          "signature": "(self, b)",
          "doc": ""
        },
        "readline": {
          "signature": "(self, limit=-1)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "http.client"
    },
    "HTTPSConnection": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "connect": {
          "signature": "(self)",
          "doc": ""
        },
        "endheaders": {
          "signature": "(self, message_body=None, *, encode_chunked=False)",
          "doc": ""
        },
        "getresponse": {
          "signature": "(self)",
          "doc": ""
        },
        "putheader": {
          "signature": "(self, header, *values)",
          "doc": ""
        },
        "putrequest": {
          "signature": "(self, method, url, skip_host=False, skip_accept_encoding=False)",
          "doc": ""
        },
        "request": {
          "signature": "(self, method, url, body=None, headers={}, *, encode_chunked=False)",
          "doc": ""
        },
        "send": {
          "signature": "(self, data)",
          "doc": ""
        },
        "set_debuglevel": {
          "signature": "(self, level)",
          "doc": ""
        },
        "set_tunnel": {
          "signature": "(self, host, port=None, headers=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "http.client"
    },
    "ImproperConnectionState": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "IncompleteRead": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "InvalidURL": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "LineTooLong": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "NotConnected": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "RemoteDisconnected": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "ResponseNotReady": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "UnimplementedFileMode": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "UnknownProtocol": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "UnknownTransferEncoding": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "AbstractBasicAuthHandler": {
      "methods": {
        "http_error_auth_reqed": {
          "signature": "(self, authreq, host, req, headers)",
          "doc": ""
        },
        "http_request": {
          "signature": "(self, req)",
          "doc": ""
        },
        "http_response": {
          "signature": "(self, req, response)",
          "doc": ""
        },
        "https_request": {
          "signature": "(self, req)",
          "doc": ""
        },
        "https_response": {
          "signature": "(self, req, response)",
          "doc": ""
        },
        "retry_http_basic_auth": {
          "signature": "(self, host, req, realm)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "AbstractDigestAuthHandler": {
      "methods": {
        "get_algorithm_impls": {
          "signature": "(self, algorithm)",
          "doc": ""
        },
        "get_authorization": {
          "signature": "(self, req, chal)",
          "doc": ""
        },
        "get_cnonce": {
          "signature": "(self, nonce)",
          "doc": ""
        },
        "get_entity_digest": {
          "signature": "(self, data, chal)",
          "doc": ""
        },
        "http_error_auth_reqed": {
          "signature": "(self, auth_header, host, req, headers)",
          "doc": ""
        },
        "reset_retry_count": {
          "signature": "(self)",
          "doc": ""
        },
        "retry_http_digest_auth": {
          "signature": "(self, req, auth)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "AbstractHTTPHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "do_open": {
          "signature": "(self, http_class, req, **http_conn_args)",
          "doc": ""
        },
        "do_request_": {
          "signature": "(self, request)",
          "doc": ""
        },
        "set_http_debuglevel": {
          "signature": "(self, level)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "BaseHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "CacheFTPHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "check_cache": {
          "signature": "(self)",
          "doc": ""
        },
        "clear_cache": {
          "signature": "(self)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "connect_ftp": {
          "signature": "(self, user, passwd, host, port, dirs, timeout)",
          "doc": ""
        },
        "ftp_open": {
          "signature": "(self, req)",
          "doc": ""
        },
        "setMaxConns": {
          "signature": "(self, m)",
          "doc": ""
        },
        "setTimeout": {
          "signature": "(self, t)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "DataHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "data_open": {
          "signature": "(self, req)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "FTPHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "connect_ftp": {
          "signature": "(self, user, passwd, host, port, dirs, timeout)",
          "doc": ""
        },
        "ftp_open": {
          "signature": "(self, req)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "FancyURLopener": {
      "methods": {
        "addheader": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "cleanup": {
          "signature": "(self)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "get_user_passwd": {
          "signature": "(self, host, realm, clear_cache=0)",
          "doc": ""
        },
        "http_error": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None)",
          "doc": ""
        },
        "http_error_301": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None)",
          "doc": ""
        },
        "http_error_302": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None)",
          "doc": ""
        },
        "http_error_303": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None)",
          "doc": ""
        },
        "http_error_307": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None)",
          "doc": ""
        },
        "http_error_308": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None)",
          "doc": ""
        },
        "http_error_401": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None, retry=False)",
          "doc": ""
        },
        "http_error_407": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None, retry=False)",
          "doc": ""
        },
        "http_error_default": {
          "signature": "(self, url, fp, errcode, errmsg, headers)",
          "doc": ""
        },
        "open": {
          "signature": "(self, fullurl, data=None)",
          "doc": ""
        },
        "open_data": {
          "signature": "(self, url, data=None)",
          "doc": ""
        },
        "open_file": {
          "signature": "(self, url)",
          "doc": ""
        },
        "open_ftp": {
          "signature": "(self, url)",
          "doc": ""
        },
        "open_http": {
          "signature": "(self, url, data=None)",
          "doc": ""
        },
        "open_https": {
          "signature": "(self, url, data=None)",
          "doc": ""
        },
        "open_local_file": {
          "signature": "(self, url)",
          "doc": ""
        },
        "open_unknown": {
          "signature": "(self, fullurl, data=None)",
          "doc": ""
        },
        "open_unknown_proxy": {
          "signature": "(self, proxy, fullurl, data=None)",
          "doc": ""
        },
        "prompt_user_passwd": {
          "signature": "(self, host, realm)",
          "doc": ""
        },
        "redirect_internal": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data)",
          "doc": ""
        },
        "retrieve": {
          "signature": "(self, url, filename=None, reporthook=None, data=None)",
          "doc": ""
        },
        "retry_http_basic_auth": {
          "signature": "(self, url, realm, data=None)",
          "doc": ""
        },
        "retry_https_basic_auth": {
          "signature": "(self, url, realm, data=None)",
          "doc": ""
        },
        "retry_proxy_http_basic_auth": {
          "signature": "(self, url, realm, data=None)",
          "doc": ""
        },
        "retry_proxy_https_basic_auth": {
          "signature": "(self, url, realm, data=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "FileHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "file_open": {
          "signature": "(self, req)",
          "doc": ""
        },
        "get_names": {
          "signature": "(self)",
          "doc": ""
        },
        "open_local_file": {
          "signature": "(self, req)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPBasicAuthHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "http_error_401": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_auth_reqed": {
          "signature": "(self, authreq, host, req, headers)",
          "doc": ""
        },
        "http_request": {
          "signature": "(self, req)",
          "doc": ""
        },
        "http_response": {
          "signature": "(self, req, response)",
          "doc": ""
        },
        "https_request": {
          "signature": "(self, req)",
          "doc": ""
        },
        "https_response": {
          "signature": "(self, req, response)",
          "doc": ""
        },
        "retry_http_basic_auth": {
          "signature": "(self, host, req, realm)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPCookieProcessor": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "http_request": {
          "signature": "(self, request)",
          "doc": ""
        },
        "http_response": {
          "signature": "(self, request, response)",
          "doc": ""
        },
        "https_request": {
          "signature": "(self, request)",
          "doc": ""
        },
        "https_response": {
          "signature": "(self, request, response)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPDefaultErrorHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "http_error_default": {
          "signature": "(self, req, fp, code, msg, hdrs)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPDigestAuthHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "get_algorithm_impls": {
          "signature": "(self, algorithm)",
          "doc": ""
        },
        "get_authorization": {
          "signature": "(self, req, chal)",
          "doc": ""
        },
        "get_cnonce": {
          "signature": "(self, nonce)",
          "doc": ""
        },
        "get_entity_digest": {
          "signature": "(self, data, chal)",
          "doc": ""
        },
        "http_error_401": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_auth_reqed": {
          "signature": "(self, auth_header, host, req, headers)",
          "doc": ""
        },
        "reset_retry_count": {
          "signature": "(self)",
          "doc": ""
        },
        "retry_http_digest_auth": {
          "signature": "(self, req, auth)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPErrorProcessor": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "http_response": {
          "signature": "(self, request, response)",
          "doc": ""
        },
        "https_response": {
          "signature": "(self, request, response)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "do_open": {
          "signature": "(self, http_class, req, **http_conn_args)",
          "doc": ""
        },
        "do_request_": {
          "signature": "(self, request)",
          "doc": ""
        },
        "http_open": {
          "signature": "(self, req)",
          "doc": ""
        },
        "http_request": {
          "signature": "(self, request)",
          "doc": ""
        },
        "set_http_debuglevel": {
          "signature": "(self, level)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPPasswordMgr": {
      "methods": {
        "add_password": {
          "signature": "(self, realm, uri, user, passwd)",
          "doc": ""
        },
        "find_user_password": {
          "signature": "(self, realm, authuri)",
          "doc": ""
        },
        "is_suburi": {
          "signature": "(self, base, test)",
          "doc": ""
        },
        "reduce_uri": {
          "signature": "(self, uri, default_port=True)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPPasswordMgrWithDefaultRealm": {
      "methods": {
        "add_password": {
          "signature": "(self, realm, uri, user, passwd)",
          "doc": ""
        },
        "find_user_password": {
          "signature": "(self, realm, authuri)",
          "doc": ""
        },
        "is_suburi": {
          "signature": "(self, base, test)",
          "doc": ""
        },
        "reduce_uri": {
          "signature": "(self, uri, default_port=True)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPPasswordMgrWithPriorAuth": {
      "methods": {
        "add_password": {
          "signature": "(self, realm, uri, user, passwd, is_authenticated=False)",
          "doc": ""
        },
        "find_user_password": {
          "signature": "(self, realm, authuri)",
          "doc": ""
        },
        "is_authenticated": {
          "signature": "(self, authuri)",
          "doc": ""
        },
        "is_suburi": {
          "signature": "(self, base, test)",
          "doc": ""
        },
        "reduce_uri": {
          "signature": "(self, uri, default_port=True)",
          "doc": ""
        },
        "update_authenticated": {
          "signature": "(self, uri, is_authenticated=False)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPRedirectHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "http_error_301": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_302": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_303": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_307": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_308": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "redirect_request": {
          "signature": "(self, req, fp, code, msg, headers, newurl)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPSHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "do_open": {
          "signature": "(self, http_class, req, **http_conn_args)",
          "doc": ""
        },
        "do_request_": {
          "signature": "(self, request)",
          "doc": ""
        },
        "https_open": {
          "signature": "(self, req)",
          "doc": ""
        },
        "https_request": {
          "signature": "(self, request)",
          "doc": ""
        },
        "set_http_debuglevel": {
          "signature": "(self, level)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "OpenerDirector": {
      "methods": {
        "add_handler": {
          "signature": "(self, handler)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "error": {
          "signature": "(self, proto, *args)",
          "doc": ""
        },
        "open": {
          "signature": "(self, fullurl, data=None, timeout=<object object at 0x0000014D00B04400>)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "ProxyBasicAuthHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "http_error_407": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_auth_reqed": {
          "signature": "(self, authreq, host, req, headers)",
          "doc": ""
        },
        "http_request": {
          "signature": "(self, req)",
          "doc": ""
        },
        "http_response": {
          "signature": "(self, req, response)",
          "doc": ""
        },
        "https_request": {
          "signature": "(self, req)",
          "doc": ""
        },
        "https_response": {
          "signature": "(self, req, response)",
          "doc": ""
        },
        "retry_http_basic_auth": {
          "signature": "(self, host, req, realm)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "ProxyDigestAuthHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "get_algorithm_impls": {
          "signature": "(self, algorithm)",
          "doc": ""
        },
        "get_authorization": {
          "signature": "(self, req, chal)",
          "doc": ""
        },
        "get_cnonce": {
          "signature": "(self, nonce)",
          "doc": ""
        },
        "get_entity_digest": {
          "signature": "(self, data, chal)",
          "doc": ""
        },
        "http_error_407": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_auth_reqed": {
          "signature": "(self, auth_header, host, req, headers)",
          "doc": ""
        },
        "reset_retry_count": {
          "signature": "(self)",
          "doc": ""
        },
        "retry_http_digest_auth": {
          "signature": "(self, req, auth)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "ProxyHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "proxy_open": {
          "signature": "(self, req, proxy, type)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "Request": {
      "methods": {
        "add_header": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "add_unredirected_header": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "get_full_url": {
          "signature": "(self)",
          "doc": ""
        },
        "get_header": {
          "signature": "(self, header_name, default=None)",
          "doc": ""
        },
        "get_method": {
          "signature": "(self)",
          "doc": ""
        },
        "has_header": {
          "signature": "(self, header_name)",
          "doc": ""
        },
        "has_proxy": {
          "signature": "(self)",
          "doc": ""
        },
        "header_items": {
          "signature": "(self)",
          "doc": ""
        },
        "remove_header": {
          "signature": "(self, header_name)",
          "doc": ""
        },
        "set_proxy": {
          "signature": "(self, host, type)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "URLopener": {
      "methods": {
        "addheader": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "cleanup": {
          "signature": "(self)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "http_error": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None)",
          "doc": ""
        },
        "http_error_default": {
          "signature": "(self, url, fp, errcode, errmsg, headers)",
          "doc": ""
        },
        "open": {
          "signature": "(self, fullurl, data=None)",
          "doc": ""
        },
        "open_data": {
          "signature": "(self, url, data=None)",
          "doc": ""
        },
        "open_file": {
          "signature": "(self, url)",
          "doc": ""
        },
        "open_ftp": {
          "signature": "(self, url)",
          "doc": ""
        },
        "open_http": {
          "signature": "(self, url, data=None)",
          "doc": ""
        },
        "open_https": {
          "signature": "(self, url, data=None)",
          "doc": ""
        },
        "open_local_file": {
          "signature": "(self, url)",
          "doc": ""
        },
        "open_unknown": {
          "signature": "(self, fullurl, data=None)",
          "doc": ""
        },
        "open_unknown_proxy": {
          "signature": "(self, proxy, fullurl, data=None)",
          "doc": ""
        },
        "retrieve": {
          "signature": "(self, url, filename=None, reporthook=None, data=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "UnknownHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "unknown_open": {
          "signature": "(self, req)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "ftpwrapper": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "endtransfer": {
          "signature": "(self)",
          "doc": ""
        },
        "file_close": {
          "signature": "(self)",
          "doc": ""
        },
        "init": {
          "signature": "(self)",
          "doc": ""
        },
        "real_close": {
          "signature": "(self)",
          "doc": ""
        },
        "retrfile": {
          "signature": "(self, file, type)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "ATOM": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "BOOL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "BOOLEAN": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "BYTE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "CHAR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "COLORREF": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "DOUBLE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "DWORD": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "FILETIME": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "FLOAT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HACCEL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HANDLE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HBITMAP": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HBRUSH": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HCOLORSPACE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HDC": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HDESK": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HDWP": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HENHMETAFILE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HFONT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HGDIOBJ": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HGLOBAL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HHOOK": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HICON": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HINSTANCE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HKEY": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HKL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HLOCAL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HMENU": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HMETAFILE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HMODULE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HMONITOR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HPALETTE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HPEN": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HRGN": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HRSRC": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HSTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HTASK": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HWINSTA": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HWND": {
      "methods": {},
      "doc": "",
      "module": "msgbox"
    },
    "INT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LANGID": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LARGE_INTEGER": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LCID": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LCTYPE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LGRPID": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LONG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPARAM": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPBOOL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPBYTE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPCOLESTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPCOLORREF": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPCSTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPCVOID": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPCWSTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPDWORD": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPFILETIME": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPHANDLE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPHKL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPLONG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPMSG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPOLESTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPPOINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPRECT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPRECTL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPSC_HANDLE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPSIZE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPSIZEL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPSTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPUINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPVOID": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPWIN32_FIND_DATAA": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPWIN32_FIND_DATAW": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPWORD": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPWSTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "MSG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "OLESTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PBOOL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PBOOLEAN": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PBYTE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PCHAR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PDWORD": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PFILETIME": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PFLOAT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PHANDLE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PHKEY": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PLARGE_INTEGER": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PLCID": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PLONG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PMSG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "POINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "POINTL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PPOINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PPOINTL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PRECT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PRECTL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PSHORT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PSIZE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PSIZEL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PSMALL_RECT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PUINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PULARGE_INTEGER": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PULONG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PUSHORT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PWCHAR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PWIN32_FIND_DATAA": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PWIN32_FIND_DATAW": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PWORD": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "RECT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "RECTL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "SC_HANDLE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "SERVICE_STATUS_HANDLE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "SHORT": {
      "methods": {},
      "doc": "",
      "module": "msgbox"
    },
    "SIZE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "SIZEL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "SMALL_RECT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "UINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "ULARGE_INTEGER": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "ULONG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "USHORT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "VARIANT_BOOL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "WCHAR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "WIN32_FIND_DATAA": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "WIN32_FIND_DATAW": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "WORD": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "WPARAM": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "tagMSG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "tagPOINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "tagRECT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "tagSIZE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "prototype": {
      "methods": {},
      "doc": "",
      "module": "msgbox"
    },
    "Finalize": {
      "methods": {
        "cancel": {
          "signature": "(self)",
          "doc": ""
        },
        "still_active": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing.util"
    },
    "ForkAwareLocal": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing.util"
    },
    "ForkAwareThreadLock": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing.util"
    },
    "L": {
      "methods": {},
      "doc": "",
      "module": "freeze.utils"
    },
    "CallerProxy": {
      "methods": {
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.obfjump"
    },
    "OJumperBuffer": {
      "methods": {
        "GetDataSize": {
          "signature": "(self)",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, pbuf)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.obfjump"
    },
    "ObjPool": {
      "methods": {
        "alloc": {
          "signature": "(self, basetype, *args, **kwargs)",
          "doc": ""
        },
        "free": {
          "signature": "(self, basetype, data) -> None",
          "doc": ""
        },
        "full": {
          "signature": "(self) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.collections.objpool"
    },
    "CompletionGenerator": {
      "methods": {
        "analyze_module": {
          "signature": "(self, module_name, module_obj)",
          "doc": "모듈 분석해서 함수와 클래스 정보 추출"
        },
        "save_completions": {
          "signature": "(self)",
          "doc": "결과를 JSON 파일로 저장"
        },
        "scan_libraries": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "main"
    },
    "c_make_scanner": {
      "methods": {},
      "doc": "JSON scanner object",
      "module": "json.scanner"
    },
    "make_scanner": {
      "methods": {},
      "doc": "JSON scanner object",
      "module": "json.scanner"
    },
    "JSONDecodeError": {
      "methods": {},
      "doc": "",
      "module": "json"
    },
    "JSONDecoder": {
      "methods": {
        "decode": {
          "signature": "(self, s, _w=<built-in method match of re.Pattern object at 0x0000014D038BEDC0>)",
          "doc": ""
        },
        "raw_decode": {
          "signature": "(self, s, idx=0)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "json"
    },
    "JSONEncoder": {
      "methods": {
        "default": {
          "signature": "(self, o)",
          "doc": ""
        },
        "encode": {
          "signature": "(self, o)",
          "doc": ""
        },
        "iterencode": {
          "signature": "(self, o, _one_shot=False)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "json"
    },
    "c_make_encoder": {
      "methods": {},
      "doc": "_iterencode(obj, _current_indent_level) -> iterable",
      "module": "json.encoder"
    },
    "ImpImporter": {
      "methods": {
        "find_module": {
          "signature": "(self, fullname, path=None)",
          "doc": ""
        },
        "iter_modules": {
          "signature": "(self, prefix='')",
          "doc": ""
        }
      },
      "doc": "",
      "module": "pkgutil"
    },
    "ImpLoader": {
      "methods": {
        "get_code": {
          "signature": "(self, fullname=None)",
          "doc": ""
        },
        "get_data": {
          "signature": "(self, pathname)",
          "doc": ""
        },
        "get_filename": {
          "signature": "(self, fullname=None)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname=None)",
          "doc": ""
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": ""
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "pkgutil"
    },
    "ModuleInfo": {
      "methods": {},
      "doc": "A namedtuple with minimal info about a module.",
      "module": "pkgutil"
    }
  },
  "vars": {
    "api_version": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sys"
    },
    "argv": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sys"
    },
    "base_exec_prefix": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "base_prefix": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "builtin_module_names": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "sys"
    },
    "byteorder": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "copyright": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "dllhandle": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sys"
    },
    "dont_write_bytecode": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "sys"
    },
    "exec_prefix": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "executable": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "flags": {
      "doc": "sys.flags",
      "type": "flags",
      "module": "sys"
    },
    "float_info": {
      "doc": "sys.float_info",
      "type": "float_info",
      "module": "sys"
    },
    "float_repr_style": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "frozen": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "sys"
    },
    "frozen_dir": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "hash_info": {
      "doc": "hash_info",
      "type": "hash_info",
      "module": "sys"
    },
    "hexversion": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sys"
    },
    "implementation": {
      "doc": "A simple attribute-based namespace.",
      "type": "SimpleNamespace",
      "module": "sys"
    },
    "int_info": {
      "doc": "sys.int_info",
      "type": "int_info",
      "module": "sys"
    },
    "maxsize": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pickle"
    },
    "maxunicode": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sys"
    },
    "meta_path": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sys"
    },
    "modules": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sys"
    },
    "orig_argv": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sys"
    },
    "path": {
      "doc": "Common pathname manipulations, WindowsNT/95 version.",
      "type": "module",
      "module": "os"
    },
    "path_hooks": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sys"
    },
    "path_importer_cache": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sys"
    },
    "platform": {
      "doc": "",
      "type": "module",
      "module": "eudplib.epscript.epscompile"
    },
    "platlibdir": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "prefix": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "pycache_prefix": {
      "doc": "",
      "type": "NoneType",
      "module": "sys"
    },
    "stderr": {
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "type": "TextIOWrapper",
      "module": "sys"
    },
    "stdin": {
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "type": "TextIOWrapper",
      "module": "sys"
    },
    "stdlib_module_names": {
      "doc": "frozenset() -> empty frozenset object",
      "type": "frozenset",
      "module": "sys"
    },
    "stdout": {
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "type": "TextIOWrapper",
      "module": "sys"
    },
    "thread_info": {
      "doc": "sys.thread_info",
      "type": "thread_info",
      "module": "sys"
    },
    "version": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "euddraft"
    },
    "version_info": {
      "doc": "sys.version_info",
      "type": "version_info",
      "module": "sys"
    },
    "warnoptions": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sys"
    },
    "winver": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "Ellipsis": {
      "doc": "",
      "type": "ellipsis",
      "module": "builtins"
    },
    "False": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "builtins"
    },
    "None": {
      "doc": "",
      "type": "NoneType",
      "module": "builtins"
    },
    "NotImplemented": {
      "doc": "",
      "type": "NotImplementedType",
      "module": "builtins"
    },
    "True": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "builtins"
    },
    "HKEY_CLASSES_ROOT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_CURRENT_CONFIG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_CURRENT_USER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_DYN_DATA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_LOCAL_MACHINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_PERFORMANCE_DATA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_USERS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_ALL_ACCESS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_CREATE_LINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_CREATE_SUB_KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_ENUMERATE_SUB_KEYS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_EXECUTE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_NOTIFY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_QUERY_VALUE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_READ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_SET_VALUE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_WOW64_32KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_WOW64_64KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_WRITE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_BINARY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_CREATED_NEW_KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_DWORD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_DWORD_BIG_ENDIAN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_DWORD_LITTLE_ENDIAN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_EXPAND_SZ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_FULL_RESOURCE_DESCRIPTOR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_LEGAL_CHANGE_FILTER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_LEGAL_OPTION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_LINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_MULTI_SZ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NONE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NOTIFY_CHANGE_ATTRIBUTES": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NOTIFY_CHANGE_LAST_SET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NOTIFY_CHANGE_NAME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NOTIFY_CHANGE_SECURITY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NO_LAZY_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPENED_EXISTING_KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_BACKUP_RESTORE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_CREATE_LINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_NON_VOLATILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_OPEN_LINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_RESERVED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_VOLATILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_QWORD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_QWORD_LITTLE_ENDIAN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_REFRESH_HIVE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_RESOURCE_LIST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_RESOURCE_REQUIREMENTS_LIST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_SZ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_WHOLE_HIVE_VOLATILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "EX_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "F_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_APPEND": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_BINARY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_CREAT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_EXCL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_NOINHERIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_RANDOM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_RDONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_RDWR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_SEQUENTIAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_SHORT_LIVED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_TEMPORARY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_TEXT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_TRUNC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_WRONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_DETACH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_NOWAIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_NOWAITO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_OVERLAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_WAIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "R_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "TMP_MAX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tempfile"
    },
    "W_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "X_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "environ": {
      "doc": "",
      "type": "_Environ",
      "module": "os"
    },
    "altzone": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "time"
    },
    "daylight": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "time"
    },
    "timezone": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "time"
    },
    "tzname": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "time"
    },
    "END_CENTRAL_DIR_SIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipimport"
    },
    "MAX_COMMENT_LEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipimport"
    },
    "STRING_END_ARCHIVE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipimport"
    },
    "alt_path_sep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zipimport"
    },
    "cp437_table": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zipimport"
    },
    "marshal": {
      "doc": "This module contains functions that can read and write Python values in",
      "type": "module",
      "module": "importlib._bootstrap_external"
    },
    "path_sep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "importlib._bootstrap_external"
    },
    "sys": {
      "doc": "This module provides access to some objects used or maintained by the",
      "type": "module",
      "module": "pkgutil"
    },
    "time": {
      "doc": "This module provides various functions to manipulate time values.",
      "type": "module",
      "module": "euddraft"
    },
    "DEFLATED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "DEF_BUF_SIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "DEF_MEM_LEVEL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "MAX_WBITS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "ZLIB_RUNTIME_VERSION": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zlib"
    },
    "ZLIB_VERSION": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zlib"
    },
    "Z_BEST_COMPRESSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_BEST_SPEED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_BLOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_DEFAULT_COMPRESSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_DEFAULT_STRATEGY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_FILTERED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_FINISH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_FIXED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_FULL_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_HUFFMAN_ONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_NO_COMPRESSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_NO_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_PARTIAL_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_RLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_SYNC_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_TREES": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "BOM": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM32_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM32_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM64_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM64_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF16": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF16_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF16_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF32": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF32_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF32_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF8": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "tokenize"
    },
    "builtins": {
      "doc": "Built-in functions, types, exceptions, and other objects.",
      "type": "module",
      "module": "eudplib"
    },
    "aliases": {
      "doc": "",
      "type": "module",
      "module": "encodings"
    },
    "codecs": {
      "doc": " codecs -- Python Codec Registry, API and helpers.",
      "type": "module",
      "module": "json"
    },
    "cp1252": {
      "doc": "",
      "type": "module",
      "module": "encodings"
    },
    "cp949": {
      "doc": "",
      "type": "module",
      "module": "encodings"
    },
    "utf_8": {
      "doc": "",
      "type": "module",
      "module": "encodings"
    },
    "decoding_table": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "encodings.cp1252"
    },
    "encoding_table": {
      "doc": "",
      "type": "EncodingMap",
      "module": "encodings.cp1252"
    },
    "DEFAULT_BUFFER_SIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "io"
    },
    "SEEK_CUR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "SEEK_END": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "SEEK_SET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "abc": {
      "doc": "Abstract Base Classes (ABCs) according to PEP 3119.",
      "type": "module",
      "module": "email._policybase"
    },
    "FILE_ATTRIBUTE_ARCHIVE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_COMPRESSED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_DEVICE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_DIRECTORY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_ENCRYPTED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_HIDDEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_INTEGRITY_STREAM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_NORMAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_NOT_CONTENT_INDEXED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_NO_SCRUB_DATA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_OFFLINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_READONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_REPARSE_POINT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_SPARSE_FILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_SYSTEM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_TEMPORARY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_VIRTUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "IO_REPARSE_TAG_APPEXECLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "IO_REPARSE_TAG_MOUNT_POINT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "IO_REPARSE_TAG_SYMLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_APPEND": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_ARCHIVED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_IMMUTABLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_NOUNLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_SNAPSHOT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_ATIME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_CTIME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_DEV": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_GID": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_INO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_MODE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_MTIME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_NLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_SIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_UID": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_ENFMT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IEXEC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFBLK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFCHR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFDIR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFDOOR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFIFO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFLNK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFREG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFSOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFWHT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IREAD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRGRP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IROTH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRUSR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRWXG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRWXO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRWXU": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_ISGID": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_ISUID": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_ISVTX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IWGRP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IWOTH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IWRITE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IWUSR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IXGRP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IXOTH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IXUSR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_APPEND": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_COMPRESSED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_HIDDEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_IMMUTABLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_NODUMP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_NOUNLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_OPAQUE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "os": {
      "doc": "OS routines for NT or Posix depending on what system we're on.",
      "type": "module",
      "module": "pkgutil"
    },
    "stat": {
      "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().",
      "type": "module",
      "module": "zipfile"
    },
    "altsep": {
      "doc": "",
      "type": "NoneType",
      "module": "posixpath"
    },
    "curdir": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "posixpath"
    },
    "defpath": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "posixpath"
    },
    "devnull": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "posixpath"
    },
    "extsep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "posixpath"
    },
    "genericpath": {
      "doc": "",
      "type": "module",
      "module": "posixpath"
    },
    "pardir": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "posixpath"
    },
    "pathsep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "posixpath"
    },
    "sep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "posixpath"
    },
    "supports_unicode_filenames": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "posixpath"
    },
    "linesep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "os"
    },
    "name": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "os"
    },
    "st": {
      "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().",
      "type": "module",
      "module": "os"
    },
    "supports_bytes_environ": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "os"
    },
    "supports_dir_fd": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "os"
    },
    "supports_effective_ids": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "os"
    },
    "supports_fd": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "os"
    },
    "supports_follow_symlinks": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "os"
    },
    "kwlist": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "keyword"
    },
    "softkwlist": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "keyword"
    },
    "aRepr": {
      "doc": "",
      "type": "Repr",
      "module": "reprlib"
    },
    "repr": {
      "doc": "",
      "type": "method",
      "module": "reprlib"
    },
    "WRAPPER_ASSIGNMENTS": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "functools"
    },
    "WRAPPER_UPDATES": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "functools"
    },
    "CONFORM": {
      "doc": "",
      "type": "FlagBoundary",
      "module": "enum"
    },
    "CONTINUOUS": {
      "doc": "An enumeration.",
      "type": "EnumCheck",
      "module": "enum"
    },
    "EJECT": {
      "doc": "",
      "type": "FlagBoundary",
      "module": "enum"
    },
    "KEEP": {
      "doc": "",
      "type": "FlagBoundary",
      "module": "enum"
    },
    "NAMED_FLAGS": {
      "doc": "An enumeration.",
      "type": "EnumCheck",
      "module": "enum"
    },
    "STRICT": {
      "doc": "",
      "type": "FlagBoundary",
      "module": "enum"
    },
    "UNIQUE": {
      "doc": "An enumeration.",
      "type": "EnumCheck",
      "module": "enum"
    },
    "bltns": {
      "doc": "Built-in functions, types, exceptions, and other objects.",
      "type": "module",
      "module": "enum"
    },
    "ANY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "ANY_ALL": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "ASSERT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "ASSERT_NOT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "AT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "ATCODES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "re._compiler"
    },
    "ATOMIC_GROUP": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "AT_BEGINNING": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "AT_BEGINNING_LINE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "AT_BEGINNING_STRING": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "AT_BOUNDARY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "AT_END": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "AT_END_LINE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "AT_END_STRING": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "AT_LOCALE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "re._compiler"
    },
    "AT_LOC_BOUNDARY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "AT_LOC_NON_BOUNDARY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "AT_MULTILINE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "re._compiler"
    },
    "AT_NON_BOUNDARY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "AT_UNICODE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "re._compiler"
    },
    "AT_UNI_BOUNDARY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "AT_UNI_NON_BOUNDARY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "BIGCHARSET": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "BRANCH": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_DIGIT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_LINEBREAK": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_LOC_NOT_WORD": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_LOC_WORD": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_NOT_DIGIT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_NOT_LINEBREAK": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_NOT_SPACE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_NOT_WORD": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_SPACE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_UNI_DIGIT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_UNI_LINEBREAK": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_UNI_NOT_DIGIT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_UNI_NOT_LINEBREAK": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_UNI_NOT_SPACE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_UNI_NOT_WORD": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_UNI_SPACE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_UNI_WORD": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CATEGORY_WORD": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CHARSET": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "CHCODES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "re._compiler"
    },
    "CH_LOCALE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "re._compiler"
    },
    "CH_UNICODE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "re._compiler"
    },
    "FAILURE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "GROUPREF": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "GROUPREF_EXISTS": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "GROUPREF_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "GROUPREF_LOC_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "GROUPREF_UNI_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "IN": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "INFO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "multiprocessing.util"
    },
    "IN_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "IN_LOC_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "IN_UNI_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "JUMP": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "LITERAL": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "LITERAL_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "LITERAL_LOC_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "LITERAL_UNI_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "MAGIC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "MARK": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "MAXGROUPS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "MAXREPEAT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "MAX_REPEAT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "MAX_UNTIL": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "MIN_REPEAT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "MIN_REPEAT_ONE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "MIN_UNTIL": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "NEGATE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "NOT_LITERAL": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "NOT_LITERAL_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "NOT_LITERAL_LOC_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "NOT_LITERAL_UNI_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "OPCODES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "re._compiler"
    },
    "OP_IGNORE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "re._compiler"
    },
    "OP_LOCALE_IGNORE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "re._compiler"
    },
    "OP_UNICODE_IGNORE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "re._compiler"
    },
    "POSSESSIVE_REPEAT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "POSSESSIVE_REPEAT_ONE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "RANGE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "RANGE_UNI_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "REPEAT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "REPEAT_ONE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "SRE_FLAG_ASCII": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "SRE_FLAG_DEBUG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "SRE_FLAG_DOTALL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "SRE_FLAG_IGNORECASE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "SRE_FLAG_LOCALE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "SRE_FLAG_MULTILINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "SRE_FLAG_TEMPLATE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "SRE_FLAG_UNICODE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "SRE_FLAG_VERBOSE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "SRE_INFO_CHARSET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "SRE_INFO_LITERAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "SRE_INFO_PREFIX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "SUBPATTERN": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "SUCCESS": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "re._compiler"
    },
    "ASCIILETTERS": {
      "doc": "frozenset() -> empty frozenset object",
      "type": "frozenset",
      "module": "re._parser"
    },
    "CATEGORIES": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "re._parser"
    },
    "DIGITS": {
      "doc": "frozenset() -> empty frozenset object",
      "type": "frozenset",
      "module": "re._parser"
    },
    "ESCAPES": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "re._parser"
    },
    "FLAGS": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "json.decoder"
    },
    "GLOBAL_FLAGS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._parser"
    },
    "HEXDIGITS": {
      "doc": "frozenset() -> empty frozenset object",
      "type": "frozenset",
      "module": "re._parser"
    },
    "MAXWIDTH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._parser"
    },
    "OCTDIGITS": {
      "doc": "frozenset() -> empty frozenset object",
      "type": "frozenset",
      "module": "re._parser"
    },
    "REPEAT_CHARS": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "re._parser"
    },
    "SPECIAL_CHARS": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "re._parser"
    },
    "TYPE_FLAGS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._parser"
    },
    "WHITESPACE": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "json.decoder"
    },
    "MAXCODE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "re._compiler"
    },
    "dispatch_table": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "copy"
    },
    "A": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "ASCII": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "DEBUG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "multiprocessing.util"
    },
    "DOTALL": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "I": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "IGNORECASE": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "L": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "LOCALE": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "M": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "MULTILINE": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "NOFLAG": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "S": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "T": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.crypt"
    },
    "TEMPLATE": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "U": {
      "doc": "",
      "type": "TypeVar",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "UNICODE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "VERBOSE": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "X": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "copyreg": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing.reduction"
    },
    "enum": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata.offsetmap.memberkind"
    },
    "functools": {
      "doc": "",
      "type": "module",
      "module": "email._encoded_words"
    },
    "ascii_letters": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email._encoded_words"
    },
    "ascii_lowercase": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "string"
    },
    "ascii_uppercase": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "string"
    },
    "digits": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email._encoded_words"
    },
    "hexdigits": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.quoprimime"
    },
    "octdigits": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "string"
    },
    "printable": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "string"
    },
    "punctuation": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "string"
    },
    "whitespace": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "string"
    },
    "BYTECODE_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "DEBUG_BYTECODE_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "EXTENSION_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "MAGIC_NUMBER": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "importlib.util"
    },
    "OPTIMIZED_BYTECODE_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "SOURCE_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "path_sep_tuple": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "importlib._bootstrap_external"
    },
    "path_separators": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "importlib._bootstrap_external"
    },
    "winreg": {
      "doc": "This module provides access to the Windows registry API.",
      "type": "module",
      "module": "importlib._bootstrap_external"
    },
    "defaultaction": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "warnings"
    },
    "filters": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "warnings"
    },
    "onceregistry": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "warnings"
    },
    "machinery": {
      "doc": "The machinery of importlib: finders, loaders, hooks, etc.",
      "type": "module",
      "module": "importlib"
    },
    "util": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing.spawn"
    },
    "warnings": {
      "doc": "",
      "type": "module",
      "module": "pkgutil"
    },
    "BUILD_COPYRIGHT": {
      "doc": "",
      "type": "NoneType",
      "module": "BUILD_CONSTANTS"
    },
    "BUILD_HOST": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "BUILD_CONSTANTS"
    },
    "BUILD_RELEASE_STRING": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "BUILD_CONSTANTS"
    },
    "BUILD_TIMESTAMP": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "BUILD_CONSTANTS"
    },
    "SOURCE_TIMESTAMP": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "BUILD_CONSTANTS"
    },
    "TIMEOUT_MAX": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "threading"
    },
    "threading": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing.util"
    },
    "types": {
      "doc": "",
      "type": "module",
      "module": "main"
    },
    "CTRL_BREAK_EVENT": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "CTRL_C_EVENT": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "NSIG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "signal"
    },
    "SIGABRT": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "SIGBREAK": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "SIGFPE": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "SIGILL": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "SIGINT": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "SIGSEGV": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "SIGTERM": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "SIG_DFL": {
      "doc": "An enumeration.",
      "type": "Handlers",
      "module": "signal"
    },
    "SIG_IGN": {
      "doc": "An enumeration.",
      "type": "Handlers",
      "module": "signal"
    },
    "ORIGINAL_DIR": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "multiprocessing.process"
    },
    "itertools": {
      "doc": "Functional tools for creating and using iterators.",
      "type": "module",
      "module": "multiprocessing.util"
    },
    "signal": {
      "doc": "",
      "type": "module",
      "module": "subprocess"
    },
    "ADDITEMS": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "APPEND": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "APPENDS": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINBYTES": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINBYTES8": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINFLOAT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINGET": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BININT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BININT1": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BININT2": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINPERSID": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINPUT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINSTRING": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINUNICODE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINUNICODE8": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BUILD": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BYTEARRAY8": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "DEFAULT_PROTOCOL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pickle"
    },
    "DICT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "DUP": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "EMPTY_DICT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "EMPTY_LIST": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "EMPTY_SET": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "EMPTY_TUPLE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "EXT1": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "EXT2": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "EXT4": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "FALSE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "FLOAT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "FRAME": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "FROZENSET": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "GET": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "GLOBAL": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "HIGHEST_PROTOCOL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pickle"
    },
    "INST": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "INT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "LIST": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "LONG": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "LONG1": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "LONG4": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "LONG_BINGET": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "LONG_BINPUT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "MEMOIZE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "NEWFALSE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "NEWOBJ": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "NEWOBJ_EX": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "NEWTRUE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "NEXT_BUFFER": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "NONE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "OBJ": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "PERSID": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "POP": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "POP_MARK": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "PROTO": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "PUT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "PyStringMap": {
      "doc": "",
      "type": "NoneType",
      "module": "pickle"
    },
    "READONLY_BUFFER": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "REDUCE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "SETITEM": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "SETITEMS": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "SHORT_BINBYTES": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "SHORT_BINSTRING": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "SHORT_BINUNICODE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "STACK_GLOBAL": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "STOP": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "STRING": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "TRUE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "TUPLE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "TUPLE1": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "TUPLE2": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "TUPLE3": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "bytes_types": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "base64"
    },
    "compatible_formats": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "pickle"
    },
    "format_version": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "pickle"
    },
    "io": {
      "doc": "The io module provides the Python interfaces to stream handling. The",
      "type": "module",
      "module": "runpy"
    },
    "re": {
      "doc": "",
      "type": "module",
      "module": "json.encoder"
    },
    "e": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "math"
    },
    "inf": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "math"
    },
    "nan": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "math"
    },
    "pi": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "math"
    },
    "tau": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "math"
    },
    "EVENT_READ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "selectors"
    },
    "EVENT_WRITE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "selectors"
    },
    "math": {
      "doc": "This module provides access to the mathematical functions",
      "type": "module",
      "module": "eudplib.eudlib.mathf.lengthdir"
    },
    "select": {
      "doc": "This module supports asynchronous I/O on multiple file descriptors.",
      "type": "module",
      "module": "selectors"
    },
    "E2BIG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EACCES": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EADDRINUSE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EADDRNOTAVAIL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EAFNOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EAGAIN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EALREADY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EBADF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pathlib"
    },
    "EBADMSG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EBUSY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ECANCELED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ECHILD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ECONNABORTED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ECONNREFUSED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ECONNRESET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EDEADLK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EDEADLOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EDESTADDRREQ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EDOM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EDQUOT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EEXIST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EFAULT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EFBIG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EHOSTDOWN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EHOSTUNREACH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EIDRM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EILSEQ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EINPROGRESS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EINTR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EINVAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EIO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EISCONN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EISDIR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ELOOP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pathlib"
    },
    "EMFILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EMLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EMSGSIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENAMETOOLONG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENETDOWN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENETRESET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENETUNREACH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENFILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOBUFS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENODATA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENODEV": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pathlib"
    },
    "ENOEXEC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOLCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOMEM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOMSG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOPROTOOPT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOSPC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOSR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOSTR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOSYS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOTCONN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOTDIR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pathlib"
    },
    "ENOTEMPTY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOTRECOVERABLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOTSOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOTSUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOTTY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENXIO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EOPNOTSUPP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EOVERFLOW": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EOWNERDEAD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EPERM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EPFNOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EPIPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EPROTO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EPROTONOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EPROTOTYPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ERANGE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EREMOTE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EROFS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ESHUTDOWN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ESOCKTNOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ESPIPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ESRCH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ESTALE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ETIME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ETIMEDOUT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ETOOMANYREFS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ETXTBSY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EUSERS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EWOULDBLOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EXDEV": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSABASEERR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEACCES": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEADDRINUSE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEADDRNOTAVAIL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEAFNOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEALREADY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEBADF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAECONNABORTED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAECONNREFUSED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAECONNRESET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEDESTADDRREQ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEDISCON": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEDQUOT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEFAULT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEHOSTDOWN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEHOSTUNREACH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEINPROGRESS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEINTR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEINVAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEISCONN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAELOOP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEMFILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEMSGSIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENAMETOOLONG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENETDOWN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENETRESET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENETUNREACH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENOBUFS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENOPROTOOPT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENOTCONN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENOTEMPTY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENOTSOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEOPNOTSUPP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEPFNOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEPROCLIM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEPROTONOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEPROTOTYPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEREMOTE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAESHUTDOWN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAESOCKTNOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAESTALE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAETIMEDOUT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAETOOMANYREFS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEUSERS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEWOULDBLOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSANOTINITIALISED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSASYSNOTREADY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAVERNOTSUPPORTED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "errorcode": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "errno"
    },
    "AF_APPLETALK": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_BLUETOOTH": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_DECnet": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "AF_INET": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_INET6": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_IPX": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_IRDA": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_LINK": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_SNA": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_UNSPEC": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AI_ADDRCONFIG": {
      "doc": "An enumeration.",
      "type": "AddressInfo",
      "module": "socket"
    },
    "AI_ALL": {
      "doc": "An enumeration.",
      "type": "AddressInfo",
      "module": "socket"
    },
    "AI_CANONNAME": {
      "doc": "An enumeration.",
      "type": "AddressInfo",
      "module": "socket"
    },
    "AI_NUMERICHOST": {
      "doc": "An enumeration.",
      "type": "AddressInfo",
      "module": "socket"
    },
    "AI_NUMERICSERV": {
      "doc": "An enumeration.",
      "type": "AddressInfo",
      "module": "socket"
    },
    "AI_PASSIVE": {
      "doc": "An enumeration.",
      "type": "AddressInfo",
      "module": "socket"
    },
    "AI_V4MAPPED": {
      "doc": "An enumeration.",
      "type": "AddressInfo",
      "module": "socket"
    },
    "BDADDR_ANY": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "socket"
    },
    "BDADDR_LOCAL": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "socket"
    },
    "BTPROTO_RFCOMM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "CAPI": {
      "doc": "Capsule objects let you wrap a C \"void *\" pointer in a Python",
      "type": "PyCapsule",
      "module": "socket"
    },
    "EAI_AGAIN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_BADFLAGS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_FAIL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_FAMILY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_MEMORY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_NODATA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_NONAME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_SERVICE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_SOCKTYPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "INADDR_ALLHOSTS_GROUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "INADDR_ANY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "INADDR_BROADCAST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "INADDR_LOOPBACK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "INADDR_MAX_LOCAL_GROUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "INADDR_NONE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "INADDR_UNSPEC_GROUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPORT_RESERVED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPORT_USERRESERVED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_AH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_CBT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_DSTOPTS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_EGP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_ESP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_FRAGMENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_GGP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_HOPOPTS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_ICLFXBM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_ICMP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_ICMPV6": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_IDP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_IGMP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_IGP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_IP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_IPV4": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_IPV6": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_L2TP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_MAX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_ND": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_NONE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_PGM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_PIM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_PUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_RAW": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_RDP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_ROUTING": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_SCTP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_ST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_TCP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_UDP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_CHECKSUM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_DONTFRAG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_HOPLIMIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_HOPOPTS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_JOIN_GROUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_LEAVE_GROUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_MULTICAST_HOPS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_MULTICAST_IF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_MULTICAST_LOOP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_PKTINFO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_RECVRTHDR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_RECVTCLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_RTHDR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_TCLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_UNICAST_HOPS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_V6ONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_ADD_MEMBERSHIP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_DROP_MEMBERSHIP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_HDRINCL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_MULTICAST_IF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_MULTICAST_LOOP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_MULTICAST_TTL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_OPTIONS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_RECVDSTADDR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_RECVTOS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_TOS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_TTL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "MSG_BCAST": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_CTRUNC": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_DONTROUTE": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_ERRQUEUE": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_MCAST": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_OOB": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_PEEK": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_TRUNC": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_WAITALL": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "NI_DGRAM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "NI_MAXHOST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "NI_MAXSERV": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "NI_NAMEREQD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "NI_NOFQDN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "NI_NUMERICHOST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "NI_NUMERICSERV": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "RCVALL_MAX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "RCVALL_OFF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "RCVALL_ON": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "RCVALL_SOCKETLEVELONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SHUT_RD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SHUT_RDWR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SHUT_WR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SIO_KEEPALIVE_VALS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SIO_LOOPBACK_FAST_PATH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SIO_RCVALL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SOCK_DGRAM": {
      "doc": "An enumeration.",
      "type": "SocketKind",
      "module": "socket"
    },
    "SOCK_RAW": {
      "doc": "An enumeration.",
      "type": "SocketKind",
      "module": "socket"
    },
    "SOCK_RDM": {
      "doc": "An enumeration.",
      "type": "SocketKind",
      "module": "socket"
    },
    "SOCK_SEQPACKET": {
      "doc": "An enumeration.",
      "type": "SocketKind",
      "module": "socket"
    },
    "SOCK_STREAM": {
      "doc": "An enumeration.",
      "type": "SocketKind",
      "module": "ssl"
    },
    "SOL_IP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SOL_SOCKET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ssl"
    },
    "SOL_TCP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SOL_UDP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SOMAXCONN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_ACCEPTCONN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_BROADCAST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_DEBUG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_DONTROUTE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_ERROR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_EXCLUSIVEADDRUSE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_KEEPALIVE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_LINGER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_OOBINLINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_RCVBUF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_RCVLOWAT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_RCVTIMEO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_REUSEADDR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_SNDBUF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_SNDLOWAT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_SNDTIMEO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_TYPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ssl"
    },
    "SO_USELOOPBACK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "TCP_FASTOPEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "TCP_KEEPCNT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "TCP_KEEPIDLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "TCP_KEEPINTVL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "TCP_MAXSEG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "TCP_NODELAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "errno": {
      "doc": "This module makes available standard errno system symbols.",
      "type": "module",
      "module": "http.client"
    },
    "errorTab": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "socket"
    },
    "has_ipv6": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "socket"
    },
    "selectors": {
      "doc": "",
      "type": "module",
      "module": "socket"
    },
    "HAVE_SEND_HANDLE": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "multiprocessing.reduction"
    },
    "context": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing"
    },
    "pickle": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing.reduction"
    },
    "register": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing.reduction"
    },
    "socket": {
      "doc": "",
      "type": "module",
      "module": "urllib.request"
    },
    "process": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing.spawn"
    },
    "reduction": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing.spawn"
    },
    "Array": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "Barrier": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "BoundedSemaphore": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "Condition": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "Event": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "JoinableQueue": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "Lock": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "Manager": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "Pipe": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "Pool": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "Queue": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "RLock": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "RawArray": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "RawValue": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "SUBDEBUG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "multiprocessing.util"
    },
    "SUBWARNING": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "multiprocessing.util"
    },
    "Semaphore": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "SimpleQueue": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "Value": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "allow_connection_pickling": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "cpu_count": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "freeze_support": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "get_all_start_methods": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "get_context": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "get_logger": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "get_start_method": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing.spawn"
    },
    "log_to_stderr": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "reducer": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing"
    },
    "set_executable": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "set_forkserver_preload": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "set_start_method": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing.spawn"
    },
    "spawn": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing"
    },
    "Match": {
      "doc": "A generic version of re.Match.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Pattern": {
      "doc": "A generic version of re.Pattern.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "AbstractSet": {
      "doc": "A generic version of collections.abc.Set.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "AnyStr": {
      "doc": "",
      "type": "TypeVar",
      "module": "typing_extensions"
    },
    "AsyncContextManager": {
      "doc": "A generic version of contextlib.AbstractAsyncContextManager.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "AsyncGenerator": {
      "doc": "A generic version of collections.abc.AsyncGenerator.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "AsyncIterable": {
      "doc": "A generic version of collections.abc.AsyncIterable.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "AsyncIterator": {
      "doc": "A generic version of collections.abc.AsyncIterator.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Awaitable": {
      "doc": "A generic version of collections.abc.Awaitable.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "ByteString": {
      "doc": "A generic version of collections.abc.ByteString.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "CT_co": {
      "doc": "",
      "type": "TypeVar",
      "module": "typing"
    },
    "Callable": {
      "doc": "Deprecated alias to collections.abc.Callable.",
      "type": "_CallableType",
      "module": "typing_extensions"
    },
    "ChainMap": {
      "doc": "A generic version of collections.ChainMap.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "ClassVar": {
      "doc": "",
      "type": "_SpecialForm",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "Collection": {
      "doc": "A generic version of collections.abc.Collection.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Concatenate": {
      "doc": "",
      "type": "_SpecialForm",
      "module": "typing_extensions"
    },
    "Container": {
      "doc": "A generic version of collections.abc.Container.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "ContextManager": {
      "doc": "A generic version of contextlib.AbstractContextManager.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Coroutine": {
      "doc": "A generic version of collections.abc.Coroutine.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Counter": {
      "doc": "A generic version of collections.Counter.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "DefaultDict": {
      "doc": "A generic version of collections.defaultdict.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Deque": {
      "doc": "A generic version of collections.deque.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Dict": {
      "doc": "A generic version of dict.",
      "type": "_SpecialGenericAlias",
      "module": "readconfig"
    },
    "EXCLUDED_ATTRIBUTES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "typing"
    },
    "Final": {
      "doc": "",
      "type": "_SpecialForm",
      "module": "eudplib.scdata.offsetmap.enummember"
    },
    "FrozenSet": {
      "doc": "A generic version of frozenset.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Generator": {
      "doc": "A generic version of collections.abc.Generator.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Hashable": {
      "doc": "A generic version of collections.abc.Hashable.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "ItemsView": {
      "doc": "A generic version of collections.abc.ItemsView.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Iterable": {
      "doc": "A generic version of collections.abc.Iterable.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Iterator": {
      "doc": "A generic version of collections.abc.Iterator.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "KT": {
      "doc": "",
      "type": "TypeVar",
      "module": "typing_extensions"
    },
    "KeysView": {
      "doc": "A generic version of collections.abc.KeysView.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "List": {
      "doc": "A generic version of list.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Literal": {
      "doc": "",
      "type": "_LiteralSpecialForm",
      "module": "eudplib.eudlib.locf.locf"
    },
    "LiteralString": {
      "doc": "",
      "type": "_SpecialForm",
      "module": "typing_extensions"
    },
    "Mapping": {
      "doc": "A generic version of collections.abc.Mapping.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "MappingView": {
      "doc": "A generic version of collections.abc.MappingView.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "MutableMapping": {
      "doc": "A generic version of collections.abc.MutableMapping.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "MutableSequence": {
      "doc": "A generic version of collections.abc.MutableSequence.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "MutableSet": {
      "doc": "A generic version of collections.abc.MutableSet.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Never": {
      "doc": "",
      "type": "_SpecialForm",
      "module": "typing_extensions"
    },
    "NoReturn": {
      "doc": "",
      "type": "_SpecialForm",
      "module": "eudplib.scdata.offsetmap.member"
    },
    "NotRequired": {
      "doc": "",
      "type": "_SpecialForm",
      "module": "typing_extensions"
    },
    "Optional": {
      "doc": "",
      "type": "_SpecialForm",
      "module": "typing_extensions"
    },
    "OrderedDict": {
      "doc": "A generic version of collections.OrderedDict.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Required": {
      "doc": "",
      "type": "_SpecialForm",
      "module": "typing_extensions"
    },
    "Reversible": {
      "doc": "A generic version of collections.abc.Reversible.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Self": {
      "doc": "",
      "type": "_SpecialForm",
      "module": "eudplib.collections.objpool"
    },
    "Sequence": {
      "doc": "A generic version of collections.abc.Sequence.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "Set": {
      "doc": "",
      "type": "_Set",
      "module": "freeze.freeze"
    },
    "Sized": {
      "doc": "A generic version of collections.abc.Sized.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "TYPE_CHECKING": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "eudplib.trigtrg.runtrigtrg"
    },
    "T_co": {
      "doc": "",
      "type": "TypeVar",
      "module": "typing_extensions"
    },
    "T_contra": {
      "doc": "",
      "type": "TypeVar",
      "module": "typing_extensions"
    },
    "Tuple": {
      "doc": "Deprecated alias to builtins.tuple.",
      "type": "_TupleType",
      "module": "typing_extensions"
    },
    "Type": {
      "doc": "Deprecated alias to builtins.type.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "TypeAlias": {
      "doc": "",
      "type": "_SpecialForm",
      "module": "eudplib.maprw.inlinecode.btinliner"
    },
    "TypeGuard": {
      "doc": "",
      "type": "_SpecialForm",
      "module": "eudplib.core.variable.eudv"
    },
    "Union": {
      "doc": "",
      "type": "_SpecialForm",
      "module": "typing_extensions"
    },
    "Unpack": {
      "doc": "Type unpack operator.",
      "type": "_UnpackSpecialForm",
      "module": "typing_extensions"
    },
    "VT": {
      "doc": "",
      "type": "TypeVar",
      "module": "typing_extensions"
    },
    "VT_co": {
      "doc": "",
      "type": "TypeVar",
      "module": "typing"
    },
    "V_co": {
      "doc": "",
      "type": "TypeVar",
      "module": "typing"
    },
    "ValuesView": {
      "doc": "A generic version of collections.abc.ValuesView.",
      "type": "_SpecialGenericAlias",
      "module": "typing_extensions"
    },
    "collections": {
      "doc": "",
      "type": "module",
      "module": "http.client"
    },
    "contextlib": {
      "doc": "",
      "type": "module",
      "module": "urllib.request"
    },
    "operator": {
      "doc": "Operator interface.",
      "type": "module",
      "module": "typing_extensions"
    },
    "stdlib_re": {
      "doc": "",
      "type": "module",
      "module": "typing"
    },
    "allocator": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "epscript": {
      "doc": "",
      "type": "module",
      "module": "eudplib"
    },
    "eudobj": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "mpqapi": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.savemap"
    },
    "CHAR_MAX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "locale"
    },
    "LC_ALL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "locale"
    },
    "LC_COLLATE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "locale"
    },
    "LC_CTYPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "locale"
    },
    "LC_MONETARY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "locale"
    },
    "LC_NUMERIC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "locale"
    },
    "LC_TIME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "locale"
    },
    "encodings": {
      "doc": "",
      "type": "module",
      "module": "locale"
    },
    "locale_alias": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "locale"
    },
    "locale_encoding_alias": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "locale"
    },
    "windows_locale": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "locale"
    },
    "gettext": {
      "doc": "",
      "type": "module",
      "module": "eudplib.localize"
    },
    "lang": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "eudplib.localize"
    },
    "lc": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.localize"
    },
    "locale": {
      "doc": "",
      "type": "module",
      "module": "subprocess"
    },
    "locale_path": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.localize"
    },
    "t": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.inlinecode.ilccompile"
    },
    "block": {
      "doc": "Built-in immutable sequence.",
      "type": "GenericAlias",
      "module": "eudplib.utils.blockstru"
    },
    "BPF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "random"
    },
    "LOG4": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "random"
    },
    "NV_MAGICCONST": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "random"
    },
    "RECIP_BPF": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "random"
    },
    "SG_MAGICCONST": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "random"
    },
    "TWOPI": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "random"
    },
    "betavariate": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "choice": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "choices": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "expovariate": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "gammavariate": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "gauss": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "getstate": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "lognormvariate": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "normalvariate": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "paretovariate": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "randbytes": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "randint": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "randrange": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "sample": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "seed": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "setstate": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "shuffle": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "triangular": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "uniform": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "vonmisesvariate": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "weibullvariate": {
      "doc": "",
      "type": "method",
      "module": "random"
    },
    "BytesPath": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.utils.etc"
    },
    "StrPath": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.utils.etc"
    },
    "c": {
      "doc": "",
      "type": "module",
      "module": "eudplib.collections.objpool"
    },
    "random": {
      "doc": "",
      "type": "module",
      "module": "freeze.freeze"
    },
    "g_encoding": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.utils.ubconv"
    },
    "binio": {
      "doc": "",
      "type": "module",
      "module": "eudplib.utils"
    },
    "blockstru": {
      "doc": "",
      "type": "module",
      "module": "eudplib.utils"
    },
    "eperror": {
      "doc": "",
      "type": "module",
      "module": "eudplib.utils"
    },
    "etc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.utils"
    },
    "exprproxy": {
      "doc": "",
      "type": "module",
      "module": "eudplib.utils"
    },
    "ubconv": {
      "doc": "",
      "type": "module",
      "module": "eudplib.utils"
    },
    "al": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.allocator.constexpr"
    },
    "Evaluable": {
      "doc": "",
      "type": "_UnionGenericAlias",
      "module": "eudplib.core.allocator.payload"
    },
    "PHASE_ALLOCATING": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.core.allocator.payload"
    },
    "PHASE_COLLECTING": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.core.allocator.payload"
    },
    "PHASE_WRITING": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.core.allocator.payload"
    },
    "annotations": {
      "doc": "",
      "type": "_Feature",
      "module": "eudplib.trigtrg.runtrigtrg"
    },
    "defri": {
      "doc": "Relocatable int",
      "type": "RlocInt_C",
      "module": "eudplib.core.allocator.payload"
    },
    "phase": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.core.allocator.payload"
    },
    "constexpr": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.allocator"
    },
    "payload": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.allocator"
    },
    "pbuffer": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.allocator"
    },
    "rlocint": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.allocator"
    },
    "PyCF_ALLOW_TOP_LEVEL_AWAIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ast"
    },
    "PyCF_ONLY_AST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ast"
    },
    "PyCF_TYPE_COMMENTS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ast"
    },
    "EXTENDED_ARG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "dis"
    },
    "HAVE_ARGUMENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "dis"
    },
    "cmp_op": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "dis"
    },
    "hascompare": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "hasconst": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "hasfree": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "hasjabs": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "hasjrel": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "haslocal": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "hasname": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "hasnargs": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "opmap": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "dis"
    },
    "opname": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "BINARY_OP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "dis"
    },
    "CACHE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "dis"
    },
    "COMPILER_FLAG_NAMES": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "dis"
    },
    "FORMAT_VALUE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "dis"
    },
    "FORMAT_VALUE_CONVERTERS": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "dis"
    },
    "JUMP_BACKWARD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "dis"
    },
    "LOAD_CONST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "dis"
    },
    "LOAD_GLOBAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "dis"
    },
    "MAKE_FUNCTION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "dis"
    },
    "MAKE_FUNCTION_FLAGS": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "dis"
    },
    "UNKNOWN": {
      "doc": "",
      "type": "_Unknown",
      "module": "dis"
    },
    "deoptmap": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "dis"
    },
    "spec_op": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "dis"
    },
    "specialized": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio"
    },
    "AMPER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "AMPEREQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "ASYNC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "ATEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "AWAIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "CIRCUMFLEX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "CIRCUMFLEXEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "COLON": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "COLONEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "COMMA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "COMMENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "DEDENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "DOT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "DOUBLESLASH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "DOUBLESLASHEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "DOUBLESTAR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "DOUBLESTAREQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "ELLIPSIS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "ENCODING": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "ENDMARKER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "EQEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "EQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "ERRORTOKEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "EXACT_TOKEN_TYPES": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "tokenize"
    },
    "GREATER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "GREATEREQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "INDENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "LBRACE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "LEFTSHIFT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "LEFTSHIFTEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "LESS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "LESSEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "LPAR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "LSQB": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "MINEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "MINUS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "NAME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "NEWLINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "NL": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.feedparser"
    },
    "NOTEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "NT_OFFSET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "NUMBER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "N_TOKENS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "OP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "PERCENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "PERCENTEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "PLUS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "PLUSEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "RARROW": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "RBRACE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "RIGHTSHIFT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "RIGHTSHIFTEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "RPAR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "RSQB": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "SEMI": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "SLASH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "SLASHEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "SOFT_KEYWORD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "STAR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "STAREQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "TILDE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "TYPE_COMMENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "TYPE_IGNORE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "VBAR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "VBAREQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "tok_name": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "tokenize"
    },
    "Binnumber": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Comment": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "ContStr": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Decnumber": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Double": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Double3": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Expfloat": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Exponent": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Floatnumber": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Funny": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Hexnumber": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Ignore": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Imagnumber": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Intnumber": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Name": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Number": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Octnumber": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "PlainToken": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Pointfloat": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "PseudoExtras": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "PseudoToken": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Single": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Single3": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Special": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "String": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "StringPrefix": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Token": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Triple": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Whitespace": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "blank_re": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "tokenize"
    },
    "cookie_re": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "tokenize"
    },
    "endpats": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "tokenize"
    },
    "single_quoted": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "tokenize"
    },
    "tabsize": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "triple_quoted": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "tokenize"
    },
    "cache": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "linecache"
    },
    "tokenize": {
      "doc": "",
      "type": "module",
      "module": "inspect"
    },
    "CORO_CLOSED": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "CORO_CREATED": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "CORO_RUNNING": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "CORO_SUSPENDED": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "CO_ASYNC_GENERATOR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_COROUTINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_GENERATOR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_ITERABLE_COROUTINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_NESTED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_NEWLOCALS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_NOFREE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_OPTIMIZED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_VARARGS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_VARKEYWORDS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "GEN_CLOSED": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "GEN_CREATED": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "GEN_RUNNING": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "GEN_SUSPENDED": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "TPFLAGS_IS_ABSTRACT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "ast": {
      "doc": "",
      "type": "module",
      "module": "inspect"
    },
    "dis": {
      "doc": "",
      "type": "module",
      "module": "main"
    },
    "importlib": {
      "doc": "",
      "type": "module",
      "module": "pkgutil"
    },
    "linecache": {
      "doc": "",
      "type": "module",
      "module": "traceback"
    },
    "modulesbyfile": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "inspect"
    },
    "token": {
      "doc": "",
      "type": "module",
      "module": "inspect"
    },
    "NoDefault": {
      "doc": "",
      "type": "NoDefaultType",
      "module": "typing_extensions"
    },
    "PEP_560": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "typing_extensions"
    },
    "ReadOnly": {
      "doc": "",
      "type": "_ExtensionsSpecialForm",
      "module": "typing_extensions"
    },
    "TypeIs": {
      "doc": "",
      "type": "_ExtensionsSpecialForm",
      "module": "typing_extensions"
    },
    "inspect": {
      "doc": "",
      "type": "module",
      "module": "main"
    },
    "typing": {
      "doc": "",
      "type": "module",
      "module": "typing_extensions"
    },
    "Byte": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.rawtrigger.stockact"
    },
    "Dword": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.rawtrigger.stockcond"
    },
    "Word": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "ut": {
      "doc": "",
      "type": "module",
      "module": "eudplib.collections.objpool"
    },
    "DEFAULT_MODE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ctypes"
    },
    "GetLastError": {
      "doc": "",
      "type": "_FuncPtr",
      "module": "ctypes"
    },
    "RTLD_GLOBAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ctypes"
    },
    "RTLD_LOCAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ctypes"
    },
    "cdll": {
      "doc": "",
      "type": "LibraryLoader",
      "module": "ctypes"
    },
    "memmove": {
      "doc": "",
      "type": "CFunctionType",
      "module": "ctypes"
    },
    "memset": {
      "doc": "",
      "type": "CFunctionType",
      "module": "ctypes"
    },
    "oledll": {
      "doc": "",
      "type": "LibraryLoader",
      "module": "ctypes"
    },
    "pydll": {
      "doc": "",
      "type": "LibraryLoader",
      "module": "ctypes"
    },
    "pythonapi": {
      "doc": "",
      "type": "PyDLL",
      "module": "ctypes"
    },
    "windll": {
      "doc": "",
      "type": "LibraryLoader",
      "module": "msgbox"
    },
    "wintypes": {
      "doc": "",
      "type": "module",
      "module": "ctypes"
    },
    "unit_name_encoding": {
      "doc": "",
      "type": "NoneType",
      "module": "eudplib.core.mapdata.tblformat"
    },
    "locmap": {
      "doc": "",
      "type": "StringIdMap",
      "module": "eudplib.core.mapdata.stringmap"
    },
    "strmap": {
      "doc": "",
      "type": "TBL",
      "module": "eudplib.core.mapdata.stringmap"
    },
    "strsection": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.mapdata.stringmap"
    },
    "swmap": {
      "doc": "",
      "type": "StringIdMap",
      "module": "eudplib.core.mapdata.stringmap"
    },
    "unitmap": {
      "doc": "",
      "type": "StringIdMap",
      "module": "eudplib.core.mapdata.stringmap"
    },
    "chktok": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.loadmap"
    },
    "fixmapdata": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.savemap"
    },
    "mapdata": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.savemap"
    },
    "playerinfo": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.mapdata"
    },
    "proptable": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.mapdata"
    },
    "stringmap": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.mapdata"
    },
    "tblformat": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.mapdata"
    },
    "unitprp": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.mapdata"
    },
    "Add": {
      "doc": "",
      "type": "TrgModifier",
      "module": "freeze.freeze"
    },
    "All": {
      "doc": "",
      "type": "TrgCount",
      "module": "freeze.freeze"
    },
    "AlliedVictory": {
      "doc": "",
      "type": "TrgAllyStatus",
      "module": "freeze.freeze"
    },
    "Ally": {
      "doc": "",
      "type": "TrgAllyStatus",
      "module": "freeze.freeze"
    },
    "AllyStatus": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "AllyStatusDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "AtLeast": {
      "doc": "",
      "type": "TrgComparison",
      "module": "freeze.freeze"
    },
    "AtMost": {
      "doc": "",
      "type": "TrgComparison",
      "module": "freeze.freeze"
    },
    "Attack": {
      "doc": "",
      "type": "TrgOrder",
      "module": "freeze.freeze"
    },
    "Buildings": {
      "doc": "",
      "type": "TrgScore",
      "module": "freeze.freeze"
    },
    "Clear": {
      "doc": "",
      "type": "TrgSwitchAction",
      "module": "freeze.freeze"
    },
    "Cleared": {
      "doc": "",
      "type": "TrgSwitchState",
      "module": "freeze.freeze"
    },
    "Comparison": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "ComparisonDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "Count": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Custom": {
      "doc": "",
      "type": "TrgScore",
      "module": "freeze.freeze"
    },
    "Disable": {
      "doc": "",
      "type": "TrgPropState",
      "module": "freeze.freeze"
    },
    "Enable": {
      "doc": "",
      "type": "TrgPropState",
      "module": "freeze.freeze"
    },
    "Enemy": {
      "doc": "",
      "type": "TrgAllyStatus",
      "module": "freeze.freeze"
    },
    "Exactly": {
      "doc": "",
      "type": "TrgComparison",
      "module": "freeze.freeze"
    },
    "Gas": {
      "doc": "",
      "type": "TrgResource",
      "module": "freeze.freeze"
    },
    "Kills": {
      "doc": "",
      "type": "_Kills",
      "module": "freeze.freeze"
    },
    "KillsAndRazings": {
      "doc": "",
      "type": "TrgScore",
      "module": "freeze.freeze"
    },
    "Modifier": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "ModifierDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "Move": {
      "doc": "",
      "type": "TrgOrder",
      "module": "freeze.freeze"
    },
    "Order": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "OrderDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "Ore": {
      "doc": "",
      "type": "TrgResource",
      "module": "freeze.freeze"
    },
    "OreAndGas": {
      "doc": "",
      "type": "TrgResource",
      "module": "freeze.freeze"
    },
    "Patrol": {
      "doc": "",
      "type": "TrgOrder",
      "module": "freeze.freeze"
    },
    "Player": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "PlayerDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.scdata.player"
    },
    "PropState": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "PropStateDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "Random": {
      "doc": "",
      "type": "TrgSwitchAction",
      "module": "freeze.freeze"
    },
    "Razings": {
      "doc": "",
      "type": "TrgScore",
      "module": "freeze.freeze"
    },
    "Resource": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "ResourceDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "Score": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.rawtrigger.stockact"
    },
    "ScoreDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "SetTo": {
      "doc": "",
      "type": "TrgModifier",
      "module": "freeze.freeze"
    },
    "Subtract": {
      "doc": "",
      "type": "TrgModifier",
      "module": "freeze.freeze"
    },
    "SwitchAction": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "SwitchActionDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "SwitchState": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "SwitchStateDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "Toggle": {
      "doc": "",
      "type": "_Toggle",
      "module": "freeze.freeze"
    },
    "Total": {
      "doc": "",
      "type": "TrgScore",
      "module": "freeze.freeze"
    },
    "Units": {
      "doc": "",
      "type": "TrgScore",
      "module": "freeze.freeze"
    },
    "UnitsAndBuildings": {
      "doc": "",
      "type": "TrgScore",
      "module": "freeze.freeze"
    },
    "ev": {
      "doc": "",
      "type": "module",
      "module": "eudplib.collections.objpool"
    },
    "bytedump": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudobj"
    },
    "Trigger": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.core.rawtrigger.rawtriggerdef"
    },
    "alc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.rawtriggerdef"
    },
    "struct": {
      "doc": "Functions to convert between Python values and C structs.",
      "type": "module",
      "module": "base64"
    },
    "DefFlingyDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefIconDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefImageDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefIscriptDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefPortraitDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefSfxDataDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "DefSpriteDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefRankDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.scdata.offsetmap.memberimpl"
    },
    "DefStatTextDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefTechDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefAIScriptDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefLocationDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefSwitchDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefUnitDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefUnitOrderDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefUpgradeDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefWeaponDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "flingy": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata"
    },
    "icon": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "image": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata"
    },
    "iscript": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "portrait": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "sfxdata": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "sprite": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata"
    },
    "stattxt": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "tech": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata"
    },
    "trg": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "unitorder": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata"
    },
    "upgrade": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata"
    },
    "weapon": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata"
    },
    "AIScript": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Location": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Switch": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.rawtrigger.stockact"
    },
    "Unit": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "difflib": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "action": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger"
    },
    "condition": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger"
    },
    "constenc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger"
    },
    "consttype": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger"
    },
    "rawtriggerdef": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger"
    },
    "stockact": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger"
    },
    "stockcond": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger"
    },
    "strdict": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger"
    },
    "strenc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger"
    },
    "triggerscope": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger"
    },
    "bt": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudstruct.vararray"
    },
    "textwrap": {
      "doc": "",
      "type": "module",
      "module": "traceback"
    },
    "traceback": {
      "doc": "",
      "type": "module",
      "module": "applyeuddraft"
    },
    "eudlv": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.variable"
    },
    "eudv": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.variable"
    },
    "eudxv": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.variable"
    },
    "evcommon": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.variable"
    },
    "vbase": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.variable"
    },
    "vbuf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.variable"
    },
    "tracecrypt": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudfunc.trace.tracetool"
    },
    "tracetool": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudfunc.trace"
    },
    "i_header": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "eudplib.core.eudfunc.trace.tracetool"
    },
    "trace_header": {
      "doc": "",
      "type": "NoneType",
      "module": "eudplib.maprw.savemap"
    },
    "trace_map": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.maprw.savemap"
    },
    "ac": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudfunc.eudfptr"
    },
    "cpcache": {
      "doc": "",
      "type": "EUDXVariable",
      "module": "eudplib.memio.memifgen"
    },
    "i": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.string.strcommon"
    },
    "eudstruct": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "structarr": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudstruct"
    },
    "vararray": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudstruct"
    },
    "eudf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudfunc"
    },
    "eudfmethod": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudfunc"
    },
    "eudfptr": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudfunc"
    },
    "eudfuncn": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudfunc"
    },
    "eudtypedfuncn": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudfunc"
    },
    "trace": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudfunc"
    },
    "rt": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudfunc.eudfptr"
    },
    "f_bitsplit": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "bitwise": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.calcf"
    },
    "muldiv": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.calcf"
    },
    "calcf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "curpl": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "eudfunc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "inlinens": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "inplacecw": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "rawtrigger": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "variable": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "Constant": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigger.filler"
    },
    "ConstCondition": {
      "doc": "",
      "type": "_UnionGenericAlias",
      "module": "eudplib.trigger.tpatcher"
    },
    "actpt": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.trigger.tpatcher"
    },
    "condpt": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.trigger.tpatcher"
    },
    "Actions": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigger.ptrigger"
    },
    "Conditions": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigger.ptrigger"
    },
    "Players": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigger.ptrigger"
    },
    "branch": {
      "doc": "",
      "type": "module",
      "module": "eudplib.trigger"
    },
    "filler": {
      "doc": "",
      "type": "module",
      "module": "eudplib.trigger"
    },
    "ptrigger": {
      "doc": "",
      "type": "module",
      "module": "eudplib.trigger"
    },
    "tpatcher": {
      "doc": "",
      "type": "module",
      "module": "eudplib.trigger"
    },
    "triggerdef": {
      "doc": "",
      "type": "module",
      "module": "eudplib.trigger"
    },
    "tg": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru.shortcircuit"
    },
    "lb": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru.breakcont"
    },
    "sb": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru.breakcont"
    },
    "basicstru": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "breakcont": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "cshelper": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "jumptable": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "logic": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "loopblock": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "shortcircuit": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "simpleblock": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "swblock": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "cp": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf.listloop"
    },
    "CP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.memio.modcurpl"
    },
    "cpcond": {
      "doc": "Class for forward definition.",
      "type": "Forward",
      "module": "eudplib.memio.modcurpl"
    },
    "cs": {
      "doc": "",
      "type": "module",
      "module": "eudplib.collections.objpool"
    },
    "f_getcurpl": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "consecutive_table": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.memio.readtable"
    },
    "copy_ret": {
      "doc": "",
      "type": "Action",
      "module": "eudplib.memio.readtable"
    },
    "read_end_common": {
      "doc": "",
      "type": "RawTrigger",
      "module": "eudplib.memio.readtable"
    },
    "E": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.memio.dwepdio"
    },
    "f_dwbreak": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_dwbreak2": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_dwepdread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "readtable": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio"
    },
    "dwm": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio.ptrmemio"
    },
    "cpm": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio.ptrmemio"
    },
    "f_memcmp": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_repmovsd_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "bwm": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio.ptrmemio"
    },
    "f_cunitepdread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_cunitread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_epdcunitread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_epdspriteread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_spriteepdread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_spriteread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "bwepdio": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio"
    },
    "byterw": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio"
    },
    "cpbyterw": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio"
    },
    "cpmemio": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio"
    },
    "dwepdio": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio"
    },
    "mblockio": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio"
    },
    "memifgen": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio"
    },
    "modcurpl": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio"
    },
    "muldiv4table": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata.offsetmap.epdoffsetmap"
    },
    "ptrmemio": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio"
    },
    "rwcommon": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio"
    },
    "s": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio"
    },
    "varrayreader": {
      "doc": "",
      "type": "module",
      "module": "eudplib.memio"
    },
    "EUDDeque": {
      "doc": "",
      "type": "_lru_cache_wrapper",
      "module": "freeze.freeze"
    },
    "EUDQueue": {
      "doc": "",
      "type": "_lru_cache_wrapper",
      "module": "freeze.freeze"
    },
    "br1": {
      "doc": "",
      "type": "EUDByteReader",
      "module": "eudplib.string.texteffect"
    },
    "br2": {
      "doc": "",
      "type": "EUDByteReader",
      "module": "eudplib.string.strfunc"
    },
    "bs1": {
      "doc": "",
      "type": "EUDByteStream",
      "module": "eudplib.string.strfunc"
    },
    "bw1": {
      "doc": "",
      "type": "EUDByteWriter",
      "module": "eudplib.string.strfunc"
    },
    "cw": {
      "doc": "",
      "type": "CPByteWriter",
      "module": "eudplib.string.texteffect"
    },
    "lv": {
      "doc": "",
      "type": "EUDLightVariable",
      "module": "eudplib.eudlib.utilf.random"
    },
    "muldiv4_table": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.memio.muldiv4table"
    },
    "muldiv_end_table": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.memio.muldiv4table"
    },
    "varcount_dict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.memio.muldiv4table"
    },
    "enummember": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata.offsetmap"
    },
    "epdoffsetmap": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata.offsetmap"
    },
    "member": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata.offsetmap"
    },
    "memberimpl": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata.offsetmap"
    },
    "memberkind": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata.offsetmap"
    },
    "int_or_var": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.scdata.cunit"
    },
    "AllPlayers": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Allies": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "CurrentPlayer": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Foes": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Force1": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Force2": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Force3": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Force4": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "NeutralPlayers": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "NonAlliedVictoryPlayers": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "P1": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "P10": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "P11": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "P12": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "P2": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "P3": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "P4": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "P5": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "P6": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "P7": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "P8": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "P9": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Player1": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Player10": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Player11": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Player12": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Player2": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Player3": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Player4": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Player5": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Player6": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Player7": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Player8": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "Player9": {
      "doc": "",
      "type": "TrgPlayer",
      "module": "freeze.freeze"
    },
    "memio": {
      "doc": "",
      "type": "module",
      "module": "eudplib"
    },
    "csprite": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata"
    },
    "cunit": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata"
    },
    "offsetmap": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata"
    },
    "player": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.trigtrg.runtrigtrg"
    },
    "unit": {
      "doc": "",
      "type": "module",
      "module": "eudplib.scdata"
    },
    "eudarray": {
      "doc": "",
      "type": "module",
      "module": "eudplib.collections"
    },
    "eudqueue": {
      "doc": "",
      "type": "module",
      "module": "eudplib.collections"
    },
    "eudstack": {
      "doc": "",
      "type": "module",
      "module": "eudplib.collections"
    },
    "objpool": {
      "doc": "",
      "type": "module",
      "module": "eudplib.collections"
    },
    "playerv": {
      "doc": "",
      "type": "module",
      "module": "eudplib.collections"
    },
    "unitgroup": {
      "doc": "",
      "type": "module",
      "module": "eudplib.collections"
    },
    "locf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "atan2": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.mathf"
    },
    "div": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.mathf"
    },
    "lengthdir": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.mathf"
    },
    "pow": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.mathf"
    },
    "sqrt": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.mathf"
    },
    "f_atan2": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_atan2_256": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_lengthdir": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_lengthdir_256": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_sqrt": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "binsearch": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf"
    },
    "gametick": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf"
    },
    "listloop": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf"
    },
    "pexist": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf"
    },
    "unlimiterflag": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf"
    },
    "userpl": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf"
    },
    "f_getgametick": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "ProxyTypes": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "weakref"
    },
    "KW_ONLY": {
      "doc": "",
      "type": "_KW_ONLY_TYPE",
      "module": "dataclasses"
    },
    "MISSING": {
      "doc": "",
      "type": "_MISSING_TYPE",
      "module": "dataclasses"
    },
    "copy": {
      "doc": "",
      "type": "module",
      "module": "dataclasses"
    },
    "keyword": {
      "doc": "",
      "type": "module",
      "module": "eudplib"
    },
    "f_playerexist": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_dwrand": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_rand": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_randomize": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "wiredata": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.wireframe"
    },
    "wireframe": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "apply_injector": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector"
    },
    "inj_finalizer": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector"
    },
    "mainloop": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector"
    },
    "payload_init": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector"
    },
    "payload_reloc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector"
    },
    "vector_reloc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector"
    },
    "RunTrigTrigger": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "runtrigtrg": {
      "doc": "",
      "type": "module",
      "module": "eudplib.trigtrg"
    },
    "trigtrg": {
      "doc": "",
      "type": "module",
      "module": "eudplib"
    },
    "btinliner": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.inlinecode"
    },
    "ilccompile": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.inlinecode"
    },
    "ilcprocesstrig": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.inlinecode"
    },
    "t_start_end": {
      "doc": "Built-in immutable sequence.",
      "type": "GenericAlias",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "sf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.inlinecode.ilccompile"
    },
    "tt": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector.vector_reloc"
    },
    "mi": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector.inj_finalizer"
    },
    "rtt": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector.inj_finalizer"
    },
    "trglist": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.maprw.injector.vector_reloc"
    },
    "skip_payload_relocator": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "eudplib.maprw.injector.apply_injector"
    },
    "b": {
      "doc": "",
      "type": "EUDVariable",
      "module": "eudplib.string.strcommon"
    },
    "count": {
      "doc": "",
      "type": "EUDLightVariable",
      "module": "eudplib.string.strcommon"
    },
    "cp_cont": {
      "doc": "Class for forward definition.",
      "type": "Forward",
      "module": "eudplib.string.strcommon"
    },
    "cp_end": {
      "doc": "",
      "type": "RawTrigger",
      "module": "eudplib.string.strcommon"
    },
    "cp_start": {
      "doc": "",
      "type": "RawTrigger",
      "module": "eudplib.string.strcommon"
    },
    "dbstr_cont": {
      "doc": "Class for forward definition.",
      "type": "Forward",
      "module": "eudplib.string.strcommon"
    },
    "dbstr_end": {
      "doc": "",
      "type": "RawTrigger",
      "module": "eudplib.string.strcommon"
    },
    "dbstr_start": {
      "doc": "",
      "type": "RawTrigger",
      "module": "eudplib.string.strcommon"
    },
    "init": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.string.strcommon"
    },
    "key1": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.string.strcommon"
    },
    "key2": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.string.strcommon"
    },
    "key3": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.string.strcommon"
    },
    "key4": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.string.strcommon"
    },
    "set_read": {
      "doc": "",
      "type": "Action",
      "module": "eudplib.string.strcommon"
    },
    "create_unit": {
      "doc": "Class for forward definition.",
      "type": "Forward",
      "module": "eudplib.string.cpprint"
    },
    "f_cpstr_adddw": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_cpstr_addptr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_cpstr_addstr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_cpstr_addstr_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.string.cpprint"
    },
    "f_getnextchatdst": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.string.cpprint"
    },
    "f_gettextptr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_raise_CCMU": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "prevcp": {
      "doc": "",
      "type": "EUDVariable",
      "module": "eudplib.string.cpprint"
    },
    "cp949_table": {
      "doc": "",
      "type": "module",
      "module": "eudplib.string"
    },
    "f_cp949_to_utf8_cpy": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_dbstr_adddw": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.string.eudprint"
    },
    "f_dbstr_addptr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.string.eudprint"
    },
    "f_dbstr_addstr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.string.eudprint"
    },
    "f_dbstr_addstr_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.string.eudprint"
    },
    "string": {
      "doc": "",
      "type": "module",
      "module": "urllib.request"
    },
    "LOCALES": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "eudplib.string.locale"
    },
    "LocalLocale": {
      "doc": "",
      "type": "_LocalLocale",
      "module": "freeze.freeze"
    },
    "f_strcmp": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_strcpy": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "f_strnstr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "PLVarMask": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.string.pname"
    },
    "PLVarUnit": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.string.pname"
    },
    "f_check_id": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.string.pname"
    },
    "color_code": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "eudplib.string.texteffect"
    },
    "color_codes": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.string.texteffect"
    },
    "color_v": {
      "doc": "",
      "type": "EUDVariable",
      "module": "eudplib.string.texteffect"
    },
    "f_cpchar_adddw": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.string.texteffect"
    },
    "id_codes": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.string.texteffect"
    },
    "id_gen": {
      "doc": "Return elements from the iterable until it is exhausted. Then repeat the sequence indefinitely.",
      "type": "cycle",
      "module": "eudplib.string.texteffect"
    },
    "DisplayTextAt": {
      "doc": "",
      "type": "EUDFullFuncN",
      "module": "freeze.freeze"
    },
    "DisplayTextAllAt": {
      "doc": "",
      "type": "EUDFullFuncN",
      "module": "freeze.freeze"
    },
    "GetTBLAddr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "cpprint": {
      "doc": "",
      "type": "module",
      "module": "eudplib.string"
    },
    "cpstr": {
      "doc": "",
      "type": "module",
      "module": "eudplib.string"
    },
    "cputf8": {
      "doc": "",
      "type": "module",
      "module": "eudplib.string"
    },
    "dbstr": {
      "doc": "",
      "type": "module",
      "module": "eudplib.string"
    },
    "eudprint": {
      "doc": "",
      "type": "module",
      "module": "eudplib.string"
    },
    "fmtprint": {
      "doc": "",
      "type": "module",
      "module": "eudplib.string"
    },
    "parse": {
      "doc": "",
      "type": "module",
      "module": "urllib"
    },
    "pname": {
      "doc": "",
      "type": "module",
      "module": "eudplib.string"
    },
    "strall": {
      "doc": "",
      "type": "module",
      "module": "eudplib.string"
    },
    "strbuffer": {
      "doc": "",
      "type": "module",
      "module": "eudplib.string"
    },
    "strcommon": {
      "doc": "",
      "type": "module",
      "module": "eudplib.string"
    },
    "strfunc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.string"
    },
    "tblprint": {
      "doc": "",
      "type": "module",
      "module": "eudplib.string"
    },
    "texteffect": {
      "doc": "",
      "type": "module",
      "module": "eudplib.string"
    },
    "posixpath": {
      "doc": "Common operations on Posix pathnames.",
      "type": "module",
      "module": "urllib.request"
    },
    "CHECK_CRC32": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "CHECK_CRC64": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "CHECK_ID_MAX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "CHECK_NONE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "CHECK_SHA256": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "CHECK_UNKNOWN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_ARM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_ARMTHUMB": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_DELTA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_IA64": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_LZMA1": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_LZMA2": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_POWERPC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_SPARC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_X86": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FORMAT_ALONE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FORMAT_AUTO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FORMAT_RAW": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FORMAT_XZ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "MF_BT2": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "MF_BT3": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "MF_BT4": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "MF_HC3": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "MF_HC4": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "MODE_FAST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "MODE_NORMAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "PRESET_DEFAULT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "PRESET_EXTREME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "COPY_BUFSIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "shutil"
    },
    "fnmatch": {
      "doc": "",
      "type": "module",
      "module": "pathlib"
    },
    "nt": {
      "doc": "This module provides access to operating system functionality that is",
      "type": "module",
      "module": "shutil"
    },
    "posix": {
      "doc": "",
      "type": "NoneType",
      "module": "shutil"
    },
    "tempdir": {
      "doc": "",
      "type": "NoneType",
      "module": "tempfile"
    },
    "template": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tempfile"
    },
    "binascii": {
      "doc": "Conversion between binary data and ASCII",
      "type": "module",
      "module": "email.message"
    },
    "tempfile": {
      "doc": "",
      "type": "module",
      "module": "urllib.request"
    },
    "injector": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw"
    },
    "inlinecode": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw"
    },
    "loadmap": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw"
    },
    "mpqadd": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw"
    },
    "savemap": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw"
    },
    "GrpWire32": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "eudplib.eudlib.wireframe.wiredata"
    },
    "GrpWire64": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "eudplib.eudlib.wireframe.wiredata"
    },
    "TranWire32": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "eudplib.eudlib.wireframe.wiredata"
    },
    "TranWire64": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "eudplib.eudlib.wireframe.wiredata"
    },
    "Wirefram32": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "eudplib.eudlib.wireframe.wiredata"
    },
    "Wirefram64": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "eudplib.eudlib.wireframe.wiredata"
    },
    "SetGrpWire": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "SetTranWire": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "SetWirefram": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "SetWireframes": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "defaultwire": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "grpwire": {
      "doc": "",
      "type": "EUDVariable",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "is64bit": {
      "doc": "",
      "type": "EUDLightBool",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "tranwire": {
      "doc": "",
      "type": "EUDVariable",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "wd": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "wirefram": {
      "doc": "",
      "type": "EUDVariable",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "mathf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "utilf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "CRT_ASSEMBLY_VERSION": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "msvcrt"
    },
    "LK_LOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "LK_NBLCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "LK_NBRLCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "LK_RLCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "LK_UNLCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "SEM_FAILCRITICALERRORS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "SEM_NOALIGNMENTFAULTEXCEPT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "SEM_NOGPFAULTERRORBOX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "SEM_NOOPENFILEERRORBOX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "ABOVE_NORMAL_PRIORITY_CLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "BELOW_NORMAL_PRIORITY_CLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "CREATE_BREAKAWAY_FROM_JOB": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "CREATE_DEFAULT_ERROR_MODE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "CREATE_NEW_CONSOLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "CREATE_NEW_PROCESS_GROUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "CREATE_NO_WINDOW": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "DETACHED_PROCESS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "DEVNULL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "HIGH_PRIORITY_CLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "IDLE_PRIORITY_CLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "NORMAL_PRIORITY_CLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "PIPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "REALTIME_PRIORITY_CLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "STARTF_USESHOWWINDOW": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "STARTF_USESTDHANDLES": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "STDOUT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "STD_ERROR_HANDLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "STD_INPUT_HANDLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "STD_OUTPUT_HANDLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "SW_HIDE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "fcntl": {
      "doc": "",
      "type": "NoneType",
      "module": "subprocess"
    },
    "msvcrt": {
      "doc": "",
      "type": "module",
      "module": "subprocess"
    },
    "libeps": {
      "doc": "",
      "type": "CDLL",
      "module": "eudplib.epscript.epscompile"
    },
    "PYCODE_ATTRIBUTES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.epscript.epsimp"
    },
    "PYOPCODE_CACHE_SIZE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.epscript.linetable_calculator"
    },
    "is_scdb_map": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "eudplib.epscript.epsimp"
    },
    "lineno_regex": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "eudplib.epscript.epsimp"
    },
    "epscompile": {
      "doc": "",
      "type": "module",
      "module": "eudplib"
    },
    "epsimp": {
      "doc": "",
      "type": "module",
      "module": "eudplib.epscript"
    },
    "linetable_calculator": {
      "doc": "",
      "type": "module",
      "module": "eudplib.epscript"
    },
    "QueueGameCommand": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "QueueGameCommand_MergeArchon": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "QueueGameCommand_MergeDarkArchon": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "QueueGameCommand_MinimapPing": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "QueueGameCommand_PauseGame": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "QueueGameCommand_QueuedRightClick": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "QueueGameCommand_RestartGame": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "QueueGameCommand_ResumeGame": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "QueueGameCommand_RightClick": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "QueueGameCommand_TrainUnit": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "QueueGameCommand_UseCheat": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "bw": {
      "doc": "",
      "type": "EUDByteWriter",
      "module": "eudplib.qgc.qgc"
    },
    "qgc": {
      "doc": "",
      "type": "module",
      "module": "eudplib"
    },
    "codec": {
      "doc": "",
      "type": "MultibyteCodec",
      "module": "encodings.cp949"
    },
    "mbc": {
      "doc": "",
      "type": "module",
      "module": "encodings.cp949"
    },
    "bindings": {
      "doc": "",
      "type": "module",
      "module": "eudplib"
    },
    "core": {
      "doc": "",
      "type": "module",
      "module": "eudplib"
    },
    "ctrlstru": {
      "doc": "",
      "type": "module",
      "module": "freeze.obfpatch"
    },
    "eudlib": {
      "doc": "",
      "type": "module",
      "module": "eudplib"
    },
    "localize": {
      "doc": "",
      "type": "module",
      "module": "eudplib"
    },
    "maprw": {
      "doc": "",
      "type": "module",
      "module": "eudplib"
    },
    "prelude": {
      "doc": "",
      "type": "module",
      "module": "eudplib"
    },
    "scdata": {
      "doc": "",
      "type": "module",
      "module": "eudplib"
    },
    "trigger": {
      "doc": "",
      "type": "module",
      "module": "freeze.obfpatch"
    },
    "utils": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "error": {
      "doc": "",
      "type": "module",
      "module": "urllib"
    },
    "request": {
      "doc": "",
      "type": "module",
      "module": "urllib"
    },
    "response": {
      "doc": "",
      "type": "module",
      "module": "urllib"
    },
    "IPV4LENGTH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ipaddress"
    },
    "IPV6LENGTH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ipaddress"
    },
    "ipaddress": {
      "doc": "",
      "type": "module",
      "module": "urllib.parse"
    },
    "non_hierarchical": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "urllib.parse"
    },
    "scheme_chars": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "urllib.parse"
    },
    "urlsplit": {
      "doc": "",
      "type": "_lru_cache_wrapper",
      "module": "urllib.request"
    },
    "uses_fragment": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "urllib.parse"
    },
    "uses_netloc": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "urllib.parse"
    },
    "uses_params": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "urllib.parse"
    },
    "uses_query": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "urllib.parse"
    },
    "uses_relative": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "urllib.parse"
    },
    "ntpath": {
      "doc": "Common pathname manipulations, WindowsNT/95 version.",
      "type": "module",
      "module": "pathlib"
    },
    "BZIP2_VERSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "DEFAULT_VERSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "LZMA_VERSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "MAX_EXTRACT_VERSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP64_LIMIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP64_VERSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP_BZIP2": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP_DEFLATED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP_FILECOUNT_LIMIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP_LZMA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP_MAX_COMMENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP_STORED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "bz2": {
      "doc": "",
      "type": "module",
      "module": "zipfile"
    },
    "compressor_names": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "zipfile"
    },
    "lzma": {
      "doc": "",
      "type": "module",
      "module": "zipfile"
    },
    "pathlib": {
      "doc": "",
      "type": "module",
      "module": "zipfile"
    },
    "shutil": {
      "doc": "",
      "type": "module",
      "module": "zipfile"
    },
    "sizeCentralDir": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "sizeEndCentDir": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "sizeEndCentDir64": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "sizeEndCentDir64Locator": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "sizeFileHeader": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "stringCentralDir": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipfile"
    },
    "stringEndArchive": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipfile"
    },
    "stringEndArchive64": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipfile"
    },
    "stringEndArchive64Locator": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipfile"
    },
    "stringFileHeader": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipfile"
    },
    "structCentralDir": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zipfile"
    },
    "structEndArchive": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipfile"
    },
    "structEndArchive64": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zipfile"
    },
    "structEndArchive64Locator": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zipfile"
    },
    "structFileHeader": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zipfile"
    },
    "zlib": {
      "doc": "The functions in this module allow compression and decompression using the",
      "type": "module",
      "module": "zipfile"
    },
    "urllib": {
      "doc": "",
      "type": "module",
      "module": "email.utils"
    },
    "MAXBINSIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "base64"
    },
    "MAXLINESIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "quopri"
    },
    "base64mime": {
      "doc": "",
      "type": "module",
      "module": "email"
    },
    "charset": {
      "doc": "",
      "type": "module",
      "module": "email"
    },
    "encoders": {
      "doc": "",
      "type": "module",
      "module": "email"
    },
    "errors": {
      "doc": "",
      "type": "module",
      "module": "email.message"
    },
    "feedparser": {
      "doc": "",
      "type": "module",
      "module": "email"
    },
    "header": {
      "doc": "",
      "type": "module",
      "module": "email._policybase"
    },
    "iterators": {
      "doc": "",
      "type": "module",
      "module": "email"
    },
    "message": {
      "doc": "",
      "type": "module",
      "module": "email"
    },
    "parser": {
      "doc": "",
      "type": "module",
      "module": "email"
    },
    "quoprimime": {
      "doc": "",
      "type": "module",
      "module": "email"
    },
    "algorithms_available": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "hashlib"
    },
    "algorithms_guaranteed": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "hashlib"
    },
    "client": {
      "doc": "",
      "type": "module",
      "module": "http"
    },
    "CRLF": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.utils"
    },
    "EMPTYSTRING": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.feedparser"
    },
    "MISC_LEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "email.base64mime"
    },
    "ESCAPE": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "json.encoder"
    },
    "HEX": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "quopri"
    },
    "ALIASES": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "email.charset"
    },
    "BASE64": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "email.charset"
    },
    "CHARSETS": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "email.charset"
    },
    "CODEC_MAP": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "email.charset"
    },
    "DEFAULT_CHARSET": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.charset"
    },
    "QP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "email.charset"
    },
    "RFC2047_CHROME_LEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "email.charset"
    },
    "SHORTEST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "email.charset"
    },
    "UNKNOWN8BIT": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.charset"
    },
    "email": {
      "doc": "",
      "type": "module",
      "module": "urllib.request"
    },
    "BSPACE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "email.header"
    },
    "FWS": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.header"
    },
    "MAXLINELEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "email.header"
    },
    "SPACE": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email._parseaddr"
    },
    "SPACE8": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.header"
    },
    "USASCII": {
      "doc": "",
      "type": "Charset",
      "module": "email.header"
    },
    "UTF8": {
      "doc": "",
      "type": "Charset",
      "module": "email.header"
    },
    "ecre": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.header"
    },
    "fcre": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.header"
    },
    "MAXYEAR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "datetime"
    },
    "MINYEAR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "datetime"
    },
    "UTC": {
      "doc": "Fixed offset from UTC implementation of tzinfo.",
      "type": "timezone",
      "module": "datetime"
    },
    "datetime_CAPI": {
      "doc": "Capsule objects let you wrap a C \"void *\" pointer in a Python",
      "type": "PyCapsule",
      "module": "datetime"
    },
    "EPOCH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "FRIDAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "February": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "January": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "MONDAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "SATURDAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "SUNDAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "THURSDAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "TUESDAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "WEDNESDAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "calendar": {
      "doc": "",
      "type": "module",
      "module": "email._parseaddr"
    },
    "datetime": {
      "doc": "Fast implementation of the datetime type.",
      "type": "module",
      "module": "email.utils"
    },
    "day_abbr": {
      "doc": "",
      "type": "_localized_day",
      "module": "calendar"
    },
    "day_name": {
      "doc": "",
      "type": "_localized_day",
      "module": "calendar"
    },
    "firstweekday": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "mdays": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "calendar"
    },
    "month": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "month_abbr": {
      "doc": "",
      "type": "_localized_month",
      "module": "calendar"
    },
    "month_name": {
      "doc": "",
      "type": "_localized_month",
      "module": "calendar"
    },
    "monthcalendar": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "prcal": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "prmonth": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "prweek": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "week": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "weekheader": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "COMMASPACE": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.utils"
    },
    "TICK": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.utils"
    },
    "UEMPTYSTRING": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.utils"
    },
    "escapesre": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.utils"
    },
    "rfc2231_continuation": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.utils"
    },
    "specialsre": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.utils"
    },
    "compat32": {
      "doc": "",
      "type": "Compat32",
      "module": "email.message"
    },
    "NLCRE": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.feedparser"
    },
    "NLCRE_bol": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.feedparser"
    },
    "NLCRE_crack": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.feedparser"
    },
    "NLCRE_eol": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.feedparser"
    },
    "NeedMoreData": {
      "doc": "The base class of the class hierarchy.",
      "type": "object",
      "module": "email.feedparser"
    },
    "headerRE": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.feedparser"
    },
    "base64": {
      "doc": "",
      "type": "module",
      "module": "urllib.request"
    },
    "SEMISPACE": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.message"
    },
    "quopri": {
      "doc": "",
      "type": "module",
      "module": "email.message"
    },
    "tspecials": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.message"
    },
    "ALERT_DESCRIPTION_ACCESS_DENIED": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_BAD_CERTIFICATE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_BAD_CERTIFICATE_HASH_VALUE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_BAD_CERTIFICATE_STATUS_RESPONSE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_BAD_RECORD_MAC": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_CERTIFICATE_EXPIRED": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_CERTIFICATE_REVOKED": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_CERTIFICATE_UNKNOWN": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_CERTIFICATE_UNOBTAINABLE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_CLOSE_NOTIFY": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_DECODE_ERROR": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_DECOMPRESSION_FAILURE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_DECRYPT_ERROR": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_HANDSHAKE_FAILURE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_ILLEGAL_PARAMETER": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_INSUFFICIENT_SECURITY": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_INTERNAL_ERROR": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_NO_RENEGOTIATION": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_PROTOCOL_VERSION": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_RECORD_OVERFLOW": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_UNEXPECTED_MESSAGE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_UNKNOWN_CA": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_UNKNOWN_PSK_IDENTITY": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_UNRECOGNIZED_NAME": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_UNSUPPORTED_CERTIFICATE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_UNSUPPORTED_EXTENSION": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_USER_CANCELLED": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "CERT_NONE": {
      "doc": "An enumeration.",
      "type": "VerifyMode",
      "module": "ssl"
    },
    "CERT_OPTIONAL": {
      "doc": "An enumeration.",
      "type": "VerifyMode",
      "module": "ssl"
    },
    "CERT_REQUIRED": {
      "doc": "An enumeration.",
      "type": "VerifyMode",
      "module": "ssl"
    },
    "CHANNEL_BINDING_TYPES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "ssl"
    },
    "HAS_ALPN": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_ECDH": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_NEVER_CHECK_COMMON_NAME": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_NPN": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_SNI": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_SSLv2": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_SSLv3": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_TLSv1": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_TLSv1_1": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_TLSv1_2": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_TLSv1_3": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "OPENSSL_VERSION": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "ssl"
    },
    "OPENSSL_VERSION_INFO": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "ssl"
    },
    "OPENSSL_VERSION_NUMBER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ssl"
    },
    "OP_ALL": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_CIPHER_SERVER_PREFERENCE": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_ENABLE_MIDDLEBOX_COMPAT": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_IGNORE_UNEXPECTED_EOF": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_COMPRESSION": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_RENEGOTIATION": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_SSLv2": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_SSLv3": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_TICKET": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_TLSv1": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_TLSv1_1": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_TLSv1_2": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_TLSv1_3": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_SINGLE_DH_USE": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_SINGLE_ECDH_USE": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "PEM_FOOTER": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "ssl"
    },
    "PEM_HEADER": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "ssl"
    },
    "PROTOCOL_SSLv23": {
      "doc": "An enumeration.",
      "type": "_SSLMethod",
      "module": "ssl"
    },
    "PROTOCOL_TLS": {
      "doc": "An enumeration.",
      "type": "_SSLMethod",
      "module": "ssl"
    },
    "PROTOCOL_TLS_CLIENT": {
      "doc": "An enumeration.",
      "type": "_SSLMethod",
      "module": "ssl"
    },
    "PROTOCOL_TLS_SERVER": {
      "doc": "An enumeration.",
      "type": "_SSLMethod",
      "module": "ssl"
    },
    "PROTOCOL_TLSv1": {
      "doc": "An enumeration.",
      "type": "_SSLMethod",
      "module": "ssl"
    },
    "PROTOCOL_TLSv1_1": {
      "doc": "An enumeration.",
      "type": "_SSLMethod",
      "module": "ssl"
    },
    "PROTOCOL_TLSv1_2": {
      "doc": "An enumeration.",
      "type": "_SSLMethod",
      "module": "ssl"
    },
    "SSL_ERROR_EOF": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_INVALID_ERROR_CODE": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_SSL": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_SYSCALL": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_WANT_CONNECT": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_WANT_READ": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_WANT_WRITE": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_WANT_X509_LOOKUP": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_ZERO_RETURN": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "VERIFY_ALLOW_PROXY_CERTS": {
      "doc": "An enumeration.",
      "type": "VerifyFlags",
      "module": "ssl"
    },
    "VERIFY_CRL_CHECK_CHAIN": {
      "doc": "An enumeration.",
      "type": "VerifyFlags",
      "module": "ssl"
    },
    "VERIFY_CRL_CHECK_LEAF": {
      "doc": "An enumeration.",
      "type": "VerifyFlags",
      "module": "ssl"
    },
    "VERIFY_DEFAULT": {
      "doc": "An enumeration.",
      "type": "VerifyFlags",
      "module": "ssl"
    },
    "VERIFY_X509_PARTIAL_CHAIN": {
      "doc": "An enumeration.",
      "type": "VerifyFlags",
      "module": "ssl"
    },
    "VERIFY_X509_STRICT": {
      "doc": "An enumeration.",
      "type": "VerifyFlags",
      "module": "ssl"
    },
    "VERIFY_X509_TRUSTED_FIRST": {
      "doc": "An enumeration.",
      "type": "VerifyFlags",
      "module": "ssl"
    },
    "ACCEPTED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "ALREADY_REPORTED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "BAD_GATEWAY": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "BAD_REQUEST": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "CONFLICT": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "CONTINUE": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "CREATED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "EARLY_HINTS": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "EXPECTATION_FAILED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "FAILED_DEPENDENCY": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "FORBIDDEN": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "FOUND": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "GATEWAY_TIMEOUT": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "GONE": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "HTTPS_PORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "http.client"
    },
    "HTTP_PORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "http.client"
    },
    "HTTP_VERSION_NOT_SUPPORTED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "IM_A_TEAPOT": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "IM_USED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "INSUFFICIENT_STORAGE": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "INTERNAL_SERVER_ERROR": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "LENGTH_REQUIRED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "LOCKED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "LOOP_DETECTED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "METHOD_NOT_ALLOWED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "MISDIRECTED_REQUEST": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "MOVED_PERMANENTLY": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "MULTIPLE_CHOICES": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "MULTI_STATUS": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NETWORK_AUTHENTICATION_REQUIRED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NON_AUTHORITATIVE_INFORMATION": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NOT_ACCEPTABLE": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NOT_EXTENDED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NOT_FOUND": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NOT_IMPLEMENTED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NOT_MODIFIED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NO_CONTENT": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "OK": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "PARTIAL_CONTENT": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "PAYMENT_REQUIRED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "PERMANENT_REDIRECT": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "PRECONDITION_FAILED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "PRECONDITION_REQUIRED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "PROCESSING": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "PROXY_AUTHENTICATION_REQUIRED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "REQUESTED_RANGE_NOT_SATISFIABLE": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "REQUEST_ENTITY_TOO_LARGE": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "REQUEST_HEADER_FIELDS_TOO_LARGE": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "REQUEST_TIMEOUT": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "REQUEST_URI_TOO_LONG": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "RESET_CONTENT": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "SEE_OTHER": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "SERVICE_UNAVAILABLE": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "SWITCHING_PROTOCOLS": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "TEMPORARY_REDIRECT": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "TOO_EARLY": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "TOO_MANY_REQUESTS": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "UNAUTHORIZED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "UNAVAILABLE_FOR_LEGAL_REASONS": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "UNPROCESSABLE_ENTITY": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "UNSUPPORTED_MEDIA_TYPE": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "UPGRADE_REQUIRED": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "USE_PROXY": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "VARIANT_ALSO_NEGOTIATES": {
      "doc": "An enumeration.",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "http": {
      "doc": "",
      "type": "module",
      "module": "urllib.request"
    },
    "responses": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "http.client"
    },
    "ssl": {
      "doc": "",
      "type": "module",
      "module": "urllib.request"
    },
    "MAXFTPCACHE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "urllib.request"
    },
    "bisect": {
      "doc": "",
      "type": "module",
      "module": "urllib.request"
    },
    "ftpcache": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "urllib.request"
    },
    "hashlib": {
      "doc": "hashlib module - A common interface to many hash functions.",
      "type": "module",
      "module": "urllib.request"
    },
    "MB_ICONASTERISK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "MB_ICONEXCLAMATION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "MB_ICONHAND": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "applyeuddraft"
    },
    "MB_ICONQUESTION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "MB_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "applyeuddraft"
    },
    "SND_ALIAS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_APPLICATION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_ASYNC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_FILENAME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_LOOP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_MEMORY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_NODEFAULT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_NOSTOP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_NOWAIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_PURGE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "MAX_PATH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ctypes.wintypes"
    },
    "ctypes": {
      "doc": "",
      "type": "module",
      "module": "msgbox"
    },
    "GetAsyncKeyState": {
      "doc": "",
      "type": "WinFunctionType",
      "module": "msgbox"
    },
    "GetConsoleWindow": {
      "doc": "",
      "type": "WinFunctionType",
      "module": "msgbox"
    },
    "GetForegroundWindow": {
      "doc": "",
      "type": "WinFunctionType",
      "module": "msgbox"
    },
    "SetForegroundWindow": {
      "doc": "",
      "type": "WinFunctionType",
      "module": "msgbox"
    },
    "isWindows": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "msgbox"
    },
    "RELEASE_URL": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "autoupdate"
    },
    "VERSION_URL": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "autoupdate"
    },
    "atexit": {
      "doc": "allow programmer to define multiple exit functions to be executed",
      "type": "module",
      "module": "multiprocessing.util"
    },
    "msgbox": {
      "doc": "",
      "type": "module",
      "module": "applyeuddraft"
    },
    "zipfile": {
      "doc": "",
      "type": "module",
      "module": "autoupdate"
    },
    "basepath": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "applyeuddraft"
    },
    "freeze_enabled": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "pluginLoader"
    },
    "prompt_enabled": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "pluginLoader"
    },
    "scbankSettings": {
      "doc": "",
      "type": "NoneType",
      "module": "pluginLoader"
    },
    "scbank_enabled": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "pluginLoader"
    },
    "DEFAULT_LOGGING_FORMAT": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "multiprocessing.util"
    },
    "LOGGER_NAME": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "multiprocessing.util"
    },
    "MAXFD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "multiprocessing.util"
    },
    "NOTSET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "multiprocessing.util"
    },
    "abstract_sockets_supported": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "multiprocessing.util"
    },
    "weakref": {
      "doc": "",
      "type": "module",
      "module": "eudplib.collections.objpool"
    },
    "WINEXE": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "multiprocessing.spawn"
    },
    "WINSERVICE": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "multiprocessing.spawn"
    },
    "old_main_modules": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "multiprocessing.spawn"
    },
    "runpy": {
      "doc": "runpy.py - locating and running Python code using the module namespace",
      "type": "module",
      "module": "multiprocessing.spawn"
    },
    "autoupdate": {
      "doc": "",
      "type": "module",
      "module": "euddraft"
    },
    "ep": {
      "doc": "",
      "type": "module",
      "module": "applyeuddraft"
    },
    "mp": {
      "doc": "",
      "type": "module",
      "module": "euddraft"
    },
    "default_ptex": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "freeze.trigutils"
    },
    "default_pupx": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "freeze.trigutils"
    },
    "fread": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.trigutils"
    },
    "obf_ptex": {
      "doc": "",
      "type": "NoneType",
      "module": "freeze.trigutils"
    },
    "obf_pupx": {
      "doc": "",
      "type": "NoneType",
      "module": "freeze.trigutils"
    },
    "obfuData": {
      "doc": "",
      "type": "Db",
      "module": "freeze.trigutils"
    },
    "randbits": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "freeze.trigutils"
    },
    "randonset": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "freeze.trigutils"
    },
    "restore_ptex": {
      "doc": "",
      "type": "NoneType",
      "module": "freeze.trigutils"
    },
    "restore_pupx": {
      "doc": "",
      "type": "NoneType",
      "module": "freeze.trigutils"
    },
    "mix": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "unTDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "freeze.crypt"
    },
    "cryptKey": {
      "doc": "",
      "type": "EUDVariable",
      "module": "freeze.freeze"
    },
    "oJumper": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "freeze.obfjump"
    },
    "oJumperArray": {
      "doc": "",
      "type": "OJumperBuffer",
      "module": "freeze.obfjump"
    },
    "oJumperSet": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "freeze.obfjump"
    },
    "tKeys": {
      "doc": "",
      "type": "NoneType",
      "module": "freeze.obfjump"
    },
    "patchList": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "freeze.obfpatch"
    },
    "decryptTrigger": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.freeze"
    },
    "obfuscateDT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "freeze.freeze"
    },
    "tabCount": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "freeze.trigcrypt"
    },
    "g_seedKey": {
      "doc": "",
      "type": "NoneType",
      "module": "freeze.freeze"
    },
    "crypt": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "freeze": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "keycalc": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "mpqh": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "obfjump": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "pdefault": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "trigcrypt": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "trigutils": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "edPath": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "applyeuddraft"
    },
    "epPath": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "applyeuddraft"
    },
    "freezeMpq": {
      "doc": "",
      "type": "module",
      "module": "applyeuddraft"
    },
    "globalPluginPath": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "applyeuddraft"
    },
    "scbank_core": {
      "doc": "",
      "type": "module",
      "module": "applyeuddraft"
    },
    "json": {
      "doc": "",
      "type": "module",
      "module": "main"
    },
    "pkgutil": {
      "doc": "",
      "type": "module",
      "module": "main"
    },
    "settings": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "main"
    },
    "NUMBER_RE": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "json.scanner"
    },
    "BACKSLASH": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "json.decoder"
    },
    "NaN": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "json.decoder"
    },
    "NegInf": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "json.decoder"
    },
    "PosInf": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "json.decoder"
    },
    "STRINGCHUNK": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "json.decoder"
    },
    "WHITESPACE_STR": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "json.decoder"
    },
    "scanner": {
      "doc": "",
      "type": "module",
      "module": "json"
    },
    "ESCAPE_ASCII": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "json.encoder"
    },
    "ESCAPE_DCT": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "json.encoder"
    },
    "HAS_UTF8": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "json.encoder"
    },
    "INFINITY": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "json.encoder"
    },
    "decoder": {
      "doc": "",
      "type": "module",
      "module": "json"
    },
    "encoder": {
      "doc": "",
      "type": "module",
      "module": "json"
    },
    "zipimport": {
      "doc": "zipimport provides support for importing Python modules from Zip archives.",
      "type": "module",
      "module": "pkgutil"
    }
  }
}