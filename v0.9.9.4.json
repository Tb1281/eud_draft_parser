{
  "built_ins": {
    "clear": {
      "type": "built_in",
      "doc": "D.clear() -> None.  Remove all items from D."
    },
    "copy": {
      "type": "built_in",
      "doc": "D.copy() -> a shallow copy of D"
    },
    "fromkeys": {
      "type": "built_in",
      "doc": "Create a new dictionary with keys from iterable and values set to value."
    },
    "get": {
      "type": "built_in",
      "doc": "Return the value for key if key is in the dictionary, else default."
    },
    "items": {
      "type": "built_in",
      "doc": "D.items() -> a set-like object providing a view on D's items"
    },
    "keys": {
      "type": "built_in",
      "doc": "D.keys() -> a set-like object providing a view on D's keys"
    },
    "pop": {
      "type": "built_in",
      "doc": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value."
    },
    "popitem": {
      "type": "built_in",
      "doc": "Remove and return a (key, value) pair as a 2-tuple."
    },
    "setdefault": {
      "type": "built_in",
      "doc": "Insert key with a value of default if key is not in the dictionary."
    },
    "update": {
      "type": "built_in",
      "doc": "D.update([E, ]**F) -> None.  Update D from dict/iterable E and F."
    },
    "values": {
      "type": "built_in",
      "doc": "D.values() -> an object providing a view on D's values"
    }
  },
  "keywords": {
    "False": {
      "type": "keyword"
    },
    "None": {
      "type": "keyword"
    },
    "True": {
      "type": "keyword"
    },
    "and": {
      "type": "keyword"
    },
    "as": {
      "type": "keyword"
    },
    "assert": {
      "type": "keyword"
    },
    "async": {
      "type": "keyword"
    },
    "await": {
      "type": "keyword"
    },
    "break": {
      "type": "keyword"
    },
    "class": {
      "type": "keyword"
    },
    "continue": {
      "type": "keyword"
    },
    "def": {
      "type": "keyword"
    },
    "del": {
      "type": "keyword"
    },
    "elif": {
      "type": "keyword"
    },
    "else": {
      "type": "keyword"
    },
    "except": {
      "type": "keyword"
    },
    "finally": {
      "type": "keyword"
    },
    "for": {
      "type": "keyword"
    },
    "from": {
      "type": "keyword"
    },
    "global": {
      "type": "keyword"
    },
    "if": {
      "type": "keyword"
    },
    "import": {
      "type": "keyword"
    },
    "in": {
      "type": "keyword"
    },
    "is": {
      "type": "keyword"
    },
    "lambda": {
      "type": "keyword"
    },
    "nonlocal": {
      "type": "keyword"
    },
    "not": {
      "type": "keyword"
    },
    "or": {
      "type": "keyword"
    },
    "pass": {
      "type": "keyword"
    },
    "raise": {
      "type": "keyword"
    },
    "return": {
      "type": "keyword"
    },
    "try": {
      "type": "keyword"
    },
    "while": {
      "type": "keyword"
    },
    "with": {
      "type": "keyword"
    },
    "yield": {
      "type": "keyword"
    }
  },
  "libraries": {
    "sys": {
      "type": "module",
      "doc": "This module provides access to some objects used or maintained by the"
    },
    "builtins": {
      "type": "module",
      "doc": "Built-in functions, exceptions, and other objects."
    },
    "marshal": {
      "type": "module",
      "doc": "This module contains functions that can read and write Python values in"
    },
    "nt": {
      "type": "module",
      "doc": "This module provides access to operating system functionality that is"
    },
    "winreg": {
      "type": "module",
      "doc": "This module provides access to the Windows registry API."
    },
    "time": {
      "type": "module",
      "doc": "This module provides various functions to manipulate time values."
    },
    "zipimport": {
      "type": "module",
      "doc": "zipimport provides support for importing Python modules from Zip archives."
    },
    "zlib": {
      "type": "module",
      "doc": "The functions in this module allow compression and decompression using the"
    },
    "codecs": {
      "type": "module",
      "doc": " codecs -- Python Codec Registry, API and helpers."
    },
    "encodings.aliases": {
      "type": "module",
      "doc": " Encoding Aliases Support"
    },
    "encodings": {
      "type": "module",
      "doc": " Standard \"encodings\" Package"
    },
    "encodings.utf_8": {
      "type": "module",
      "doc": " Python 'utf-8' Codec"
    },
    "encodings.cp1252": {
      "type": "module",
      "doc": " Python Character Mapping Codec cp1252 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1252.TXT' with gencodec.py."
    },
    "abc": {
      "type": "module",
      "doc": "Abstract Base Classes (ABCs) according to PEP 3119."
    },
    "io": {
      "type": "module",
      "doc": "The io module provides the Python interfaces to stream handling. The"
    },
    "stat": {
      "type": "module",
      "doc": "Constants/functions for interpreting results of os.stat() and os.lstat()."
    },
    "genericpath": {
      "type": "module",
      "doc": ""
    },
    "ntpath": {
      "type": "module",
      "doc": "Common pathname manipulations, WindowsNT/95 version."
    },
    "os.path": {
      "type": "module",
      "doc": "Common pathname manipulations, WindowsNT/95 version."
    },
    "os": {
      "type": "module",
      "doc": "OS routines for NT or Posix depending on what system we're on."
    },
    "types": {
      "type": "module",
      "doc": ""
    },
    "enum": {
      "type": "module",
      "doc": ""
    },
    "sre_constants": {
      "type": "module",
      "doc": "Internal support module for sre"
    },
    "sre_parse": {
      "type": "module",
      "doc": "Internal support module for sre"
    },
    "sre_compile": {
      "type": "module",
      "doc": "Internal support module for sre"
    },
    "itertools": {
      "type": "module",
      "doc": "Functional tools for creating and using iterators."
    },
    "keyword": {
      "type": "module",
      "doc": "Keywords (from \"Grammar/python.gram\")"
    },
    "operator": {
      "type": "module",
      "doc": "Operator interface."
    },
    "reprlib": {
      "type": "module",
      "doc": "Redo the builtin repr() (representation) but with limits on most sizes."
    },
    "collections": {
      "type": "module",
      "doc": "This module implements specialized container datatypes providing"
    },
    "functools": {
      "type": "module",
      "doc": "functools.py - Tools for working with functions and callable objects"
    },
    "copyreg": {
      "type": "module",
      "doc": "Helper to provide extensibility for pickle."
    },
    "re": {
      "type": "module",
      "doc": "Support for regular expressions (RE)."
    },
    "string": {
      "type": "module",
      "doc": "A collection of string constants."
    },
    "importlib._bootstrap": {
      "type": "module",
      "doc": "Core implementation of import."
    },
    "importlib._bootstrap_external": {
      "type": "module",
      "doc": "Core implementation of path-based import."
    },
    "warnings": {
      "type": "module",
      "doc": "Python part of the warnings subsystem."
    },
    "importlib": {
      "type": "module",
      "doc": "A pure Python implementation of import."
    },
    "importlib.machinery": {
      "type": "module",
      "doc": "The machinery of importlib: finders, loaders, hooks, etc."
    },
    "sysconfig": {
      "type": "module",
      "doc": "Access to Python's configuration information."
    },
    "collections.abc": {
      "type": "module",
      "doc": ""
    },
    "contextlib": {
      "type": "module",
      "doc": "Utilities for with-statement contexts.  See PEP 343."
    },
    "typing.io": {
      "type": "module",
      "doc": "Wrapper namespace for IO generic classes."
    },
    "typing.re": {
      "type": "module",
      "doc": "Wrapper namespace for re type aliases."
    },
    "typing": {
      "type": "module",
      "doc": ""
    },
    "BUILD_CONSTANTS": {
      "type": "module",
      "doc": ""
    },
    "euddraft__init__": {
      "type": "module",
      "doc": ""
    },
    "threading": {
      "type": "module",
      "doc": "Thread module emulating a subset of Java's threading model."
    },
    "signal": {
      "type": "module",
      "doc": ""
    },
    "multiprocessing.process": {
      "type": "module",
      "doc": ""
    },
    "struct": {
      "type": "module",
      "doc": "Functions to convert between Python values and C structs."
    },
    "pickle": {
      "type": "module",
      "doc": "Create portable serialized representations of Python objects."
    },
    "math": {
      "type": "module",
      "doc": "This module provides access to the mathematical functions"
    },
    "select": {
      "type": "module",
      "doc": "This module supports asynchronous I/O on multiple file descriptors."
    },
    "selectors": {
      "type": "module",
      "doc": "Selectors module."
    },
    "errno": {
      "type": "module",
      "doc": "This module makes available standard errno system symbols."
    },
    "socket": {
      "type": "module",
      "doc": "This module provides socket operations and some related functions."
    },
    "multiprocessing.reduction": {
      "type": "module",
      "doc": ""
    },
    "multiprocessing.context": {
      "type": "module",
      "doc": ""
    },
    "multiprocessing": {
      "type": "module",
      "doc": ""
    },
    "gettext": {
      "type": "module",
      "doc": "Internationalization and localization support."
    },
    "locale": {
      "type": "module",
      "doc": "Locale support module."
    },
    "eudplib.localize": {
      "type": "module",
      "doc": ""
    },
    "eudplib.utils.binio": {
      "type": "module",
      "doc": ""
    },
    "eudplib.utils.eperror": {
      "type": "module",
      "doc": ""
    },
    "eudplib.utils.blockstru": {
      "type": "module",
      "doc": ""
    },
    "bisect": {
      "type": "module",
      "doc": "Bisection algorithms."
    },
    "random": {
      "type": "module",
      "doc": "Random variable generators."
    },
    "eudplib.utils.etc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.utils.exprproxy": {
      "type": "module",
      "doc": ""
    },
    "eudplib.utils.ubconv": {
      "type": "module",
      "doc": ""
    },
    "eudplib.utils": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.allocator.rlocint": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.allocator.constexpr": {
      "type": "module",
      "doc": ""
    },
    "eudplib.utils.stackobjs": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.allocator.pbuffer": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.allocator.payload": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.allocator": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.chktok": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.playerinfo": {
      "type": "module",
      "doc": ""
    },
    "ctypes._endian": {
      "type": "module",
      "doc": ""
    },
    "ctypes": {
      "type": "module",
      "doc": "create and manipulate C data types in Python"
    },
    "eudplib.core.mapdata.unitprp": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.proptable": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.tblformat": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.stringmap": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.mapdata": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.constenc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.action": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.condition": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudobj.eudobj": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudobj.bytedump": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudobj": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.triggerscope": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.rawtriggerdef": {
      "type": "module",
      "doc": ""
    },
    "heapq": {
      "type": "module",
      "doc": "Heap queue algorithm (a.k.a. priority queue)."
    },
    "difflib": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.flingy": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.icon": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.image": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.iscript": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.portrait": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.sprite": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.stattxt": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.tech": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.trg": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.unitorder": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.upgrade": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict.weapon": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strdict": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.strenc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.stockact": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger.stockcond": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.rawtrigger": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.variable.vbase": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.variable.eudlv": {
      "type": "module",
      "doc": ""
    },
    "token": {
      "type": "module",
      "doc": "Token constants."
    },
    "tokenize": {
      "type": "module",
      "doc": "Tokenization help for Python programs."
    },
    "linecache": {
      "type": "module",
      "doc": "Cache lines from Python source files."
    },
    "traceback": {
      "type": "module",
      "doc": "Extract, format and print information about Python stack traces."
    },
    "eudplib.core.variable.vbuf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.variable.eudv": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.variable.eudxv": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.variable": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.variable.evcommon": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.consttype": {
      "type": "module",
      "doc": ""
    },
    "ast": {
      "type": "module",
      "doc": ""
    },
    "opcode": {
      "type": "module",
      "doc": ""
    },
    "dis": {
      "type": "module",
      "doc": "Disassembler of Python byte code into mnemonics."
    },
    "inspect": {
      "type": "module",
      "doc": "Get useful information from live Python objects."
    },
    "eudplib.core.eudfunc.trace.tracecrypt": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.trace.tracetool": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.trace": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.eudfuncn": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.eudtypedfuncn": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.eudf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudstruct.selftype": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.curpl": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.inplacecw": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudstruct.vararray": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudstruct.structarr": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudstruct.eudstruct": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudstruct": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.eudfmethod": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc.eudfptr": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.eudfunc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.calcf.muldiv": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.calcf.bitwise": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.calcf._eudvsupport": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.calcf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.inlinens": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigger.filler": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigger.tpatcher": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigger.branch": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigger.triggerdef": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigger.ptrigger": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigger": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.basicstru": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.cshelper": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.loopblock": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.jumptable": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.swblock": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.breakcont": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.shortcircuit": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru.simpleblock": {
      "type": "module",
      "doc": ""
    },
    "eudplib.ctrlstru": {
      "type": "module",
      "doc": ""
    },
    "msvcrt": {
      "type": "module",
      "doc": ""
    },
    "subprocess": {
      "type": "module",
      "doc": "Subprocesses with accessible I/O streams"
    },
    "platform": {
      "type": "module",
      "doc": " This module tries to retrieve as much platform-identifying data as"
    },
    "eudplib.epscript.epscompile": {
      "type": "module",
      "doc": ""
    },
    "eudplib.epscript.epsimp": {
      "type": "module",
      "doc": ""
    },
    "eudplib.epscript": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.s": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.memiof.modcurpl": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.memiof.dwepdio": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.memiof.byterw": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.memiof.cpmemio": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.memiof.bwepdio": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.memiof.cpbyterw": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.memiof.mblockio": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.memiof.memifgen": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.memiof.ptrmemio": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.memiof.varrayreader": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.memiof": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.eudarray": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.eudgrp": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.eudqueue": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.eudstack": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.locf.locf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.locf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.mathf.atan2": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.mathf.lengthdir": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.mathf.pow": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.binsearch": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.gametick": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigtrg.trigtrg": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigtrg": {
      "type": "module",
      "doc": ""
    },
    "eudplib.trigtrg.runtrigtrg": {
      "type": "module",
      "doc": ""
    },
    "weakref": {
      "type": "module",
      "doc": "Weak reference support for Python."
    },
    "copy": {
      "type": "module",
      "doc": "Generic (shallow and deep) copying operations."
    },
    "dataclasses": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.unlimiterflag": {
      "type": "module",
      "doc": ""
    },
    "eudplib.offsetmap.member": {
      "type": "module",
      "doc": ""
    },
    "eudplib.offsetmap.epdoffsetmap": {
      "type": "module",
      "doc": ""
    },
    "eudplib.offsetmap.csprite": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.logic": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.mempatch": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.pexist": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.random": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf.userpl": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.utilf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.mathf.sqrt": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.mathf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.playerv": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.qgcf.qgc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.qgcf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.rwcommon": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.cpstr": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.dbstr": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.eudprint": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.cpprint": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.cp949_table": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.cputf8": {
      "type": "module",
      "doc": ""
    },
    "urllib": {
      "type": "module",
      "doc": ""
    },
    "urllib.parse": {
      "type": "module",
      "doc": "Parse (absolute and relative) URLs."
    },
    "email": {
      "type": "module",
      "doc": "A package for parsing, handling, and generating email messages."
    },
    "email.errors": {
      "type": "module",
      "doc": "email package exception classes."
    },
    "binascii": {
      "type": "module",
      "doc": "Conversion between binary data and ASCII"
    },
    "email.quoprimime": {
      "type": "module",
      "doc": "Quoted-printable content transfer encoding per RFCs 2045-2047."
    },
    "base64": {
      "type": "module",
      "doc": "Base16, Base32, Base64 (RFC 3548), Base85 and Ascii85 data encodings"
    },
    "email.base64mime": {
      "type": "module",
      "doc": "Base64 content transfer encoding per RFCs 2045-2047."
    },
    "quopri": {
      "type": "module",
      "doc": "Conversions to/from quoted-printable transport encoding as per RFC 1521."
    },
    "email.encoders": {
      "type": "module",
      "doc": "Encodings and related functions."
    },
    "email.charset": {
      "type": "module",
      "doc": ""
    },
    "email.header": {
      "type": "module",
      "doc": "Header encoding and decoding functionality."
    },
    "datetime": {
      "type": "module",
      "doc": "Fast implementation of the datetime type."
    },
    "calendar": {
      "type": "module",
      "doc": "Calendar printing functions"
    },
    "email._parseaddr": {
      "type": "module",
      "doc": "Email address parsing code."
    },
    "email.utils": {
      "type": "module",
      "doc": "Miscellaneous utilities."
    },
    "email._policybase": {
      "type": "module",
      "doc": "Policy framework for the email package."
    },
    "email.feedparser": {
      "type": "module",
      "doc": "FeedParser - An email feed parser."
    },
    "email.parser": {
      "type": "module",
      "doc": "A parser of RFC 2822 and MIME email messages."
    },
    "uu": {
      "type": "module",
      "doc": "Implementation of the UUencode and UUdecode functions."
    },
    "email._encoded_words": {
      "type": "module",
      "doc": " Routines for manipulating RFC2047 encoded words."
    },
    "email.iterators": {
      "type": "module",
      "doc": "Various types of useful iterators and generators."
    },
    "email.message": {
      "type": "module",
      "doc": "Basic message object for the email package object model."
    },
    "html.entities": {
      "type": "module",
      "doc": "HTML character entity references."
    },
    "html": {
      "type": "module",
      "doc": ""
    },
    "posixpath": {
      "type": "module",
      "doc": "Common operations on Posix pathnames."
    },
    "fnmatch": {
      "type": "module",
      "doc": "Filename matching with shell patterns."
    },
    "bz2": {
      "type": "module",
      "doc": "Interface to the libbzip2 compression library."
    },
    "lzma": {
      "type": "module",
      "doc": "Interface to the liblzma compression library."
    },
    "shutil": {
      "type": "module",
      "doc": "Utility functions for copying and archiving files and directory trees."
    },
    "tempfile": {
      "type": "module",
      "doc": "Temporary files."
    },
    "cgi": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.fmtprint": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.parse": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.strfunc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.pname": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.injector": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.inlinecode.btInliner": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.inlinecode.ilccompile": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.inlinecode.ilcprocesstrig": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.inlinecode": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.injector.injFinalizer": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.injector.payloadInit": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.injector.payloadReloc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.injector.vectorReloc": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.injector.applyInjector": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.injector.mainloop": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.mpqapi": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.mpqadd": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.loadmap": {
      "type": "module",
      "doc": ""
    },
    "eudplib.core.mapdata.fixmapdata": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw.savemap": {
      "type": "module",
      "doc": ""
    },
    "eudplib.maprw": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.texteffect": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.strbuffer": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.strall": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf.tblprint": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.stringf": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.unitgroup": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.wireframe.wiredata": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.wireframe.wireframe": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.wireframe": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib": {
      "type": "module",
      "doc": ""
    },
    "encodings.cp949": {
      "type": "module",
      "doc": ""
    },
    "atexit": {
      "type": "module",
      "doc": "allow programmer to define multiple exit functions to be executed"
    },
    "importlib._abc": {
      "type": "module",
      "doc": "Subset of importlib.abc used to reduce importlib.util imports."
    },
    "importlib.util": {
      "type": "module",
      "doc": "Utility code for constructing importers, etc."
    },
    "pathlib": {
      "type": "module",
      "doc": ""
    },
    "zipfile": {
      "type": "module",
      "doc": ""
    },
    "urllib.response": {
      "type": "module",
      "doc": ""
    },
    "urllib.error": {
      "type": "module",
      "doc": ""
    },
    "hashlib": {
      "type": "module",
      "doc": "hashlib module - A common interface to many hash functions."
    },
    "http": {
      "type": "module",
      "doc": ""
    },
    "ssl": {
      "type": "module",
      "doc": "This module provides some more Pythonic support for SSL."
    },
    "http.client": {
      "type": "module",
      "doc": "HTTP/1.1 client library"
    },
    "nturl2path": {
      "type": "module",
      "doc": ""
    },
    "urllib.request": {
      "type": "module",
      "doc": ""
    },
    "winsound": {
      "type": "module",
      "doc": "PlaySound(sound, flags) - play a sound"
    },
    "ctypes.wintypes": {
      "type": "module",
      "doc": ""
    },
    "msgbox": {
      "type": "module",
      "doc": ""
    },
    "autoupdate": {
      "type": "module",
      "doc": ""
    },
    "pluginLoader": {
      "type": "module",
      "doc": ""
    },
    "textwrap": {
      "type": "module",
      "doc": "Text wrapping and filling."
    },
    "colorama.ansi": {
      "type": "module",
      "doc": ""
    },
    "colorama.win32": {
      "type": "module",
      "doc": ""
    },
    "colorama.winterm": {
      "type": "module",
      "doc": ""
    },
    "colorama.ansitowin32": {
      "type": "module",
      "doc": ""
    },
    "colorama.initialise": {
      "type": "module",
      "doc": ""
    },
    "colorama": {
      "type": "module",
      "doc": ""
    },
    "readconfig": {
      "type": "module",
      "doc": ""
    },
    "runpy": {
      "type": "module",
      "doc": "runpy.py - locating and running Python code using the module namespace"
    },
    "multiprocessing.util": {
      "type": "module",
      "doc": ""
    },
    "multiprocessing.spawn": {
      "type": "module",
      "doc": ""
    },
    "euddraft": {
      "type": "module",
      "doc": ""
    },
    "freezeMpq": {
      "type": "module",
      "doc": ""
    },
    "scbank_core": {
      "type": "module",
      "doc": ""
    },
    "freeze.pdefault": {
      "type": "module",
      "doc": ""
    },
    "freeze.crypt": {
      "type": "module",
      "doc": ""
    },
    "freeze.utils": {
      "type": "module",
      "doc": ""
    },
    "freeze.obfpatch": {
      "type": "module",
      "doc": ""
    },
    "freeze": {
      "type": "module",
      "doc": ""
    },
    "applyeuddraft": {
      "type": "module",
      "doc": ""
    },
    "eudplib.eudlib.objpool": {
      "type": "module",
      "doc": ""
    },
    "main": {
      "type": "module",
      "doc": ""
    },
    "json.scanner": {
      "type": "module",
      "doc": ""
    },
    "json.decoder": {
      "type": "module",
      "doc": ""
    },
    "json.encoder": {
      "type": "module",
      "doc": ""
    },
    "json": {
      "type": "module",
      "doc": ""
    },
    "pkgutil": {
      "type": "module",
      "doc": "Utilities to support packages."
    }
  },
  "functions": {
    "excepthook": {
      "signature": "(type_: type[BaseException], value: BaseException, traceback: traceback | None) -> Any",
      "doc": "",
      "module": "sys"
    },
    "unraisablehook": {
      "signature": "(unraisable) -> None",
      "doc": "",
      "module": "sys"
    },
    "EncodedFile": {
      "signature": "(file, data_encoding, file_encoding=None, errors='strict')",
      "doc": " Return a wrapped version of file which provides transparent",
      "module": "codecs"
    },
    "getdecoder": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getencoder": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getincrementaldecoder": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getincrementalencoder": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getreader": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "getwriter": {
      "signature": "(encoding)",
      "doc": " Lookup up the codec for the given encoding and return",
      "module": "codecs"
    },
    "iterdecode": {
      "signature": "(iterator, encoding, errors='strict', **kwargs)",
      "doc": "",
      "module": "codecs"
    },
    "iterencode": {
      "signature": "(iterator, encoding, errors='strict', **kwargs)",
      "doc": "",
      "module": "codecs"
    },
    "make_encoding_map": {
      "signature": "(decoding_map)",
      "doc": " Creates an encoding map from a decoding map.",
      "module": "codecs"
    },
    "make_identity_dict": {
      "signature": "(rng)",
      "doc": " make_identity_dict(rng) -> dict",
      "module": "codecs"
    },
    "open": {
      "signature": "(filename, mode='rb', *, format=None, check=-1, preset=None, filters=None, encoding=None, errors=None, newline=None)",
      "doc": "Open an LZMA-compressed file in binary or text mode.",
      "module": "lzma"
    },
    "normalize_encoding": {
      "signature": "(encoding)",
      "doc": " Normalize an encoding name.",
      "module": "encodings"
    },
    "search_function": {
      "signature": "(encoding)",
      "doc": "",
      "module": "encodings"
    },
    "decode": {
      "signature": "(ew)",
      "doc": "Decode encoded word and return (string, charset, lang, defects) tuple.",
      "module": "email._encoded_words"
    },
    "getregentry": {
      "signature": "()",
      "doc": "",
      "module": "encodings.cp949"
    },
    "abstractmethod": {
      "signature": "(funcobj)",
      "doc": "A decorator indicating abstract methods.",
      "module": "eudplib.offsetmap.member"
    },
    "update_abstractmethods": {
      "signature": "(cls)",
      "doc": "Recalculate the set of abstract methods of an abstract class.",
      "module": "abc"
    },
    "commonprefix": {
      "signature": "(m)",
      "doc": "Given a list of pathnames, returns the longest common leading component",
      "module": "posixpath"
    },
    "exists": {
      "signature": "(path)",
      "doc": "Test whether a path exists.  Returns False for broken symbolic links",
      "module": "posixpath"
    },
    "getatime": {
      "signature": "(filename)",
      "doc": "Return the last access time of a file, reported by os.stat().",
      "module": "posixpath"
    },
    "getctime": {
      "signature": "(filename)",
      "doc": "Return the metadata change time of a file, reported by os.stat().",
      "module": "posixpath"
    },
    "getmtime": {
      "signature": "(filename)",
      "doc": "Return the last modification time of a file, reported by os.stat().",
      "module": "posixpath"
    },
    "getsize": {
      "signature": "(filename)",
      "doc": "Return the size of a file, reported by os.stat().",
      "module": "posixpath"
    },
    "isdir": {
      "signature": "(s)",
      "doc": "Return true if the pathname refers to an existing directory.",
      "module": "posixpath"
    },
    "isfile": {
      "signature": "(path)",
      "doc": "Test whether a path is a regular file",
      "module": "posixpath"
    },
    "samefile": {
      "signature": "(f1, f2)",
      "doc": "Test whether two pathnames reference the same actual file or directory",
      "module": "posixpath"
    },
    "sameopenfile": {
      "signature": "(fp1, fp2)",
      "doc": "Test whether two open file objects reference the same file",
      "module": "posixpath"
    },
    "samestat": {
      "signature": "(s1, s2)",
      "doc": "Test whether two stat buffers reference the same file",
      "module": "posixpath"
    },
    "abspath": {
      "signature": "(path)",
      "doc": "Return an absolute path.",
      "module": "posixpath"
    },
    "basename": {
      "signature": "(p)",
      "doc": "Returns the final component of a pathname",
      "module": "posixpath"
    },
    "commonpath": {
      "signature": "(paths)",
      "doc": "Given a sequence of path names, returns the longest common sub-path.",
      "module": "posixpath"
    },
    "dirname": {
      "signature": "(p)",
      "doc": "Returns the directory component of a pathname",
      "module": "posixpath"
    },
    "expanduser": {
      "signature": "(path)",
      "doc": "Expand ~ and ~user constructions.  If user or $HOME is unknown,",
      "module": "posixpath"
    },
    "expandvars": {
      "signature": "(path)",
      "doc": "Expand shell variables of form $var and ${var}.  Unknown variables",
      "module": "posixpath"
    },
    "isabs": {
      "signature": "(s)",
      "doc": "Test whether a path is absolute",
      "module": "posixpath"
    },
    "islink": {
      "signature": "(path)",
      "doc": "Test whether a path is a symbolic link",
      "module": "posixpath"
    },
    "ismount": {
      "signature": "(path)",
      "doc": "Test whether a path is a mount point",
      "module": "posixpath"
    },
    "join": {
      "signature": "(a, *p)",
      "doc": "Join two or more pathname components, inserting '/' as needed.",
      "module": "posixpath"
    },
    "lexists": {
      "signature": "(path)",
      "doc": "Test whether a path exists.  Returns True for broken symbolic links",
      "module": "posixpath"
    },
    "normcase": {
      "signature": "(s)",
      "doc": "Normalize case of pathname.  Has no effect under Posix",
      "module": "posixpath"
    },
    "normpath": {
      "signature": "(path)",
      "doc": "Normalize path, eliminating double slashes, etc.",
      "module": "posixpath"
    },
    "realpath": {
      "signature": "(filename, *, strict=False)",
      "doc": "Return the canonical path of the specified filename, eliminating any",
      "module": "posixpath"
    },
    "relpath": {
      "signature": "(path, start=None)",
      "doc": "Return a relative version of a path",
      "module": "posixpath"
    },
    "split": {
      "signature": "(p)",
      "doc": "Split a pathname.  Returns tuple \"(head, tail)\" where \"tail\" is",
      "module": "posixpath"
    },
    "splitdrive": {
      "signature": "(p)",
      "doc": "Split a pathname into drive and path. On Posix, drive is always",
      "module": "posixpath"
    },
    "splitext": {
      "signature": "(p)",
      "doc": "Split the extension from a pathname.",
      "module": "posixpath"
    },
    "add_dll_directory": {
      "signature": "(path)",
      "doc": "Add a path to the DLL search path.",
      "module": "os"
    },
    "execl": {
      "signature": "(file, *args)",
      "doc": "execl(file, *args)",
      "module": "os"
    },
    "execle": {
      "signature": "(file, *args)",
      "doc": "execle(file, *args, env)",
      "module": "os"
    },
    "execlp": {
      "signature": "(file, *args)",
      "doc": "execlp(file, *args)",
      "module": "os"
    },
    "execlpe": {
      "signature": "(file, *args)",
      "doc": "execlpe(file, *args, env)",
      "module": "os"
    },
    "execvp": {
      "signature": "(file, args)",
      "doc": "execvp(file, args)",
      "module": "os"
    },
    "execvpe": {
      "signature": "(file, args, env)",
      "doc": "execvpe(file, args, env)",
      "module": "os"
    },
    "fdopen": {
      "signature": "(fd, mode='r', buffering=-1, encoding=None, *args, **kwargs)",
      "doc": "",
      "module": "os"
    },
    "fsdecode": {
      "signature": "(filename)",
      "doc": "Decode filename (an os.PathLike, bytes, or str) from the filesystem",
      "module": "os"
    },
    "fsencode": {
      "signature": "(filename)",
      "doc": "Encode filename (an os.PathLike, bytes, or str) to the filesystem",
      "module": "os"
    },
    "get_exec_path": {
      "signature": "(env=None)",
      "doc": "Returns the sequence of directories that will be searched for the",
      "module": "os"
    },
    "getenv": {
      "signature": "(key, default=None)",
      "doc": "Get an environment variable, return None if it doesn't exist.",
      "module": "os"
    },
    "makedirs": {
      "signature": "(name, mode=511, exist_ok=False)",
      "doc": "makedirs(name [, mode=0o777][, exist_ok=False])",
      "module": "os"
    },
    "popen": {
      "signature": "(cmd, mode='r', buffering=-1)",
      "doc": "",
      "module": "os"
    },
    "removedirs": {
      "signature": "(name)",
      "doc": "removedirs(name)",
      "module": "os"
    },
    "renames": {
      "signature": "(old, new)",
      "doc": "renames(old, new)",
      "module": "os"
    },
    "spawnl": {
      "signature": "(mode, file, *args)",
      "doc": "spawnl(mode, file, *args) -> integer",
      "module": "os"
    },
    "spawnle": {
      "signature": "(mode, file, *args)",
      "doc": "spawnle(mode, file, *args, env) -> integer",
      "module": "os"
    },
    "walk": {
      "signature": "(self)",
      "doc": "Walk over the message tree, yielding each subpart.",
      "module": "email.iterators"
    },
    "coroutine": {
      "signature": "(func)",
      "doc": "Convert regular generator function to a coroutine.",
      "module": "types"
    },
    "new_class": {
      "signature": "(name, bases=(), kwds=None, exec_body=None)",
      "doc": "Create a class object dynamically using the appropriate metaclass.",
      "module": "types"
    },
    "prepare_class": {
      "signature": "(name, bases=(), kwds=None)",
      "doc": "Call the __prepare__ method of the appropriate metaclass.",
      "module": "types"
    },
    "resolve_bases": {
      "signature": "(bases)",
      "doc": "Resolve MRO entries dynamically as specified by PEP 560.",
      "module": "types"
    },
    "unique": {
      "signature": "(enumeration)",
      "doc": "",
      "module": "enum"
    },
    "expand_template": {
      "signature": "(template, match)",
      "doc": "",
      "module": "sre_parse"
    },
    "fix_flags": {
      "signature": "(src, flags)",
      "doc": "",
      "module": "sre_parse"
    },
    "parse": {
      "signature": "(fp=None, environ=environ({'ACTIONS_RUNNER_ACTION_ARCHIVE_CACHE': 'C:\\\\actionarchivecache\\\\', 'AGENT_TOOLSDIRECTORY': 'C:\\\\hostedtoolcache\\\\windows', 'ALLUSERSPROFILE': 'C:\\\\ProgramData', 'ANDROID_HOME': 'C:\\\\Android\\\\android-sdk', 'ANDROID_NDK': 'C:\\\\Android\\\\android-sdk\\\\ndk\\\\27.2.12479018', 'ANDROID_NDK_HOME': 'C:\\\\Android\\\\android-sdk\\\\ndk\\\\27.2.12479018', 'ANDROID_NDK_LATEST_HOME': 'C:\\\\Android\\\\android-sdk\\\\ndk\\\\27.2.12479018', 'ANDROID_NDK_ROOT': 'C:\\\\Android\\\\android-sdk\\\\ndk\\\\27.2.12479018', 'ANDROID_SDK_ROOT': 'C:\\\\Android\\\\android-sdk', 'ANT_HOME': 'C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\ant\\\\tools\\\\apache-ant-1.10.14', 'APPDATA': 'C:\\\\Users\\\\runneradmin\\\\AppData\\\\Roaming', 'AZURE_CONFIG_DIR': 'C:\\\\azureCli', 'AZURE_DEVOPS_CACHE_DIR': 'C:\\\\azureDevOpsCli\\\\cache', 'AZURE_EXTENSION_DIR': 'C:\\\\Program Files\\\\Common Files\\\\AzureCliExtensionDirectory', 'AZ_DEVOPS_GLOBAL_CONFIG_DIR': 'C:\\\\azureDevOpsCli', 'CABAL_DIR': 'C:\\\\cabal', 'CHOCOLATEYINSTALL': 'C:\\\\ProgramData\\\\chocolatey', 'CHROMEWEBDRIVER': 'C:\\\\SeleniumWebDrivers\\\\ChromeDriver', 'CI': 'true', 'COBERTURA_HOME': 'C:\\\\cobertura-2.1.1', 'COMMONPROGRAMFILES': 'C:\\\\Program Files\\\\Common Files', 'COMMONPROGRAMFILES(X86)': 'C:\\\\Program Files (x86)\\\\Common Files', 'COMMONPROGRAMW6432': 'C:\\\\Program Files\\\\Common Files', 'COMPUTERNAME': 'fv-az688-556', 'COMSPEC': 'C:\\\\Windows\\\\system32\\\\cmd.exe', 'CONDA': 'C:\\\\Miniconda', 'DEPLOYMENT_BASEPATH': 'C:\\\\actions', 'DOTNET_MULTILEVEL_LOOKUP': '0', 'DOTNET_NOLOGO': '1', 'DOTNET_SKIP_FIRST_TIME_EXPERIENCE': '1', 'DRIVERDATA': 'C:\\\\Windows\\\\System32\\\\Drivers\\\\DriverData', 'EDGEWEBDRIVER': 'C:\\\\SeleniumWebDrivers\\\\EdgeDriver', 'GCM_INTERACTIVE': 'Never', 'GECKOWEBDRIVER': 'C:\\\\SeleniumWebDrivers\\\\GeckoDriver', 'GHCUP_INSTALL_BASE_PREFIX': 'C:\\\\', 'GHCUP_MSYS2': 'C:\\\\msys64', 'GITHUB_ACTION': '__run_2', 'GITHUB_ACTIONS': 'true', 'GITHUB_ACTION_REF': '', 'GITHUB_ACTION_REPOSITORY': '', 'GITHUB_ACTOR': 'Tb1281', 'GITHUB_ACTOR_ID': '96616508', 'GITHUB_API_URL': 'https://api.github.com', 'GITHUB_BASE_REF': '', 'GITHUB_ENV': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\set_env_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_EVENT_NAME': 'workflow_dispatch', 'GITHUB_EVENT_PATH': 'D:\\\\a\\\\_temp\\\\_github_workflow\\\\event.json', 'GITHUB_GRAPHQL_URL': 'https://api.github.com/graphql', 'GITHUB_HEAD_REF': '', 'GITHUB_JOB': 'download_and_run', 'GITHUB_OUTPUT': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\set_output_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_PATH': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\add_path_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_REF': 'refs/heads/main', 'GITHUB_REF_NAME': 'main', 'GITHUB_REF_PROTECTED': 'false', 'GITHUB_REF_TYPE': 'branch', 'GITHUB_REPOSITORY': 'Tb1281/eud_draft_parser', 'GITHUB_REPOSITORY_ID': '894892658', 'GITHUB_REPOSITORY_OWNER': 'Tb1281', 'GITHUB_REPOSITORY_OWNER_ID': '96616508', 'GITHUB_RETENTION_DAYS': '90', 'GITHUB_RUN_ATTEMPT': '1', 'GITHUB_RUN_ID': '12061405809', 'GITHUB_RUN_NUMBER': '21', 'GITHUB_SERVER_URL': 'https://github.com', 'GITHUB_SHA': 'f063bfe49187dd4de9c341b24a010a601ebc89b5', 'GITHUB_STATE': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\save_state_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_STEP_SUMMARY': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\step_summary_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_TRIGGERING_ACTOR': 'Tb1281', 'GITHUB_WORKFLOW': 'Sync and Run Other Repo Releases', 'GITHUB_WORKFLOW_REF': 'Tb1281/eud_draft_parser/.github/workflows/sync.yaml@refs/heads/main', 'GITHUB_WORKFLOW_SHA': 'f063bfe49187dd4de9c341b24a010a601ebc89b5', 'GITHUB_WORKSPACE': 'D:\\\\a\\\\eud_draft_parser\\\\eud_draft_parser', 'GOROOT_1_20_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.20.14\\\\x64', 'GOROOT_1_21_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.21.13\\\\x64', 'GOROOT_1_22_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.22.9\\\\x64', 'GOROOT_1_23_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.23.3\\\\x64', 'GRADLE_HOME': 'C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\gradle\\\\tools\\\\gradle-8.11.1', 'HOMEDRIVE': 'C:', 'HOMEPATH': '\\\\Users\\\\runneradmin', 'IEWEBDRIVER': 'C:\\\\SeleniumWebDrivers\\\\IEDriver', 'IMAGEOS': 'win22', 'IMAGEVERSION': '20241125.1.0', 'JAVA_HOME': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\8.0.432-6\\\\x64', 'JAVA_HOME_11_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\11.0.25-9\\\\x64', 'JAVA_HOME_17_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\17.0.13-11\\\\x64', 'JAVA_HOME_21_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\21.0.5-11.0\\\\x64', 'JAVA_HOME_8_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\8.0.432-6\\\\x64', 'LOCALAPPDATA': 'C:\\\\Users\\\\runneradmin\\\\AppData\\\\Local', 'LOGONSERVER': '\\\\\\\\fv-az688-556', 'M2': 'C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\maven\\\\apache-maven-3.8.7\\\\bin', 'M2_REPO': 'C:\\\\ProgramData\\\\m2', 'MAVEN_OPTS': '-Xms256m', 'NPM_CONFIG_PREFIX': 'C:\\\\npm\\\\prefix', 'NUMBER_OF_PROCESSORS': '2', 'OS': 'Windows_NT', 'PATH': 'C:\\\\Program Files\\\\PowerShell\\\\7;C:\\\\Program Files\\\\MongoDB\\\\Server\\\\5.0\\\\bin;C:\\\\aliyun-cli;C:\\\\vcpkg;C:\\\\Program Files (x86)\\\\NSIS\\\\;C:\\\\tools\\\\zstd;C:\\\\Program Files\\\\Mercurial\\\\;C:\\\\hostedtoolcache\\\\windows\\\\stack\\\\3.1.1\\\\x64;C:\\\\cabal\\\\bin;C:\\\\\\\\ghcup\\\\bin;C:\\\\mingw64\\\\bin;C:\\\\Program Files\\\\dotnet;C:\\\\Program Files\\\\MySQL\\\\MySQL Server 8.0\\\\bin;C:\\\\Program Files\\\\R\\\\R-4.4.2\\\\bin\\\\x64;C:\\\\SeleniumWebDrivers\\\\GeckoDriver;C:\\\\SeleniumWebDrivers\\\\EdgeDriver\\\\;C:\\\\SeleniumWebDrivers\\\\ChromeDriver;C:\\\\Program Files (x86)\\\\sbt\\\\bin;C:\\\\Program Files (x86)\\\\GitHub CLI;C:\\\\Program Files\\\\Git\\\\bin;C:\\\\Program Files (x86)\\\\pipx_bin;C:\\\\npm\\\\prefix;C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.21.13\\\\x64\\\\bin;C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\3.9.13\\\\x64\\\\Scripts;C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\3.9.13\\\\x64;C:\\\\hostedtoolcache\\\\windows\\\\Ruby\\\\3.0.7\\\\x64\\\\bin;C:\\\\Program Files\\\\OpenSSL\\\\bin;C:\\\\tools\\\\kotlinc\\\\bin;C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\8.0.432-6\\\\x64\\\\bin;C:\\\\Program Files\\\\ImageMagick-7.1.1-Q16-HDRI;C:\\\\Program Files\\\\Microsoft SDKs\\\\Azure\\\\CLI2\\\\wbin;C:\\\\ProgramData\\\\kind;C:\\\\ProgramData\\\\Chocolatey\\\\bin;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Windows\\\\System32\\\\OpenSSH\\\\;C:\\\\Program Files\\\\dotnet\\\\;C:\\\\Program Files\\\\PowerShell\\\\7\\\\;C:\\\\Program Files\\\\Microsoft\\\\Web Platform Installer\\\\;C:\\\\Program Files\\\\TortoiseSVN\\\\bin;C:\\\\Program Files\\\\Microsoft SQL Server\\\\Client SDK\\\\ODBC\\\\170\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\150\\\\Tools\\\\Binn\\\\;C:\\\\Program Files (x86)\\\\Windows Kits\\\\10\\\\Windows Performance Toolkit\\\\;C:\\\\Program Files (x86)\\\\WiX Toolset v3.14\\\\bin;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\DTS\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\140\\\\DTS\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\150\\\\DTS\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\160\\\\DTS\\\\Binn\\\\;C:\\\\Strawberry\\\\c\\\\bin;C:\\\\Strawberry\\\\perl\\\\site\\\\bin;C:\\\\Strawberry\\\\perl\\\\bin;C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\pulumi\\\\tools\\\\Pulumi\\\\bin;C:\\\\Program Files\\\\CMake\\\\bin;C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\maven\\\\apache-maven-3.8.7\\\\bin;C:\\\\Program Files\\\\Microsoft Service Fabric\\\\bin\\\\Fabric\\\\Fabric.Code;C:\\\\Program Files\\\\Microsoft SDKs\\\\Service Fabric\\\\Tools\\\\ServiceFabricLocalClusterManager;C:\\\\Program Files\\\\nodejs\\\\;C:\\\\Program Files\\\\Git\\\\cmd;C:\\\\Program Files\\\\Git\\\\mingw64\\\\bin;C:\\\\Program Files\\\\Git\\\\usr\\\\bin;C:\\\\Program Files\\\\GitHub CLI\\\\;c:\\\\tools\\\\php;C:\\\\Program Files (x86)\\\\sbt\\\\bin;C:\\\\Program Files\\\\Amazon\\\\AWSCLIV2\\\\;C:\\\\Program Files\\\\Amazon\\\\SessionManagerPlugin\\\\bin\\\\;C:\\\\Program Files\\\\Amazon\\\\AWSSAMCLI\\\\bin\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\LLVM\\\\bin;C:\\\\Users\\\\runneradmin\\\\.dotnet\\\\tools;C:\\\\Users\\\\runneradmin\\\\.cargo\\\\bin;C:\\\\Users\\\\runneradmin\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps', 'PATHEXT': '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.CPL', 'PERFLOG_LOCATION_SETTING': 'RUNNER_PERFLOG', 'PGBIN': 'C:\\\\Program Files\\\\PostgreSQL\\\\14\\\\bin', 'PGDATA': 'C:\\\\Program Files\\\\PostgreSQL\\\\14\\\\data', 'PGPASSWORD': 'root', 'PGROOT': 'C:\\\\Program Files\\\\PostgreSQL\\\\14', 'PGUSER': 'postgres', 'PHPROOT': 'c:\\\\tools\\\\php', 'PIPX_BIN_DIR': 'C:\\\\Program Files (x86)\\\\pipx_bin', 'PIPX_HOME': 'C:\\\\Program Files (x86)\\\\pipx', 'POWERSHELL_DISTRIBUTION_CHANNEL': 'GitHub-Actions-win22', 'POWERSHELL_UPDATECHECK': 'Off', 'PROCESSOR_ARCHITECTURE': 'AMD64', 'PROCESSOR_IDENTIFIER': 'AMD64 Family 25 Model 1 Stepping 1, AuthenticAMD', 'PROCESSOR_LEVEL': '25', 'PROCESSOR_REVISION': '0101', 'PROGRAMDATA': 'C:\\\\ProgramData', 'PROGRAMFILES': 'C:\\\\Program Files', 'PROGRAMFILES(X86)': 'C:\\\\Program Files (x86)', 'PROGRAMW6432': 'C:\\\\Program Files', 'PROMPT': '$P$G', 'PSMODULEANALYSISCACHEPATH': 'C:\\\\PSModuleAnalysisCachePath\\\\ModuleAnalysisCache', 'PSMODULEPATH': 'C:\\\\Users\\\\runneradmin\\\\Documents\\\\PowerShell\\\\Modules;C:\\\\Program Files\\\\PowerShell\\\\Modules;c:\\\\program files\\\\powershell\\\\7\\\\Modules;C:\\\\\\\\Modules\\\\azurerm_2.1.0;C:\\\\\\\\Modules\\\\azure_2.1.0;C:\\\\Users\\\\packer\\\\Documents\\\\WindowsPowerShell\\\\Modules;C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\Windows\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\Tools\\\\PowerShell\\\\Modules\\\\', 'PUBLIC': 'C:\\\\Users\\\\Public', 'RTOOLS44_HOME': 'C:\\\\rtools44', 'RUNNER_ARCH': 'X64', 'RUNNER_ENVIRONMENT': 'github-hosted', 'RUNNER_NAME': 'GitHub Actions 9', 'RUNNER_OS': 'Windows', 'RUNNER_PERFLOG': 'C:\\\\actions\\\\perflog', 'RUNNER_TEMP': 'D:\\\\a\\\\_temp', 'RUNNER_TOOL_CACHE': 'C:\\\\hostedtoolcache\\\\windows', 'RUNNER_TRACKING_ID': 'github_090bc668-8081-433b-9fac-107b5217c587', 'RUNNER_WORKSPACE': 'D:\\\\a\\\\eud_draft_parser', 'SBT_HOME': 'C:\\\\Program Files (x86)\\\\sbt\\\\', 'SELENIUM_JAR_PATH': 'C:\\\\selenium\\\\selenium-server.jar', 'STATS_D': 'true', 'STATS_D_D': 'true', 'STATS_D_TC': 'true', 'STATS_EXT': 'true', 'STATS_EXTP': 'https://provjobdprod.z13.web.core.windows.net/settings/provjobdsettings-latest/provjobd.data', 'STATS_PIP': 'false', 'STATS_RDCL': 'true', 'STATS_TRP': 'true', 'STATS_UE': 'true', 'STATS_V3PS': 'true', 'STATS_VMD': 'true', 'STATS_VMFE': 'true', 'SYSTEMDRIVE': 'C:', 'SYSTEMROOT': 'C:\\\\Windows', 'TEMP': 'C:\\\\Users\\\\RUNNER~1\\\\AppData\\\\Local\\\\Temp', 'TMP': 'C:\\\\Users\\\\RUNNER~1\\\\AppData\\\\Local\\\\Temp', 'USERDOMAIN': 'fv-az688-556', 'USERDOMAIN_ROAMINGPROFILE': 'fv-az688-556', 'USERNAME': 'runneradmin', 'USERPROFILE': 'C:\\\\Users\\\\runneradmin', 'VCPKG_INSTALLATION_ROOT': 'C:\\\\vcpkg', 'WINDIR': 'C:\\\\Windows', 'WIX': 'C:\\\\Program Files (x86)\\\\WiX Toolset v3.14\\\\'}), keep_blank_values=0, strict_parsing=0, separator='&')",
      "doc": "",
      "module": "cgi"
    },
    "parse_template": {
      "signature": "(source, state)",
      "doc": "",
      "module": "sre_parse"
    },
    "compile": {
      "signature": "(pattern, flags=0)",
      "doc": "Compile a regular expression pattern, returning a Pattern object.",
      "module": "re"
    },
    "dis": {
      "signature": "(x=None, *, file=None, depth=None)",
      "doc": "Disassemble classes, methods, functions, and other compiled objects.",
      "module": "dis"
    },
    "isstring": {
      "signature": "(obj)",
      "doc": "",
      "module": "sre_compile"
    },
    "recursive_repr": {
      "signature": "(fillvalue='...')",
      "doc": "Decorator to make a repr function return fillvalue for a recursive call",
      "module": "functools"
    },
    "namedtuple": {
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "doc": "Returns a new subclass of tuple with named fields.",
      "module": "pkgutil"
    },
    "cache": {
      "signature": "(user_function, /)",
      "doc": "Simple lightweight unbounded cache.  Sometimes called \"memoize\".",
      "module": "functools"
    },
    "lru_cache": {
      "signature": "(maxsize=128, typed=False)",
      "doc": "Least-recently-used cache decorator.",
      "module": "functools"
    },
    "singledispatch": {
      "signature": "(func)",
      "doc": "Single-dispatch generic function decorator.",
      "module": "functools"
    },
    "total_ordering": {
      "signature": "(cls)",
      "doc": "Class decorator that fills in missing ordering methods",
      "module": "functools"
    },
    "update_wrapper": {
      "signature": "(wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))",
      "doc": "Update a wrapper function to look like the wrapped function",
      "module": "functools"
    },
    "wraps": {
      "signature": "(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))",
      "doc": "Decorator factory to apply update_wrapper() to a wrapper function",
      "module": "contextlib"
    },
    "add_extension": {
      "signature": "(module, name, code)",
      "doc": "Register an extension code.",
      "module": "copyreg"
    },
    "clear_extension_cache": {
      "signature": "()",
      "doc": "",
      "module": "copyreg"
    },
    "constructor": {
      "signature": "(object)",
      "doc": "",
      "module": "copyreg"
    },
    "pickle": {
      "signature": "(ob_type, pickle_function, constructor_ob=None)",
      "doc": "",
      "module": "copyreg"
    },
    "pickle_complex": {
      "signature": "(c)",
      "doc": "",
      "module": "copyreg"
    },
    "pickle_union": {
      "signature": "(obj)",
      "doc": "",
      "module": "copyreg"
    },
    "remove_extension": {
      "signature": "(module, name, code)",
      "doc": "Unregister an extension code.  For testing only.",
      "module": "copyreg"
    },
    "escape": {
      "signature": "(s, quote=True)",
      "doc": "",
      "module": "html"
    },
    "findall": {
      "signature": "(pattern, string, flags=0)",
      "doc": "Return a list of all non-overlapping matches in the string.",
      "module": "re"
    },
    "finditer": {
      "signature": "(pattern, string, flags=0)",
      "doc": "Return an iterator over all non-overlapping matches in the",
      "module": "re"
    },
    "fullmatch": {
      "signature": "(pattern, string, flags=0)",
      "doc": "Try to apply the pattern to all of the string, returning",
      "module": "re"
    },
    "match": {
      "signature": "(pattern, string, flags=0)",
      "doc": "Try to apply the pattern at the start of the string, returning",
      "module": "re"
    },
    "purge": {
      "signature": "()",
      "doc": "Clear the regular expression caches",
      "module": "re"
    },
    "search": {
      "signature": "(pattern, string, flags=0)",
      "doc": "Scan through string looking for a match to the pattern, returning",
      "module": "re"
    },
    "sub": {
      "signature": "(pattern, repl, string, count=0, flags=0)",
      "doc": "Return the string obtained by replacing the leftmost",
      "module": "re"
    },
    "subn": {
      "signature": "(pattern, repl, string, count=0, flags=0)",
      "doc": "Return a 2-tuple containing (new_string, number).",
      "module": "re"
    },
    "template": {
      "signature": "(pattern, flags=0)",
      "doc": "Compile a template pattern, returning a Pattern object",
      "module": "re"
    },
    "capwords": {
      "signature": "(s, sep=None)",
      "doc": "capwords(s [,sep]) -> string",
      "module": "string"
    },
    "module_from_spec": {
      "signature": "(spec)",
      "doc": "Create a module based on the provided spec.",
      "module": "importlib.util"
    },
    "spec_from_loader": {
      "signature": "(name, loader, *, origin=None, is_package=None)",
      "doc": "Return a module spec based on various loader methods.",
      "module": "importlib.util"
    },
    "cache_from_source": {
      "signature": "(path, debug_override=None, *, optimization=None)",
      "doc": "Given the path to a .py file, return the path to its .pyc file.",
      "module": "importlib.util"
    },
    "decode_source": {
      "signature": "(source_bytes)",
      "doc": "Decode bytes representing source code and return the string.",
      "module": "importlib.util"
    },
    "source_from_cache": {
      "signature": "(path)",
      "doc": "Given the path to a .pyc. file, return the path to its .py file.",
      "module": "importlib.util"
    },
    "spec_from_file_location": {
      "signature": "(name, location=None, *, loader=None, submodule_search_locations=<object object at 0x0000014FB25B80C0>)",
      "doc": "Return a module spec based on a file location.",
      "module": "importlib.util"
    },
    "filterwarnings": {
      "signature": "(action, message='', category=<class 'Warning'>, module='', lineno=0, append=False)",
      "doc": "Insert an entry into the list of warnings filters (at the front).",
      "module": "warnings"
    },
    "formatwarning": {
      "signature": "(message, category, filename, lineno, line=None)",
      "doc": "Function to format a warning the standard way.",
      "module": "warnings"
    },
    "resetwarnings": {
      "signature": "()",
      "doc": "Clear the list of warning filters, so that no filters are active.",
      "module": "warnings"
    },
    "showwarning": {
      "signature": "(message, category, filename, lineno, file=None, line=None)",
      "doc": "Hook to write a warning to a file; replace if you like.",
      "module": "warnings"
    },
    "simplefilter": {
      "signature": "(action, category=<class 'Warning'>, lineno=0, append=False)",
      "doc": "Insert a simple entry into the list of warnings filters (at the front).",
      "module": "warnings"
    },
    "find_loader": {
      "signature": "(fullname)",
      "doc": "Find a \"loader\" object for fullname",
      "module": "pkgutil"
    },
    "import_module": {
      "signature": "(name, package=None)",
      "doc": "Import a module.",
      "module": "importlib"
    },
    "invalidate_caches": {
      "signature": "()",
      "doc": "Call the invalidate_caches() method on all meta path finders stored in",
      "module": "importlib"
    },
    "reload": {
      "signature": "(module)",
      "doc": "Reload the module and return it.",
      "module": "importlib"
    },
    "all_suffixes": {
      "signature": "()",
      "doc": "Returns a list of all recognized module suffixes for this process",
      "module": "importlib.machinery"
    },
    "expand_makefile_vars": {
      "signature": "(s, vars)",
      "doc": "Expand Makefile-style variables -- \"${foo}\" or \"$(foo)\" -- in",
      "module": "sysconfig"
    },
    "get_config_h_filename": {
      "signature": "()",
      "doc": "Return the path of pyconfig.h.",
      "module": "sysconfig"
    },
    "get_config_var": {
      "signature": "(name)",
      "doc": "Return the value of a single variable using the dictionary returned by",
      "module": "sysconfig"
    },
    "get_config_vars": {
      "signature": "(*args)",
      "doc": "With no arguments, return a dictionary of all configuration",
      "module": "sysconfig"
    },
    "get_default_scheme": {
      "signature": "()",
      "doc": "",
      "module": "sysconfig"
    },
    "get_makefile_filename": {
      "signature": "()",
      "doc": "Return the path of the Makefile.",
      "module": "sysconfig"
    },
    "get_path": {
      "signature": "(name, scheme='nt', vars=None, expand=True)",
      "doc": "Return a path corresponding to the scheme.",
      "module": "sysconfig"
    },
    "get_path_names": {
      "signature": "()",
      "doc": "Return a tuple containing the paths names.",
      "module": "sysconfig"
    },
    "get_paths": {
      "signature": "(scheme='nt', vars=None, expand=True)",
      "doc": "Return a mapping containing an install scheme.",
      "module": "sysconfig"
    },
    "get_platform": {
      "signature": "()",
      "doc": "Return a string that identifies the current platform.",
      "module": "sysconfig"
    },
    "get_preferred_scheme": {
      "signature": "(key)",
      "doc": "",
      "module": "sysconfig"
    },
    "get_python_version": {
      "signature": "()",
      "doc": "",
      "module": "sysconfig"
    },
    "get_scheme_names": {
      "signature": "()",
      "doc": "Return a tuple containing the schemes names.",
      "module": "sysconfig"
    },
    "is_python_build": {
      "signature": "(check_home=False)",
      "doc": "",
      "module": "sysconfig"
    },
    "parse_config_h": {
      "signature": "(fp, vars=None)",
      "doc": "Parse a config.h-style file.",
      "module": "sysconfig"
    },
    "asynccontextmanager": {
      "signature": "(func)",
      "doc": "@asynccontextmanager decorator.",
      "module": "contextlib"
    },
    "contextmanager": {
      "signature": "(func)",
      "doc": "@contextmanager decorator.",
      "module": "importlib.util"
    },
    "NamedTuple": {
      "signature": "(typename, fields=None, /, **kwargs)",
      "doc": "Typed version of namedtuple.",
      "module": "typing"
    },
    "TypedDict": {
      "signature": "(typename, fields=None, /, *, total=True, **kwargs)",
      "doc": "A simple typed namespace. At runtime it is equivalent to a plain dict.",
      "module": "typing"
    },
    "cast": {
      "signature": "(typ, val)",
      "doc": "Cast a value to a type.",
      "module": "eudplib.offsetmap.csprite"
    },
    "final": {
      "signature": "(f)",
      "doc": "A decorator to indicate final methods and final classes.",
      "module": "typing"
    },
    "get_args": {
      "signature": "(tp)",
      "doc": "Get type arguments with all substitutions performed.",
      "module": "typing"
    },
    "get_origin": {
      "signature": "(tp)",
      "doc": "Get the unsubscripted version of a type.",
      "module": "typing"
    },
    "get_type_hints": {
      "signature": "(obj, globalns=None, localns=None, include_extras=False)",
      "doc": "Return type hints for an object.",
      "module": "typing"
    },
    "is_typeddict": {
      "signature": "(tp)",
      "doc": "Check if an annotation is a TypedDict class",
      "module": "typing"
    },
    "no_type_check": {
      "signature": "(arg)",
      "doc": "Decorator to indicate that annotations are not type hints.",
      "module": "typing"
    },
    "no_type_check_decorator": {
      "signature": "(decorator)",
      "doc": "Decorator to give another decorator the @no_type_check effect.",
      "module": "typing"
    },
    "overload": {
      "signature": "(func)",
      "doc": "Decorator for overloaded functions/methods.",
      "module": "eudplib.trigtrg.runtrigtrg"
    },
    "runtime_checkable": {
      "signature": "(cls)",
      "doc": "Mark a protocol class as a runtime protocol.",
      "module": "typing"
    },
    "run": {
      "signature": "(*popenargs, input=None, capture_output=False, timeout=None, check=False, **kwargs)",
      "doc": "Run command with arguments and return a CompletedProcess instance.",
      "module": "subprocess"
    },
    "RLock": {
      "signature": "(*args, **kwargs)",
      "doc": "Factory function that returns a new reentrant lock.",
      "module": "threading"
    },
    "activeCount": {
      "signature": "()",
      "doc": "Return the number of Thread objects currently alive.",
      "module": "threading"
    },
    "active_count": {
      "signature": "()",
      "doc": "Return the number of Thread objects currently alive.",
      "module": "threading"
    },
    "currentThread": {
      "signature": "()",
      "doc": "Return the current Thread object, corresponding to the caller's thread of control.",
      "module": "threading"
    },
    "current_thread": {
      "signature": "()",
      "doc": "Return the current Thread object, corresponding to the caller's thread of control.",
      "module": "threading"
    },
    "enumerate": {
      "signature": "()",
      "doc": "Return a list of all Thread objects currently alive.",
      "module": "threading"
    },
    "getprofile": {
      "signature": "()",
      "doc": "Get the profiler function as set by threading.setprofile().",
      "module": "threading"
    },
    "gettrace": {
      "signature": "()",
      "doc": "Get the trace function as set by threading.settrace().",
      "module": "threading"
    },
    "main_thread": {
      "signature": "()",
      "doc": "Return the main thread object.",
      "module": "threading"
    },
    "setprofile": {
      "signature": "(func)",
      "doc": "Set a profile function for all threads started from the threading module.",
      "module": "threading"
    },
    "settrace": {
      "signature": "(func)",
      "doc": "Set a trace function for all threads started from the threading module.",
      "module": "threading"
    },
    "getsignal": {
      "signature": "(signalnum)",
      "doc": "Return the current action for the given signal.",
      "module": "signal"
    },
    "signal": {
      "signature": "(signalnum, handler)",
      "doc": "Set the action for the given signal.",
      "module": "signal"
    },
    "valid_signals": {
      "signature": "()",
      "doc": "Return a set of valid signal numbers on this platform.",
      "module": "signal"
    },
    "active_children": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing"
    },
    "current_process": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing"
    },
    "parent_process": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing"
    },
    "signum": {
      "signature": "(value)",
      "doc": "Convert an IntEnum member to a numeric value.",
      "module": "multiprocessing.process"
    },
    "decode_long": {
      "signature": "(data)",
      "doc": "Decode a long from a two's complement little-endian binary string.",
      "module": "pickle"
    },
    "encode_long": {
      "signature": "(x)",
      "doc": "Encode a long to a two's complement little-endian binary string.",
      "module": "pickle"
    },
    "whichmodule": {
      "signature": "(obj, name)",
      "doc": "Find the module an object belong to.",
      "module": "pickle"
    },
    "create_connection": {
      "signature": "(address, timeout=<object object at 0x0000014FB25B8650>, source_address=None)",
      "doc": "Connect to *address* and return the socket object.",
      "module": "ssl"
    },
    "create_server": {
      "signature": "(address, *, family=<AddressFamily.AF_INET: 2>, backlog=None, reuse_port=False, dualstack_ipv6=False)",
      "doc": "Convenience function which creates a SOCK_STREAM type socket",
      "module": "socket"
    },
    "fromfd": {
      "signature": "(fd, family, type, proto=0)",
      "doc": " fromfd(fd, family, type[, proto]) -> socket object",
      "module": "socket"
    },
    "fromshare": {
      "signature": "(info)",
      "doc": " fromshare(info) -> socket object",
      "module": "socket"
    },
    "getaddrinfo": {
      "signature": "(host, port, family=0, type=0, proto=0, flags=0)",
      "doc": "Resolve host and port into list of address info entries.",
      "module": "socket"
    },
    "getfqdn": {
      "signature": "(name='')",
      "doc": "Get fully qualified domain name from name.",
      "module": "socket"
    },
    "has_dualstack_ipv6": {
      "signature": "()",
      "doc": "Return True if the platform supports creating a SOCK_STREAM socket",
      "module": "socket"
    },
    "socketpair": {
      "signature": "(family=<AddressFamily.AF_INET: 2>, type=<SocketKind.SOCK_STREAM: 1>, proto=0)",
      "doc": "socketpair([family[, type[, proto]]]) -> (socket object, socket object)",
      "module": "socket"
    },
    "dump": {
      "signature": "(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)",
      "doc": "",
      "module": "json"
    },
    "duplicate": {
      "signature": "(handle, target_process=None, inheritable=False, *, source_process=None)",
      "doc": "Duplicate a handle.  (target_process is a handle not a pid!)",
      "module": "multiprocessing.reduction"
    },
    "recv_handle": {
      "signature": "(conn)",
      "doc": "Receive a handle over a local connection.",
      "module": "multiprocessing.reduction"
    },
    "send_handle": {
      "signature": "(conn, handle, destination_pid)",
      "doc": "Send a handle over a local connection.",
      "module": "multiprocessing.reduction"
    },
    "steal_handle": {
      "signature": "(source_pid, handle)",
      "doc": "Steal a handle from process identified by source_pid.",
      "module": "multiprocessing.reduction"
    },
    "assert_spawning": {
      "signature": "(obj)",
      "doc": "",
      "module": "multiprocessing.context"
    },
    "get_spawning_popen": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing.context"
    },
    "set_spawning_popen": {
      "signature": "(popen)",
      "doc": "",
      "module": "multiprocessing.context"
    },
    "Catalog": {
      "signature": "(domain, localedir=None, languages=None, class_=None, fallback=False, codeset=['unspecified'])",
      "doc": "",
      "module": "gettext"
    },
    "bind_textdomain_codeset": {
      "signature": "(domain, codeset=None)",
      "doc": "",
      "module": "gettext"
    },
    "bindtextdomain": {
      "signature": "(domain, localedir=None)",
      "doc": "",
      "module": "gettext"
    },
    "c2py": {
      "signature": "(plural)",
      "doc": "Gets a C expression as used in PO files for plural forms and returns a",
      "module": "gettext"
    },
    "dgettext": {
      "signature": "(domain, message)",
      "doc": "",
      "module": "gettext"
    },
    "dngettext": {
      "signature": "(domain, msgid1, msgid2, n)",
      "doc": "",
      "module": "gettext"
    },
    "dnpgettext": {
      "signature": "(domain, context, msgid1, msgid2, n)",
      "doc": "",
      "module": "gettext"
    },
    "dpgettext": {
      "signature": "(domain, context, message)",
      "doc": "",
      "module": "gettext"
    },
    "find": {
      "signature": "(domain, localedir=None, languages=None, all=False)",
      "doc": "",
      "module": "gettext"
    },
    "gettext": {
      "signature": "(message)",
      "doc": "",
      "module": "gettext"
    },
    "install": {
      "signature": "(domain, localedir=None, codeset=['unspecified'], names=None)",
      "doc": "",
      "module": "gettext"
    },
    "ldgettext": {
      "signature": "(domain, message)",
      "doc": "",
      "module": "gettext"
    },
    "ldngettext": {
      "signature": "(domain, msgid1, msgid2, n)",
      "doc": "",
      "module": "gettext"
    },
    "lgettext": {
      "signature": "(message)",
      "doc": "",
      "module": "gettext"
    },
    "lngettext": {
      "signature": "(msgid1, msgid2, n)",
      "doc": "",
      "module": "gettext"
    },
    "ngettext": {
      "signature": "(msgid1, msgid2, n)",
      "doc": "",
      "module": "gettext"
    },
    "npgettext": {
      "signature": "(context, msgid1, msgid2, n)",
      "doc": "",
      "module": "gettext"
    },
    "pgettext": {
      "signature": "(context, message)",
      "doc": "",
      "module": "gettext"
    },
    "textdomain": {
      "signature": "(domain=None)",
      "doc": "",
      "module": "gettext"
    },
    "translation": {
      "signature": "(domain, localedir=None, languages=None, class_=None, fallback=False, codeset=['unspecified'])",
      "doc": "",
      "module": "gettext"
    },
    "atof": {
      "signature": "(string, func=<class 'float'>)",
      "doc": "Parses a string as a float according to the locale settings.",
      "module": "locale"
    },
    "atoi": {
      "signature": "(string)",
      "doc": "Converts a string to an integer according to the locale settings.",
      "module": "locale"
    },
    "currency": {
      "signature": "(val, symbol=True, grouping=False, international=False)",
      "doc": "Formats val according to the currency settings",
      "module": "locale"
    },
    "delocalize": {
      "signature": "(string)",
      "doc": "Parses a string as a normalized number according to the locale settings.",
      "module": "locale"
    },
    "format": {
      "signature": "(cols, colwidth=20, spacing=6)",
      "doc": "Prints multi-column formatting for year calendars",
      "module": "calendar"
    },
    "format_string": {
      "signature": "(f, val, grouping=False, monetary=False)",
      "doc": "Formats a string in the same way that the % formatting would use,",
      "module": "locale"
    },
    "getdefaultlocale": {
      "signature": "(envvars=('LC_ALL', 'LC_CTYPE', 'LANG', 'LANGUAGE'))",
      "doc": " Tries to determine the default locale settings and returns",
      "module": "locale"
    },
    "getlocale": {
      "signature": "(category=2)",
      "doc": " Returns the current setting for the given locale category as",
      "module": "locale"
    },
    "getpreferredencoding": {
      "signature": "(do_setlocale=True)",
      "doc": "Return the charset that the user is likely using.",
      "module": "locale"
    },
    "localeconv": {
      "signature": "()",
      "doc": "Returns numeric and monetary locale-specific parameters.",
      "module": "locale"
    },
    "localize": {
      "signature": "(string, grouping=False, monetary=False)",
      "doc": "Parses a string as locale number according to the locale settings.",
      "module": "locale"
    },
    "normalize": {
      "signature": "(localename)",
      "doc": " Returns a normalized locale code for the given locale",
      "module": "locale"
    },
    "resetlocale": {
      "signature": "(category=0)",
      "doc": " Sets the locale for category to the default setting.",
      "module": "locale"
    },
    "setlocale": {
      "signature": "(category, locale=None)",
      "doc": " Set the locale for the given category.  The locale can be",
      "module": "locale"
    },
    "str": {
      "signature": "(val)",
      "doc": "Convert float to string, taking the locale into account.",
      "module": "locale"
    },
    "b2i1": {
      "signature": "(b: collections.abc.Sequence[int], index: int = 0) -> int",
      "doc": "",
      "module": "eudplib.utils"
    },
    "b2i2": {
      "signature": "(b: collections.abc.Sequence[int], index: int = 0) -> int",
      "doc": "",
      "module": "eudplib.core.mapdata.fixmapdata"
    },
    "b2i4": {
      "signature": "(b: collections.abc.Sequence[int], index: int = 0) -> int",
      "doc": "",
      "module": "eudplib.core.mapdata.stringmap"
    },
    "bits": {
      "signature": "(n: int) -> collections.abc.Iterator[int]",
      "doc": "",
      "module": "eudplib.utils"
    },
    "i2b1": {
      "signature": "(i: int) -> bytes",
      "doc": "",
      "module": "eudplib.utils"
    },
    "i2b2": {
      "signature": "(i: int) -> bytes",
      "doc": "",
      "module": "eudplib.utils"
    },
    "i2b4": {
      "signature": "(i: int) -> bytes",
      "doc": "",
      "module": "eudplib.core.variable.eudlv"
    },
    "ep_assert": {
      "signature": "(statement, message='Assertion failed') -> None",
      "doc": "",
      "module": "eudplib.eudlib.wireframe.wiredata"
    },
    "ep_eprint": {
      "signature": "(*args, **kwargs) -> None",
      "doc": "",
      "module": "eudplib.maprw.savemap"
    },
    "ep_warn": {
      "signature": "(message: str) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.fixmapdata"
    },
    "EUDCreateBlock": {
      "signature": "(name: str, userdata: Any) -> None",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "EUDGetBlockList": {
      "signature": "() -> list[tuple[str, typing.Any]]",
      "doc": "",
      "module": "eudplib.utils"
    },
    "EUDGetLastBlock": {
      "signature": "() -> tuple[str, typing.Any]",
      "doc": "",
      "module": "eudplib.utils"
    },
    "EUDGetLastBlockOfName": {
      "signature": "(name: str) -> tuple[str, typing.Any]",
      "doc": "",
      "module": "eudplib.core.rawtrigger.triggerscope"
    },
    "EUDPeekBlock": {
      "signature": "(name: str) -> tuple[str, typing.Any]",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "EUDPopBlock": {
      "signature": "(name: str) -> tuple[str, typing.Any]",
      "doc": "",
      "module": "eudplib.core.rawtrigger.triggerscope"
    },
    "SetCurrentBlockStruManager": {
      "signature": "(bsm: eudplib.utils.blockstru.BlockStruManager) -> eudplib.utils.blockstru.BlockStruManager",
      "doc": "",
      "module": "eudplib.maprw.injector.applyInjector"
    },
    "Assignable2List": {
      "signature": "(a: Any) -> list",
      "doc": "",
      "module": "eudplib.utils"
    },
    "EPD": {
      "signature": "(p: Any) -> Any",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "FlattenList": {
      "signature": "(l: Any) -> list",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "List2Assignable": {
      "signature": "(l: list[~T]) -> Union[~T, list[~T]]",
      "doc": "",
      "module": "eudplib.core.variable.eudv"
    },
    "RandList": {
      "signature": "(lst: collections.abc.Iterable) -> list",
      "doc": "",
      "module": "eudplib.eudlib.memiof.byterw"
    },
    "SCMD2Text": {
      "signature": "(s: str) -> str",
      "doc": "",
      "module": "eudplib.utils"
    },
    "cachedfunc": {
      "signature": "(user_function, /)",
      "doc": "Simple lightweight unbounded cache.  Sometimes called \"memoize\".",
      "module": "eudplib.utils"
    },
    "find_data_file": {
      "signature": "(filename, file)",
      "doc": "",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "isUnproxyInstance": {
      "signature": "(x: object, cls: type | types.UnionType | tuple['_ClassInfo', ...]) -> bool",
      "doc": "",
      "module": "eudplib.core.eudstruct.vararray"
    },
    "unProxy": {
      "signature": "(x)",
      "doc": "",
      "module": "eudplib.trigtrg.runtrigtrg"
    },
    "UbconvSetEncoding": {
      "signature": "(encoding: str) -> None",
      "doc": "",
      "module": "eudplib.utils.ubconv"
    },
    "b2u": {
      "signature": "(b: str | bytes) -> str",
      "doc": "",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "b2utf8": {
      "signature": "(b: str | bytes) -> str",
      "doc": "",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "u2b": {
      "signature": "(s: str | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "u2utf8": {
      "signature": "(s: str | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "RlocInt": {
      "signature": "(offset: int, rlocmode: int) -> eudplib.core.allocator.rlocint.RlocInt_C",
      "doc": "",
      "module": "eudplib.core"
    },
    "toRlocInt": {
      "signature": "(x: 'int | RlocInt_C') -> eudplib.core.allocator.rlocint.RlocInt_C",
      "doc": "",
      "module": "eudplib.core"
    },
    "Evaluate": {
      "signature": "(x: Union[eudplib.core.allocator.constexpr.ConstExpr, int, eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.constexpr.ConstExpr], eudplib.core.allocator.rlocint.RlocInt_C]) -> eudplib.core.allocator.rlocint.RlocInt_C",
      "doc": "",
      "module": "eudplib.core"
    },
    "IntOrConstExpr": {
      "signature": "(baseobj: eudplib.core.allocator.constexpr.ConstExpr | None, offset: int, rlocmode: int) -> int | eudplib.core.allocator.constexpr.ConstExpr",
      "doc": "",
      "module": "eudplib.core.allocator.constexpr"
    },
    "IsConstExpr": {
      "signature": "(x) -> bool",
      "doc": "",
      "module": "freeze.utils"
    },
    "StackObjects": {
      "signature": "(found_objects: 'list[EUDObject]', dwoccupmap_dict: 'dict[EUDObject, list[int]]', alloctable: 'dict[EUDObject, int]') -> None",
      "doc": "",
      "module": "eudplib.utils.stackobjs"
    },
    "CreateStructPackerData": {
      "signature": "(structformat: str) -> list[int]",
      "doc": "",
      "module": "eudplib.core.allocator.pbuffer"
    },
    "AllocObjects": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.core.allocator.payload"
    },
    "CollectObjects": {
      "signature": "(root: 'EUDObject | Forward') -> None",
      "doc": "",
      "module": "eudplib.core.allocator.payload"
    },
    "CompressPayload": {
      "signature": "(mode: bool) -> None",
      "doc": "",
      "module": "eudplib.core"
    },
    "ConstructPayload": {
      "signature": "() -> eudplib.core.allocator.pbuffer.Payload",
      "doc": "",
      "module": "eudplib.core.allocator.payload"
    },
    "CreatePayload": {
      "signature": "(root: 'EUDObject | Forward') -> eudplib.core.allocator.pbuffer.Payload",
      "doc": "",
      "module": "eudplib.core"
    },
    "GetObjectAddr": {
      "signature": "(obj: 'EUDObject') -> eudplib.core.allocator.rlocint.RlocInt_C",
      "doc": "",
      "module": "eudplib.core"
    },
    "RegisterCreatePayloadCallback": {
      "signature": "(f: collections.abc.Callable) -> None",
      "doc": "",
      "module": "eudplib.maprw.savemap"
    },
    "ShufflePayload": {
      "signature": "(mode: bool) -> None",
      "doc": "",
      "module": "eudplib.core"
    },
    "lprint": {
      "signature": "(text: str, flush: bool = False)",
      "doc": "",
      "module": "eudplib.core.allocator.payload"
    },
    "setPayloadLoggerMode": {
      "signature": "(mode: bool) -> None",
      "doc": "",
      "module": "eudplib.maprw.injector.applyInjector"
    },
    "sectionname_format": {
      "signature": "(sn: str | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.core.mapdata.chktok"
    },
    "GetPlayerInfo": {
      "signature": "(player) -> eudplib.core.mapdata.playerinfo.PlayerInfo",
      "doc": "",
      "module": "eudplib.core"
    },
    "InitPlayerInfo": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "ARRAY": {
      "signature": "(typ, len)",
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "CFUNCTYPE": {
      "signature": "(restype, *argtypes, **kw)",
      "doc": "CFUNCTYPE(restype, *argtypes,",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "DllCanUnloadNow": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "DllGetClassObject": {
      "signature": "(rclsid, riid, ppv)",
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "PYFUNCTYPE": {
      "signature": "(restype, *argtypes)",
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "SetPointerType": {
      "signature": "(pointer, cls)",
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "WINFUNCTYPE": {
      "signature": "(restype, *argtypes, **kw)",
      "doc": "",
      "module": "msgbox"
    },
    "WinError": {
      "signature": "(code=None, descr=None)",
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_buffer": {
      "signature": "(init, size=None)",
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "create_string_buffer": {
      "signature": "(init, size=None)",
      "doc": "create_string_buffer(aBytes) -> character array",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "create_unicode_buffer": {
      "signature": "(init, size=None)",
      "doc": "create_unicode_buffer(aString) -> character array",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "string_at": {
      "signature": "(ptr, size=-1)",
      "doc": "string_at(addr[, size]) -> string",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "wstring_at": {
      "signature": "(ptr, size=-1)",
      "doc": "wstring_at(addr[, size]) -> string",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "PropertyKey": {
      "signature": "(b: bytes, index: int = 0) -> bytes",
      "doc": "",
      "module": "eudplib.core.mapdata.proptable"
    },
    "ApplyPropertyMap": {
      "signature": "(chkt: 'CHK') -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "GetPropertyIndex": {
      "signature": "(prop: eudplib.core.mapdata.unitprp.UnitProperty | bytes) -> int",
      "doc": "",
      "module": "eudplib.core"
    },
    "InitPropertyMap": {
      "signature": "(chkt: 'CHK') -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "DecodeUnitNameAs": {
      "signature": "(e: str) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.tblformat"
    },
    "IgnoreColor": {
      "signature": "(s: bytes) -> bytes | None",
      "doc": "",
      "module": "eudplib.core.mapdata.tblformat"
    },
    "b2in": {
      "signature": "(n: int) -> collections.abc.Callable[[collections.abc.Sequence[int], int], int]",
      "doc": "",
      "module": "eudplib.core.mapdata.tblformat"
    },
    "i2bn": {
      "signature": "(n: int) -> collections.abc.Callable[[int], bytes]",
      "doc": "",
      "module": "eudplib.core.mapdata.tblformat"
    },
    "roundup_by_4": {
      "signature": "(num: int) -> int",
      "doc": "",
      "module": "eudplib.core.mapdata.tblformat"
    },
    "u2bn": {
      "signature": "(n: int) -> collections.abc.Callable[[str | bytes], bytes]",
      "doc": "",
      "module": "eudplib.core.mapdata.tblformat"
    },
    "ApplyStringMap": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "ForceAddString": {
      "signature": "(s: str | bytes) -> int",
      "doc": "",
      "module": "eudplib.eudlib.stringf.strbuffer"
    },
    "GetLocationIndex": {
      "signature": "(l: str | bytes) -> int",
      "doc": "",
      "module": "eudplib.core"
    },
    "GetStringIndex": {
      "signature": "(s: str | bytes) -> int",
      "doc": "",
      "module": "eudplib.core"
    },
    "GetStringMap": {
      "signature": "() -> eudplib.core.mapdata.tblformat.TBL",
      "doc": "",
      "module": "eudplib.maprw.injector.vectorReloc"
    },
    "GetStringSectionName": {
      "signature": "() -> str",
      "doc": "",
      "module": "eudplib.maprw.injector.vectorReloc"
    },
    "GetSwitchIndex": {
      "signature": "(s: str | bytes) -> int",
      "doc": "",
      "module": "eudplib.core"
    },
    "GetUnitIndex": {
      "signature": "(u: str | bytes) -> int",
      "doc": "",
      "module": "eudplib.core"
    },
    "InitStringMap": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "AddListFiles": {
      "signature": "(n: str, f: bytes | None) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "GetChkTokenized": {
      "signature": "() -> eudplib.core.mapdata.chktok.CHK",
      "doc": "",
      "module": "eudplib.core"
    },
    "GetOriginalChkTokenized": {
      "signature": "() -> eudplib.core.mapdata.chktok.CHK",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "GetRawFile": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "InitMapData": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK, rawfile: bytes) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "IsMapdataInitialized": {
      "signature": "() -> bool",
      "doc": "",
      "module": "eudplib.core"
    },
    "IterListFiles": {
      "signature": "() -> collections.abc.Iterator[tuple[str, bytes | None]]",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "UpdateMapData": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mapdata"
    },
    "EncodeAllyStatus": {
      "signature": "(s: '_Unique | int | EUDVariable | ExprProxy[_Unique | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodeComparison": {
      "signature": "(s: '_Unique | int | EUDVariable | ExprProxy[_Unique | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodeCount": {
      "signature": "(s: '_Unique | int | EUDVariable | ExprProxy[_Unique | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodeModifier": {
      "signature": "(s: '_Unique | int | EUDVariable | ExprProxy[_Unique | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodeOrder": {
      "signature": "(s: '_Unique | int | EUDVariable | ExprProxy[_Unique | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodePlayer": {
      "signature": "(s: '_Unique | int | EUDVariable | ConstExpr | ExprProxy[_Unique | int | EUDVariable | ConstExpr | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable | ConstExpr'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodePropState": {
      "signature": "(s: '_Unique | int | EUDVariable | ExprProxy[_Unique | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodeProperty": {
      "signature": "(prop: Union[eudplib.core.mapdata.unitprp.UnitProperty, bytes, eudplib.utils.exprproxy.ExprProxy[eudplib.core.mapdata.unitprp.UnitProperty | bytes]], issueError: bool = False) -> int",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodeResource": {
      "signature": "(s: '_Unique | int | EUDVariable | ExprProxy[_Unique | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodeScore": {
      "signature": "(s: '_Unique | int | EUDVariable | ExprProxy[_Unique | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodeSwitchAction": {
      "signature": "(s: '_Unique | int | EUDVariable | ExprProxy[_Unique | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodeSwitchState": {
      "signature": "(s: '_Unique | int | EUDVariable | ExprProxy[_Unique | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "NextTrigger": {
      "signature": "() -> eudplib.core.allocator.constexpr.Forward",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "PopTriggerScope": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "PushTriggerScope": {
      "signature": "() -> Literal[True]",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "SetNextTrigger": {
      "signature": "(trg: eudplib.core.allocator.constexpr.ConstExpr) -> None",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "Disabled": {
      "signature": "(arg: eudplib.core.rawtrigger.condition.Condition | eudplib.core.rawtrigger.action.Action) -> None",
      "doc": "",
      "module": "eudplib.core"
    },
    "GetTriggerCounter": {
      "signature": "() -> int",
      "doc": "",
      "module": "eudplib.core"
    },
    "merge": {
      "signature": "(*iterables, key=None, reverse=False)",
      "doc": "Merge multiple sorted inputs into a single sorted output.",
      "module": "heapq"
    },
    "nlargest": {
      "signature": "(n, iterable, key=None)",
      "doc": "Find the n largest elements in a dataset.",
      "module": "heapq"
    },
    "nsmallest": {
      "signature": "(n, iterable, key=None)",
      "doc": "Find the n smallest elements in a dataset.",
      "module": "heapq"
    },
    "IS_CHARACTER_JUNK": {
      "signature": "(ch, ws=' \\t')",
      "doc": "",
      "module": "difflib"
    },
    "IS_LINE_JUNK": {
      "signature": "(line, pat=<built-in method match of re.Pattern object at 0x0000014FB2563B40>)",
      "doc": "",
      "module": "difflib"
    },
    "context_diff": {
      "signature": "(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\\n')",
      "doc": "",
      "module": "difflib"
    },
    "diff_bytes": {
      "signature": "(dfunc, a, b, fromfile=b'', tofile=b'', fromfiledate=b'', tofiledate=b'', n=3, lineterm=b'\\n')",
      "doc": "",
      "module": "difflib"
    },
    "get_close_matches": {
      "signature": "(word, possibilities, n=3, cutoff=0.6)",
      "doc": "Use SequenceMatcher to return list of the best \"good enough\" matches.",
      "module": "difflib"
    },
    "ndiff": {
      "signature": "(a, b, linejunk=None, charjunk=<function IS_CHARACTER_JUNK at 0x0000014FB2EF6D40>)",
      "doc": "",
      "module": "difflib"
    },
    "restore": {
      "signature": "(delta, which)",
      "doc": "",
      "module": "difflib"
    },
    "unified_diff": {
      "signature": "(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\\n')",
      "doc": "",
      "module": "difflib"
    },
    "EncodeAIScript": {
      "signature": "(ais: 'str | bytes | int | EUDVariable | ConstExpr | ExprProxy[str | bytes | int | EUDVariable | ConstExpr | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable | ConstExpr'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodeFlingy": {
      "signature": "(flingy: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.core"
    },
    "EncodeIcon": {
      "signature": "(icon: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.core"
    },
    "EncodeImage": {
      "signature": "(image: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.core"
    },
    "EncodeIscript": {
      "signature": "(iscript: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.core"
    },
    "EncodeLocation": {
      "signature": "(loc: 'str | bytes | int | EUDVariable | ConstExpr | ExprProxy[str | bytes | int | EUDVariable | ConstExpr | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable | ConstExpr'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodePortrait": {
      "signature": "(portrait: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.core"
    },
    "EncodeSprite": {
      "signature": "(sprite: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.core"
    },
    "EncodeString": {
      "signature": "(s: 'str | bytes | int | EUDVariable | ConstExpr | ExprProxy[str | bytes | int | EUDVariable | ConstExpr | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable | ConstExpr'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodeSwitch": {
      "signature": "(sw: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodeTBL": {
      "signature": "(t: 'str | bytes | int | EUDVariable | ConstExpr | ExprProxy[str | bytes | int | EUDVariable | ConstExpr | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable | ConstExpr'",
      "doc": "",
      "module": "eudplib.core"
    },
    "EncodeTech": {
      "signature": "(tech: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.core"
    },
    "EncodeUnit": {
      "signature": "(u: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "EncodeUnitOrder": {
      "signature": "(order: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.core"
    },
    "EncodeUpgrade": {
      "signature": "(upgrade: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.core"
    },
    "EncodeWeapon": {
      "signature": "(weapon: 'str | bytes | int | EUDVariable | ExprProxy[str | bytes | int | EUDVariable | ExprProxy]', issueError: bool = False) -> 'int | EUDVariable'",
      "doc": "",
      "module": "eudplib.core"
    },
    "CenterView": {
      "signature": "(Where: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Comment": {
      "signature": "(Text: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "CreateUnit": {
      "signature": "(Number: int, Unit: str | int | bytes, Where: str | int | bytes, ForPlayer: eudplib.core.rawtrigger.constenc._Player | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "CreateUnitWithProperties": {
      "signature": "(Count: int, Unit: str | int | bytes, Where: str | int | bytes, Player: eudplib.core.rawtrigger.constenc._Player | int, Properties: eudplib.core.mapdata.unitprp.UnitProperty | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Defeat": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "DisplayText": {
      "signature": "(Text: str | int | bytes, AlwaysDisplay: int = 4) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Draw": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "GiveUnits": {
      "signature": "(Count: eudplib.core.rawtrigger.constenc._Count | int, Unit: str | int | bytes, Owner: eudplib.core.rawtrigger.constenc._Player | int, Where: str | int | bytes, NewOwner: eudplib.core.rawtrigger.constenc._Player | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "KillUnit": {
      "signature": "(Unit: str | int | bytes, Player: eudplib.core.rawtrigger.constenc._Player | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "KillUnitAt": {
      "signature": "(Count: eudplib.core.rawtrigger.constenc._Count | int, Unit: str | int | bytes, Where: str | int | bytes, ForPlayer: eudplib.core.rawtrigger.constenc._Player | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LeaderBoardComputerPlayers": {
      "signature": "(State: eudplib.core.rawtrigger.constenc._PropState | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LeaderBoardControl": {
      "signature": "(Unit: str | int | bytes, Label: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LeaderBoardControlAt": {
      "signature": "(Unit: str | int | bytes, Location: str | int | bytes, Label: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LeaderBoardGoalControl": {
      "signature": "(Goal: int, Unit: str | int | bytes, Label: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LeaderBoardGoalControlAt": {
      "signature": "(Goal: int, Unit: str | int | bytes, Location: str | int | bytes, Label: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LeaderBoardGoalKills": {
      "signature": "(Goal: int, Unit: str | int | bytes, Label: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LeaderBoardGoalResources": {
      "signature": "(Goal: int, ResourceType: eudplib.core.rawtrigger.constenc._Resource | int, Label: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LeaderBoardGoalScore": {
      "signature": "(Goal: int, ScoreType: eudplib.core.rawtrigger.constenc._Score | int, Label: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LeaderBoardGreed": {
      "signature": "(Goal: int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LeaderBoardKills": {
      "signature": "(Unit: str | int | bytes, Label: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LeaderBoardResources": {
      "signature": "(ResourceType: eudplib.core.rawtrigger.constenc._Resource | int, Label: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LeaderBoardScore": {
      "signature": "(ScoreType: eudplib.core.rawtrigger.constenc._Score | int, Label: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "MinimapPing": {
      "signature": "(Where: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "ModifyUnitEnergy": {
      "signature": "(Count: eudplib.core.rawtrigger.constenc._Count | int, Unit: str | int | bytes, Owner: eudplib.core.rawtrigger.constenc._Player | int, Where: str | int | bytes, Percent: int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "ModifyUnitHangarCount": {
      "signature": "(Add: int, Count: eudplib.core.rawtrigger.constenc._Count | int, Unit: str | int | bytes, Owner: eudplib.core.rawtrigger.constenc._Player | int, Where: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "ModifyUnitHitPoints": {
      "signature": "(Count: eudplib.core.rawtrigger.constenc._Count | int, Unit: str | int | bytes, Owner: eudplib.core.rawtrigger.constenc._Player | int, Where: str | int | bytes, Percent: int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "ModifyUnitResourceAmount": {
      "signature": "(Count: eudplib.core.rawtrigger.constenc._Count | int, Owner: eudplib.core.rawtrigger.constenc._Player | int, Where: str | int | bytes, NewValue: int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "ModifyUnitShields": {
      "signature": "(Count: eudplib.core.rawtrigger.constenc._Count | int, Unit: str | int | bytes, Owner: eudplib.core.rawtrigger.constenc._Player | int, Where: str | int | bytes, Percent: int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "MoveLocation": {
      "signature": "(Location: str | int | bytes, OnUnit: str | int | bytes, Owner: eudplib.core.rawtrigger.constenc._Player | int, DestLocation: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "MoveUnit": {
      "signature": "(Count: eudplib.core.rawtrigger.constenc._Count | int, UnitType: str | int | bytes, Owner: eudplib.core.rawtrigger.constenc._Player | int, StartLocation: str | int | bytes, DestLocation: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "MuteUnitSpeech": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Order": {
      "signature": "(Unit: str | int | bytes, Owner: eudplib.core.rawtrigger.constenc._Player | int, StartLocation: str | int | bytes, OrderType: eudplib.core.rawtrigger.constenc._Order | int, DestLocation: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "PauseGame": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "PauseTimer": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "PlayWAV": {
      "signature": "(WAVName: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "PreserveTrigger": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "RemoveUnit": {
      "signature": "(Unit: str | int | bytes, Player: eudplib.core.rawtrigger.constenc._Player | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "RemoveUnitAt": {
      "signature": "(Count: eudplib.core.rawtrigger.constenc._Count | int, Unit: str | int | bytes, Where: str | int | bytes, ForPlayer: eudplib.core.rawtrigger.constenc._Player | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "RunAIScript": {
      "signature": "(Script: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "RunAIScriptAt": {
      "signature": "(Script: str | int | bytes, Where: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "SetAllianceStatus": {
      "signature": "(Player: eudplib.core.rawtrigger.constenc._Player | int, Status: eudplib.core.rawtrigger.constenc._AllyStatus | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "SetCountdownTimer": {
      "signature": "(TimeModifier: eudplib.core.rawtrigger.constenc._Modifier | int, Time: int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "SetDeaths": {
      "signature": "(Player: eudplib.core.rawtrigger.constenc._Player | int, Modifier: eudplib.core.rawtrigger.constenc._Modifier | int, Number: int, Unit: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "SetDeathsX": {
      "signature": "(Player: '_Player | Dword', Modifier: '_Modifier | Byte', Number: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', Unit: 'str | Word | bytes', Mask: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "SetDoodadState": {
      "signature": "(State: eudplib.core.rawtrigger.constenc._PropState | int, Unit: str | int | bytes, Owner: eudplib.core.rawtrigger.constenc._Player | int, Where: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "SetInvincibility": {
      "signature": "(State: eudplib.core.rawtrigger.constenc._PropState | int, Unit: str | int | bytes, Owner: eudplib.core.rawtrigger.constenc._Player | int, Where: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "SetKills": {
      "signature": "(Player: '_Player | Dword', Modifier: '_Modifier | Byte', Number: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', Unit: 'str | Word | bytes') -> eudplib.core.rawtrigger.action.Action | tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "eudplib.core"
    },
    "SetMemory": {
      "signature": "(dest: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', modtype: '_Modifier | Byte', value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "SetMemoryEPD": {
      "signature": "(dest: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', modtype: '_Modifier | Byte', value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "eudplib.core"
    },
    "SetMemoryX": {
      "signature": "(dest: int, modtype: eudplib.core.rawtrigger.constenc._Modifier | int, value: int, mask: int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "SetMemoryXEPD": {
      "signature": "(epd: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', modtype: '_Modifier | Byte', value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', mask: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "eudplib.core"
    },
    "SetMissionObjectives": {
      "signature": "(Text: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "SetNextPtr": {
      "signature": "(trg: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', dest: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "SetNextScenario": {
      "signature": "(ScenarioName: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "SetResources": {
      "signature": "(Player: eudplib.core.rawtrigger.constenc._Player | int, Modifier: eudplib.core.rawtrigger.constenc._Modifier | int, Amount: int, ResourceType: eudplib.core.rawtrigger.constenc._Resource | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "SetScore": {
      "signature": "(Player: eudplib.core.rawtrigger.constenc._Player | int, Modifier: eudplib.core.rawtrigger.constenc._Modifier | int, Amount: int, ScoreType: eudplib.core.rawtrigger.constenc._Score | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "SetSwitch": {
      "signature": "(Switch: str | int | bytes, State: eudplib.core.rawtrigger.constenc._SwitchAction | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "TalkingPortrait": {
      "signature": "(Unit: str | int | bytes, Time: int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Transmission": {
      "signature": "(Unit: str | int | bytes, Where: str | int | bytes, WAVName: str | int | bytes, TimeModifier: eudplib.core.rawtrigger.constenc._Modifier | int, Time: int, Text: str | int | bytes, AlwaysDisplay: int = 4) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "UnMuteUnitSpeech": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "UnpauseGame": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "UnpauseTimer": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Victory": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Wait": {
      "signature": "(Time: int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Accumulate": {
      "signature": "(Player: eudplib.core.rawtrigger.constenc._Player | int, Comparison: eudplib.core.rawtrigger.constenc._Comparison | int, Number: int, ResourceType: eudplib.core.rawtrigger.constenc._Resource | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Always": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Bring": {
      "signature": "(Player: eudplib.core.rawtrigger.constenc._Player | int, Comparison: eudplib.core.rawtrigger.constenc._Comparison | int, Number: int, Unit: str | int | bytes, Location: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Command": {
      "signature": "(Player: eudplib.core.rawtrigger.constenc._Player | int, Comparison: eudplib.core.rawtrigger.constenc._Comparison | int, Number: int, Unit: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "CommandLeast": {
      "signature": "(Unit: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "CommandLeastAt": {
      "signature": "(Unit: str | int | bytes, Location: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "CommandMost": {
      "signature": "(Unit: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "CommandMostAt": {
      "signature": "(Unit: str | int | bytes, Location: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "CountdownTimer": {
      "signature": "(Comparison: eudplib.core.rawtrigger.constenc._Comparison | int, Time: int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Deaths": {
      "signature": "(Player: '_Player | Dword', Comparison: '_Comparison | Byte', Number: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', Unit: 'str | Word | bytes') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "DeathsX": {
      "signature": "(Player: '_Player | Dword', Comparison: '_Comparison | Byte', Number: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', Unit: 'str | Word | bytes', Mask: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "ElapsedTime": {
      "signature": "(Comparison: eudplib.core.rawtrigger.constenc._Comparison | int, Time: int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "HighestScore": {
      "signature": "(ScoreType: eudplib.core.rawtrigger.constenc._Score | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LeastKills": {
      "signature": "(Unit: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LeastResources": {
      "signature": "(ResourceType: eudplib.core.rawtrigger.constenc._Resource | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "LowestScore": {
      "signature": "(ScoreType: eudplib.core.rawtrigger.constenc._Score | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Memory": {
      "signature": "(dest: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', cmptype: '_Comparison | Byte', value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "MemoryEPD": {
      "signature": "(dest: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', cmptype: '_Comparison | Byte', value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "eudplib.core"
    },
    "MemoryX": {
      "signature": "(dest: int, cmptype: eudplib.core.rawtrigger.constenc._Comparison | int, value: int, mask: int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "MemoryXEPD": {
      "signature": "(dest: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', cmptype: '_Comparison | Byte', value: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]', mask: 'int | EUDVariable | ConstExpr | ExprProxy[int] | ExprProxy[EUDVariable] | ExprProxy[ConstExpr]') -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "eudplib.core"
    },
    "MostKills": {
      "signature": "(Unit: str | int | bytes) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "MostResources": {
      "signature": "(ResourceType: eudplib.core.rawtrigger.constenc._Resource | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Never": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Opponents": {
      "signature": "(Player: eudplib.core.rawtrigger.constenc._Player | int, Comparison: eudplib.core.rawtrigger.constenc._Comparison | int, Number: int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Score": {
      "signature": "(Player: eudplib.core.rawtrigger.constenc._Player | int, ScoreType: eudplib.core.rawtrigger.constenc._Score | int, Comparison: eudplib.core.rawtrigger.constenc._Comparison | int, Number: int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Switch": {
      "signature": "(Switch: str | int | bytes, State: eudplib.core.rawtrigger.constenc._SwitchState | int) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "ISEOF": {
      "signature": "(x)",
      "doc": "",
      "module": "tokenize"
    },
    "ISNONTERMINAL": {
      "signature": "(x)",
      "doc": "",
      "module": "tokenize"
    },
    "ISTERMINAL": {
      "signature": "(x)",
      "doc": "",
      "module": "tokenize"
    },
    "any": {
      "signature": "(*choices)",
      "doc": "",
      "module": "tokenize"
    },
    "detect_encoding": {
      "signature": "(b)",
      "doc": "",
      "module": "json"
    },
    "generate_tokens": {
      "signature": "(readline)",
      "doc": "Tokenize a source reading Python code as unicode strings.",
      "module": "tokenize"
    },
    "group": {
      "signature": "(*choices)",
      "doc": "",
      "module": "tokenize"
    },
    "main": {
      "signature": "()",
      "doc": "",
      "module": "main"
    },
    "maybe": {
      "signature": "(*choices)",
      "doc": "",
      "module": "tokenize"
    },
    "tokenize": {
      "signature": "(readline)",
      "doc": "",
      "module": "tokenize"
    },
    "untokenize": {
      "signature": "(iterable)",
      "doc": "Transform tokens back into Python source code.",
      "module": "tokenize"
    },
    "checkcache": {
      "signature": "(filename=None)",
      "doc": "Discard cache entries that are out of date.",
      "module": "linecache"
    },
    "clearcache": {
      "signature": "()",
      "doc": "Clear the cache entirely.",
      "module": "linecache"
    },
    "getline": {
      "signature": "(filename, lineno, module_globals=None)",
      "doc": "Get a line for a Python source file from the cache.",
      "module": "linecache"
    },
    "getlines": {
      "signature": "(filename, module_globals=None)",
      "doc": "Get the lines for a Python source file from the cache.",
      "module": "linecache"
    },
    "lazycache": {
      "signature": "(filename, module_globals)",
      "doc": "Seed the cache for filename with module_globals.",
      "module": "linecache"
    },
    "updatecache": {
      "signature": "(filename, module_globals=None)",
      "doc": "Update a cache entry and return its list of lines.",
      "module": "linecache"
    },
    "clear_frames": {
      "signature": "(tb)",
      "doc": "Clear all references to local variables in the frames of a traceback.",
      "module": "traceback"
    },
    "extract_stack": {
      "signature": "(f=None, limit=None)",
      "doc": "Extract the raw traceback from the current stack frame.",
      "module": "traceback"
    },
    "extract_tb": {
      "signature": "(tb, limit=None)",
      "doc": "",
      "module": "traceback"
    },
    "format_exc": {
      "signature": "(limit=None, chain=True)",
      "doc": "Like print_exc() but return a string.",
      "module": "traceback"
    },
    "format_exception": {
      "signature": "(exc, /, value=<implicit>, tb=<implicit>, limit=None, chain=True)",
      "doc": "Format a stack trace and the exception information.",
      "module": "traceback"
    },
    "format_exception_only": {
      "signature": "(exc, /, value=<implicit>)",
      "doc": "Format the exception part of a traceback.",
      "module": "traceback"
    },
    "format_list": {
      "signature": "(extracted_list)",
      "doc": "Format a list of tuples or FrameSummary objects for printing.",
      "module": "traceback"
    },
    "format_stack": {
      "signature": "(f=None, limit=None)",
      "doc": "Shorthand for 'format_list(extract_stack(f, limit))'.",
      "module": "traceback"
    },
    "format_tb": {
      "signature": "(tb, limit=None)",
      "doc": "A shorthand for 'format_list(extract_tb(tb, limit))'.",
      "module": "traceback"
    },
    "print_exc": {
      "signature": "(limit=None, file=None, chain=True)",
      "doc": "Shorthand for 'print_exception(*sys.exc_info(), limit, file)'.",
      "module": "traceback"
    },
    "print_exception": {
      "signature": "(type=None, value=None, tb=None, limit=None)",
      "doc": "",
      "module": "cgi"
    },
    "print_last": {
      "signature": "(limit=None, file=None, chain=True)",
      "doc": "This is a shorthand for 'print_exception(sys.last_type,",
      "module": "traceback"
    },
    "print_list": {
      "signature": "(extracted_list, file=None)",
      "doc": "Print the list of tuples as returned by extract_tb() or",
      "module": "traceback"
    },
    "print_stack": {
      "signature": "(f=None, limit=None, file=None)",
      "doc": "Print a stack trace from its invocation point.",
      "module": "traceback"
    },
    "print_tb": {
      "signature": "(tb, limit=None, file=None)",
      "doc": "Print up to 'limit' stack trace entries from the traceback 'tb'.",
      "module": "traceback"
    },
    "walk_stack": {
      "signature": "(f)",
      "doc": "Walk a stack yielding the frame and line number for each frame.",
      "module": "traceback"
    },
    "walk_tb": {
      "signature": "(tb)",
      "doc": "Walk a traceback yielding the frame and line number for each frame.",
      "module": "traceback"
    },
    "GetCurrentCustomVariableBuffer": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.core.eudstruct.vararray"
    },
    "GetCurrentVariableBuffer": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.core.eudstruct.vararray"
    },
    "RegisterNewCustomVariableBuffer": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.core.variable.vbuf"
    },
    "RegisterNewVariableBuffer": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.core.variable.vbuf"
    },
    "EP_SetRValueStrictMode": {
      "signature": "(mode: bool) -> None",
      "doc": "",
      "module": "eudplib.core"
    },
    "EUDCreateVariables": {
      "signature": "(varn)",
      "doc": "",
      "module": "eudplib.core"
    },
    "IsEUDVariable": {
      "signature": "(x: object) -> bool",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "IsRValue": {
      "signature": "(obj) -> bool",
      "doc": "",
      "module": "eudplib.core.variable.eudv"
    },
    "NonSeqCompute": {
      "signature": "(assignpairs)",
      "doc": "",
      "module": "eudplib.core"
    },
    "SeqCompute": {
      "signature": "(assignpairs)",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "SetVariables": {
      "signature": "(srclist, dstlist, mdtlist=None)",
      "doc": "",
      "module": "eudplib.core"
    },
    "VProc": {
      "signature": "(v, actions)",
      "doc": "",
      "module": "freeze.crypt"
    },
    "copy_location": {
      "signature": "(new_node, old_node)",
      "doc": "",
      "module": "ast"
    },
    "fix_missing_locations": {
      "signature": "(node)",
      "doc": "",
      "module": "ast"
    },
    "get_docstring": {
      "signature": "(node, clean=True)",
      "doc": "",
      "module": "ast"
    },
    "get_source_segment": {
      "signature": "(source, node, *, padded=False)",
      "doc": "Get source code segment of the *source* that generated *node*.",
      "module": "ast"
    },
    "increment_lineno": {
      "signature": "(node, n=1)",
      "doc": "",
      "module": "ast"
    },
    "iter_child_nodes": {
      "signature": "(node)",
      "doc": "",
      "module": "ast"
    },
    "iter_fields": {
      "signature": "(node)",
      "doc": "",
      "module": "ast"
    },
    "literal_eval": {
      "signature": "(node_or_string)",
      "doc": "",
      "module": "ast"
    },
    "unparse": {
      "signature": "(ast_obj)",
      "doc": "",
      "module": "ast"
    },
    "code_info": {
      "signature": "(x)",
      "doc": "Formatted details of methods, functions, or code.",
      "module": "dis"
    },
    "disassemble": {
      "signature": "(co, lasti=-1, *, file=None)",
      "doc": "Disassemble a code object.",
      "module": "dis"
    },
    "disco": {
      "signature": "(co, lasti=-1, *, file=None)",
      "doc": "Disassemble a code object.",
      "module": "dis"
    },
    "distb": {
      "signature": "(tb=None, *, file=None)",
      "doc": "Disassemble a traceback (default: last traceback).",
      "module": "dis"
    },
    "findlabels": {
      "signature": "(code)",
      "doc": "Detect all offsets in a byte code which are jump targets.",
      "module": "dis"
    },
    "findlinestarts": {
      "signature": "(code)",
      "doc": "Find the offsets in a byte code which are start of lines in the source.",
      "module": "dis"
    },
    "get_instructions": {
      "signature": "(x, *, first_line=None)",
      "doc": "Iterator for the opcodes in methods, functions or code",
      "module": "dis"
    },
    "pretty_flags": {
      "signature": "(flags)",
      "doc": "Return pretty representation of code flags.",
      "module": "dis"
    },
    "show_code": {
      "signature": "(co, *, file=None)",
      "doc": "Print details of methods, functions, or code to *file*.",
      "module": "dis"
    },
    "classify_class_attrs": {
      "signature": "(cls)",
      "doc": "Return list of attribute-descriptor tuples.",
      "module": "inspect"
    },
    "cleandoc": {
      "signature": "(doc)",
      "doc": "Clean up indentation from docstrings.",
      "module": "inspect"
    },
    "currentframe": {
      "signature": "()",
      "doc": "Return the frame of the caller or None if this is not possible.",
      "module": "inspect"
    },
    "findsource": {
      "signature": "(object)",
      "doc": "Return the entire source file and starting line number for an object.",
      "module": "inspect"
    },
    "formatannotation": {
      "signature": "(annotation, base_module=None)",
      "doc": "",
      "module": "inspect"
    },
    "formatannotationrelativeto": {
      "signature": "(object)",
      "doc": "",
      "module": "inspect"
    },
    "formatargspec": {
      "signature": "(args, varargs=None, varkw=None, defaults=None, kwonlyargs=(), kwonlydefaults={}, annotations={}, formatarg=<class 'str'>, formatvarargs=<function <lambda> at 0x0000014FB47EB6D0>, formatvarkw=<function <lambda> at 0x0000014FB47EB760>, formatvalue=<function <lambda> at 0x0000014FB47EB7F0>, formatreturns=<function <lambda> at 0x0000014FB47EB880>, formatannotation=<function formatannotation at 0x0000014FB47EB5B0>)",
      "doc": "Format an argument spec from the values returned by getfullargspec.",
      "module": "inspect"
    },
    "formatargvalues": {
      "signature": "(args, varargs, varkw, locals, formatarg=<class 'str'>, formatvarargs=<function <lambda> at 0x0000014FB47EBA30>, formatvarkw=<function <lambda> at 0x0000014FB47EBAC0>, formatvalue=<function <lambda> at 0x0000014FB47EBB50>)",
      "doc": "Format an argument spec from the 4 values returned by getargvalues.",
      "module": "inspect"
    },
    "get_annotations": {
      "signature": "(obj, *, globals=None, locals=None, eval_str=False)",
      "doc": "Compute the annotations dict for an object.",
      "module": "inspect"
    },
    "getabsfile": {
      "signature": "(object, _filename=None)",
      "doc": "Return an absolute path to the source or compiled file for an object.",
      "module": "inspect"
    },
    "getargs": {
      "signature": "(co)",
      "doc": "Get information about the arguments accepted by a code object.",
      "module": "inspect"
    },
    "getargspec": {
      "signature": "(func)",
      "doc": "Get the names and default values of a function's parameters.",
      "module": "inspect"
    },
    "getargvalues": {
      "signature": "(frame)",
      "doc": "Get information about arguments passed into a particular frame.",
      "module": "inspect"
    },
    "getattr_static": {
      "signature": "(obj, attr, default=<object object at 0x0000014FB25B8D90>)",
      "doc": "Retrieve attributes without triggering dynamic lookup via the",
      "module": "inspect"
    },
    "getblock": {
      "signature": "(lines)",
      "doc": "Extract the block of code at the top of the given list of lines.",
      "module": "inspect"
    },
    "getcallargs": {
      "signature": "(func, /, *positional, **named)",
      "doc": "Get the mapping of arguments to values.",
      "module": "inspect"
    },
    "getclasstree": {
      "signature": "(classes, unique=False)",
      "doc": "Arrange the given list of classes into a hierarchy of nested lists.",
      "module": "inspect"
    },
    "getclosurevars": {
      "signature": "(func)",
      "doc": "",
      "module": "inspect"
    },
    "getcomments": {
      "signature": "(object)",
      "doc": "Get lines of comments immediately preceding an object's source code.",
      "module": "inspect"
    },
    "getcoroutinelocals": {
      "signature": "(coroutine)",
      "doc": "",
      "module": "inspect"
    },
    "getcoroutinestate": {
      "signature": "(coroutine)",
      "doc": "Get current state of a coroutine object.",
      "module": "inspect"
    },
    "getdoc": {
      "signature": "(object)",
      "doc": "Get the documentation string for an object.",
      "module": "inspect"
    },
    "getfile": {
      "signature": "(object)",
      "doc": "Work out which source or compiled file an object was defined in.",
      "module": "inspect"
    },
    "getframeinfo": {
      "signature": "(frame, context=1)",
      "doc": "Get information about a frame or traceback object.",
      "module": "inspect"
    },
    "getfullargspec": {
      "signature": "(func)",
      "doc": "Get the names and default values of a callable object's parameters.",
      "module": "inspect"
    },
    "getgeneratorlocals": {
      "signature": "(generator)",
      "doc": "",
      "module": "inspect"
    },
    "getgeneratorstate": {
      "signature": "(generator)",
      "doc": "Get current state of a generator-iterator.",
      "module": "inspect"
    },
    "getinnerframes": {
      "signature": "(tb, context=1)",
      "doc": "Get a list of records for a traceback's frame and all lower frames.",
      "module": "inspect"
    },
    "getlineno": {
      "signature": "(frame)",
      "doc": "Get the line number from a frame object, allowing for optimization.",
      "module": "inspect"
    },
    "getmembers": {
      "signature": "(object, predicate=None)",
      "doc": "Return all members of an object as (name, value) pairs sorted by name.",
      "module": "inspect"
    },
    "getmodule": {
      "signature": "(object, _filename=None)",
      "doc": "Return the module an object was defined in, or None if not found.",
      "module": "inspect"
    },
    "getmodulename": {
      "signature": "(path)",
      "doc": "Return the module name for a given file, or None.",
      "module": "inspect"
    },
    "getmro": {
      "signature": "(cls)",
      "doc": "Return tuple of base classes (including cls) in method resolution order.",
      "module": "inspect"
    },
    "getouterframes": {
      "signature": "(frame, context=1)",
      "doc": "Get a list of records for a frame and all higher (calling) frames.",
      "module": "inspect"
    },
    "getsource": {
      "signature": "(object)",
      "doc": "Return the text of the source code for an object.",
      "module": "inspect"
    },
    "getsourcefile": {
      "signature": "(object)",
      "doc": "Return the filename that can be used to locate an object's source.",
      "module": "inspect"
    },
    "getsourcelines": {
      "signature": "(object)",
      "doc": "Return a list of source lines and starting line number for an object.",
      "module": "inspect"
    },
    "indentsize": {
      "signature": "(line)",
      "doc": "Return the indent size, in spaces, at the start of a line of text.",
      "module": "inspect"
    },
    "isabstract": {
      "signature": "(object)",
      "doc": "Return true if the object is an abstract base class (ABC).",
      "module": "inspect"
    },
    "isasyncgen": {
      "signature": "(object)",
      "doc": "Return true if the object is an asynchronous generator.",
      "module": "inspect"
    },
    "isasyncgenfunction": {
      "signature": "(obj)",
      "doc": "Return true if the object is an asynchronous generator function.",
      "module": "inspect"
    },
    "isawaitable": {
      "signature": "(object)",
      "doc": "Return true if object can be passed to an ``await`` expression.",
      "module": "inspect"
    },
    "isbuiltin": {
      "signature": "(object)",
      "doc": "Return true if the object is a built-in function or method.",
      "module": "inspect"
    },
    "isclass": {
      "signature": "(object)",
      "doc": "Return true if the object is a class.",
      "module": "inspect"
    },
    "iscode": {
      "signature": "(object)",
      "doc": "Return true if the object is a code object.",
      "module": "inspect"
    },
    "iscoroutine": {
      "signature": "(object)",
      "doc": "Return true if the object is a coroutine.",
      "module": "inspect"
    },
    "iscoroutinefunction": {
      "signature": "(obj)",
      "doc": "Return true if the object is a coroutine function.",
      "module": "inspect"
    },
    "isdatadescriptor": {
      "signature": "(object)",
      "doc": "Return true if the object is a data descriptor.",
      "module": "inspect"
    },
    "isframe": {
      "signature": "(object)",
      "doc": "Return true if the object is a frame object.",
      "module": "inspect"
    },
    "isfunction": {
      "signature": "(object)",
      "doc": "Return true if the object is a user-defined function.",
      "module": "inspect"
    },
    "isgenerator": {
      "signature": "(object)",
      "doc": "Return true if the object is a generator.",
      "module": "inspect"
    },
    "isgeneratorfunction": {
      "signature": "(obj)",
      "doc": "Return true if the object is a user-defined generator function.",
      "module": "inspect"
    },
    "isgetsetdescriptor": {
      "signature": "(object)",
      "doc": "Return true if the object is a getset descriptor.",
      "module": "inspect"
    },
    "ismemberdescriptor": {
      "signature": "(object)",
      "doc": "Return true if the object is a member descriptor.",
      "module": "inspect"
    },
    "ismethod": {
      "signature": "(object)",
      "doc": "Return true if the object is an instance method.",
      "module": "inspect"
    },
    "ismethoddescriptor": {
      "signature": "(object)",
      "doc": "Return true if the object is a method descriptor.",
      "module": "inspect"
    },
    "ismodule": {
      "signature": "(object)",
      "doc": "Return true if the object is a module.",
      "module": "inspect"
    },
    "isroutine": {
      "signature": "(object)",
      "doc": "Return true if the object is any kind of function or method.",
      "module": "inspect"
    },
    "istraceback": {
      "signature": "(object)",
      "doc": "Return true if the object is a traceback.",
      "module": "inspect"
    },
    "signature": {
      "signature": "(obj, *, follow_wrapped=True, globals=None, locals=None, eval_str=False)",
      "doc": "Get a signature object for the passed callable.",
      "module": "inspect"
    },
    "stack": {
      "signature": "(context=1)",
      "doc": "Return a list of records for the stack above the caller's frame.",
      "module": "inspect"
    },
    "trace": {
      "signature": "(context=1)",
      "doc": "Return a list of records for the stack below the current exception.",
      "module": "inspect"
    },
    "unwrap": {
      "signature": "(url)",
      "doc": "Transform a string like '<URL:scheme://host/path>' into 'scheme://host/path'.",
      "module": "urllib.request"
    },
    "walktree": {
      "signature": "(classes, children, parent)",
      "doc": "Recursive helper function for getclasstree().",
      "module": "inspect"
    },
    "T": {
      "signature": "(x: int) -> int",
      "doc": "",
      "module": "eudplib.core.eudfunc.trace.tracecrypt"
    },
    "mix": {
      "signature": "(x: int, y: int) -> int",
      "doc": "",
      "module": "eudplib.core.eudfunc.trace.tracecrypt"
    },
    "EUDTraceLog": {
      "signature": "(lineno: int | None = None) -> None",
      "doc": "",
      "module": "eudplib.core"
    },
    "EUDTraceLogRaw": {
      "signature": "(v: int) -> None",
      "doc": "",
      "module": "eudplib.core.eudfunc.trace.tracetool"
    },
    "GetTraceStackDepth": {
      "signature": "() -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "eudplib.core"
    },
    "EUDReturn": {
      "signature": "(*args)",
      "doc": "",
      "module": "eudplib.core"
    },
    "applyTypes": {
      "signature": "(typesdecl, varlist)",
      "doc": "",
      "module": "eudplib.core.eudfunc.eudfptr"
    },
    "EUDFullFunc": {
      "signature": "(arginitvals, argtypes, rettypes=None, *, traced=False)",
      "doc": "",
      "module": "eudplib.core"
    },
    "EUDFunc": {
      "signature": "(fdecl_func)",
      "doc": "",
      "module": "freeze.crypt"
    },
    "EUDTracedFunc": {
      "signature": "(fdecl_func)",
      "doc": "",
      "module": "eudplib.core"
    },
    "EUDTracedTypedFunc": {
      "signature": "(argtypes, rettypes=None)",
      "doc": "",
      "module": "eudplib.core"
    },
    "EUDTypedFunc": {
      "signature": "(argtypes, rettypes=None, *, traced=False)",
      "doc": "",
      "module": "eudplib.core"
    },
    "EUDXTypedFunc": {
      "signature": "(argmasks, argtypes, rettypes=None, *, traced=False)",
      "doc": "",
      "module": "eudplib.core"
    },
    "SetSelfType": {
      "signature": "(t)",
      "doc": "",
      "module": "eudplib.core.eudfunc.eudfmethod"
    },
    "AddCurrentPlayer": {
      "signature": "(p)",
      "doc": "",
      "module": "eudplib.core"
    },
    "GetCPCache": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.core.eudstruct.vararray"
    },
    "SetCurrentPlayer": {
      "signature": "(p)",
      "doc": "",
      "module": "eudplib.core"
    },
    "cpcacheMatchCond": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.core.curpl"
    },
    "cpset": {
      "signature": "(a, b)",
      "doc": "",
      "module": "eudplib.eudlib.eudarray"
    },
    "iand": {
      "signature": "(a, b, v)",
      "doc": "",
      "module": "eudplib.eudlib.eudarray"
    },
    "ilshift": {
      "signature": "(a, b, n)",
      "doc": "",
      "module": "eudplib.eudlib.eudarray"
    },
    "ior": {
      "signature": "(a, b, v)",
      "doc": "",
      "module": "eudplib.eudlib.eudarray"
    },
    "irshift": {
      "signature": "(a, b, n)",
      "doc": "",
      "module": "eudplib.eudlib.eudarray"
    },
    "iset": {
      "signature": "(a, b, modifier, v)",
      "doc": "",
      "module": "eudplib.eudlib.eudarray"
    },
    "isub": {
      "signature": "(a, b, v)",
      "doc": "",
      "module": "eudplib.eudlib.eudarray"
    },
    "ixor": {
      "signature": "(a, b, v)",
      "doc": "",
      "module": "eudplib.eudlib.eudarray"
    },
    "EUDMethod": {
      "signature": "(method)",
      "doc": "",
      "module": "eudplib.core"
    },
    "EUDTracedMethod": {
      "signature": "(method)",
      "doc": "",
      "module": "eudplib.core"
    },
    "EUDTracedTypedMethod": {
      "signature": "(argtypes, rettypes=None)",
      "doc": "",
      "module": "eudplib.core"
    },
    "EUDTypedMethod": {
      "signature": "(argtypes, rettypes=None, *, traced=False)",
      "doc": "",
      "module": "eudplib.core"
    },
    "EUDFuncPtr": {
      "signature": "(argn, retn)",
      "doc": "",
      "module": "eudplib.core"
    },
    "EUDTypedFuncPtr": {
      "signature": "(argtypes, rettypes)",
      "doc": "",
      "module": "eudplib.core"
    },
    "callFuncBody": {
      "signature": "(fstart, fend)",
      "doc": "",
      "module": "eudplib.core.eudfunc.eudfptr"
    },
    "createIndirectCaller": {
      "signature": "(f, _caller_dict={})",
      "doc": "",
      "module": "eudplib.core.eudfunc.eudfptr"
    },
    "fillArguments": {
      "signature": "(f)",
      "doc": "",
      "module": "eudplib.core.eudfunc.eudfptr"
    },
    "fillReturns": {
      "signature": "(f)",
      "doc": "",
      "module": "eudplib.core.eudfunc.eudfptr"
    },
    "getArgStorage": {
      "signature": "(argn, _argstorage_dict={})",
      "doc": "",
      "module": "eudplib.core.eudfunc.eudfptr"
    },
    "getRetStorage": {
      "signature": "(retn, _retstorage_dict={})",
      "doc": "",
      "module": "eudplib.core.eudfunc.eudfptr"
    },
    "f_constdiv": {
      "signature": "(number)",
      "doc": "",
      "module": "eudplib.core.calcf.muldiv"
    },
    "f_constmul": {
      "signature": "(number)",
      "doc": "",
      "module": "eudplib.core.calcf.muldiv"
    },
    "f_div": {
      "signature": "(a, b, **kwargs)",
      "doc": "",
      "module": "eudplib.core"
    },
    "f_mul": {
      "signature": "(a, b, **kwargs)",
      "doc": "",
      "module": "eudplib.core"
    },
    "f_bitand": {
      "signature": "(a, b)",
      "doc": "",
      "module": "eudplib.core"
    },
    "f_bitlshift": {
      "signature": "(a, b, _fdict={2: <eudplib.core.eudfunc.eudtypedfuncn.EUDTypedFuncN object at 0x0000014FB4957820>}, **kwargs)",
      "doc": "",
      "module": "eudplib.core"
    },
    "f_bitnand": {
      "signature": "(a, b)",
      "doc": "",
      "module": "eudplib.core"
    },
    "f_bitnor": {
      "signature": "(a, b)",
      "doc": "",
      "module": "eudplib.core"
    },
    "f_bitnot": {
      "signature": "(a)",
      "doc": "",
      "module": "eudplib.core"
    },
    "f_bitnxor": {
      "signature": "(a, b)",
      "doc": "",
      "module": "eudplib.core"
    },
    "f_bitor": {
      "signature": "(a, b)",
      "doc": "",
      "module": "eudplib.core"
    },
    "f_bitrshift": {
      "signature": "(a, b, **kwargs)",
      "doc": "",
      "module": "eudplib.core"
    },
    "f_bitxor": {
      "signature": "(a, b)",
      "doc": "",
      "module": "eudplib.core"
    },
    "DefBinOperator": {
      "signature": "(name: str, f: collections.abc.Callable) -> None",
      "doc": "",
      "module": "eudplib.core.calcf._eudvsupport"
    },
    "DefClsMethod": {
      "signature": "(name: str, f: collections.abc.Callable) -> None",
      "doc": "",
      "module": "eudplib.core.calcf._eudvsupport"
    },
    "DefInplaceOperator": {
      "signature": "(name: str, f: collections.abc.Callable) -> None",
      "doc": "",
      "module": "eudplib.core.calcf._eudvsupport"
    },
    "EUDClearNamespace": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.core"
    },
    "EUDRegisterObjectToNamespace": {
      "signature": "(funcname: str, obj: Any) -> Any",
      "doc": "",
      "module": "eudplib.core"
    },
    "EUDRegistered": {
      "signature": "(func: collections.abc.Callable) -> collections.abc.Callable",
      "doc": "",
      "module": "eudplib.core"
    },
    "GetEUDNamespace": {
      "signature": "() -> dict[str, typing.Any]",
      "doc": "",
      "module": "eudplib.core"
    },
    "ApplyPatchTable": {
      "signature": "(initepd, obj, patchTable: list[list[int | None]]) -> None",
      "doc": "",
      "module": "eudplib.trigger.tpatcher"
    },
    "IsConditionConst": {
      "signature": "(cond) -> bool",
      "doc": "",
      "module": "eudplib.trigger.tpatcher"
    },
    "IsConditionNegatable": {
      "signature": "(cond) -> bool",
      "doc": "",
      "module": "eudplib.trigger.tpatcher"
    },
    "NegateCondition": {
      "signature": "(cond: Union[eudplib.core.allocator.constexpr.ConstExpr, bool, int, eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudlv.EUDLightVariable, eudplib.core.variable.eudlv.EUDLightBool, eudplib.utils.exprproxy.ExprProxy[bool | int | eudplib.core.variable.eudv.EUDVariable | eudplib.core.variable.eudlv.EUDLightVariable | eudplib.core.variable.eudlv.EUDLightBool], eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.constexpr.ConstExpr]]) -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "eudplib.eudlib.utilf.logic"
    },
    "PatchAction": {
      "signature": "(act: Union[eudplib.core.rawtrigger.action.Action, eudplib.core.allocator.constexpr.Forward, eudplib.utils.exprproxy.ExprProxy[eudplib.core.rawtrigger.action.Action | eudplib.core.allocator.constexpr.Forward]]) -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "eudplib.trigger.triggerdef"
    },
    "PatchCondition": {
      "signature": "(cond: Union[eudplib.core.allocator.constexpr.ConstExpr, bool, int, eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudlv.EUDLightVariable, eudplib.core.variable.eudlv.EUDLightBool, eudplib.utils.exprproxy.ExprProxy[bool | int | eudplib.core.variable.eudv.EUDVariable | eudplib.core.variable.eudlv.EUDLightVariable | eudplib.core.variable.eudlv.EUDLightBool], eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.constexpr.ConstExpr]]) -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "eudplib.trigger.triggerdef"
    },
    "isCastable": {
      "signature": "(cond) -> bool",
      "doc": "",
      "module": "eudplib.trigger.tpatcher"
    },
    "EUDBranch": {
      "signature": "(conditions: Union[eudplib.core.allocator.constexpr.ConstExpr, bool, int, eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudlv.EUDLightVariable, eudplib.core.variable.eudlv.EUDLightBool, eudplib.utils.exprproxy.ExprProxy[bool | int | eudplib.core.variable.eudv.EUDVariable | eudplib.core.variable.eudlv.EUDLightVariable | eudplib.core.variable.eudlv.EUDLightBool], eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.constexpr.ConstExpr], collections.abc.Iterable[Union[eudplib.core.allocator.constexpr.ConstExpr, bool, int, eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudlv.EUDLightVariable, eudplib.core.variable.eudlv.EUDLightBool, eudplib.utils.exprproxy.ExprProxy[bool | int | eudplib.core.variable.eudv.EUDVariable | eudplib.core.variable.eudlv.EUDLightVariable | eudplib.core.variable.eudlv.EUDLightBool], eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.constexpr.ConstExpr], collections.abc.Iterable]]], ontrue: eudplib.core.allocator.constexpr.ConstExpr, onfalse: eudplib.core.allocator.constexpr.ConstExpr, *, _actions: eudplib.core.rawtrigger.action.Action | collections.abc.Iterable[eudplib.core.rawtrigger.action.Action | collections.abc.Iterable] | None = None) -> None",
      "doc": "",
      "module": "eudplib.trigger"
    },
    "Trigger": {
      "signature": "(*, players: list[eudplib.core.rawtrigger.constenc._Player | int] = [17], conditions: list[bytes] | bytes = [], actions: list[bytes] | bytes = []) -> None",
      "doc": "",
      "module": "eudplib.maprw.injector.vectorReloc"
    },
    "InitPTrigger": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.trigger.ptrigger"
    },
    "PTrigger": {
      "signature": "(players: eudplib.core.rawtrigger.constenc._Player | int | collections.abc.Iterable[eudplib.core.rawtrigger.constenc._Player | int | collections.abc.Iterable], conditions: eudplib.core.rawtrigger.condition.Condition | bool | collections.abc.Iterable[eudplib.core.rawtrigger.condition.Condition | bool | collections.abc.Iterable | None] | None = None, actions: eudplib.core.rawtrigger.action.Action | collections.abc.Iterable[eudplib.core.rawtrigger.action.Action | collections.abc.Iterable | None] | None = None) -> None",
      "doc": "",
      "module": "eudplib.trigger"
    },
    "DoActions": {
      "signature": "(*actions, preserved=True) -> tuple[eudplib.core.allocator.constexpr.Forward, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger]",
      "doc": "",
      "module": "freeze.utils"
    },
    "EUDJump": {
      "signature": "(nextptr) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDJumpIf": {
      "signature": "(conditions, ontrue, *, _actions=None) -> None",
      "doc": "",
      "module": "eudplib.trigtrg.runtrigtrg"
    },
    "EUDJumpIfNot": {
      "signature": "(conditions, onfalse, *, _actions=None) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDTernary": {
      "signature": "(conditions, *, neg=False)",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDEndInfLoop": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.eudlib.stringf.cputf8"
    },
    "EUDEndLoopN": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDEndWhile": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "EUDInfLoop": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "eudplib.eudlib.stringf.cputf8"
    },
    "EUDLoopBreak": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "EUDLoopBreakIf": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "EUDLoopBreakIfNot": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "EUDLoopContinue": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "EUDLoopContinueIf": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "EUDLoopContinueIfNot": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "EUDLoopIsContinuePointSet": {
      "signature": "() -> bool",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "EUDLoopN": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDLoopRange": {
      "signature": "(start, end=None) -> collections.abc.Iterator[eudplib.core.variable.eudv.EUDVariable]",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDLoopSetContinuePoint": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.ctrlstru.loopblock"
    },
    "EUDWhile": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "eudplib.eudlib.eudqueue"
    },
    "EUDWhileNot": {
      "signature": "() -> eudplib.ctrlstru.cshelper.CtrlStruOpener",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "GetCurrentJumpBuffer": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "RegisterNewJumpBuffer": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.ctrlstru.jumptable"
    },
    "EPDSwitch": {
      "signature": "(epd, mask=4294967295)",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDEndSwitch": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDSwitch": {
      "signature": "(var, mask=4294967295)",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDSwitchBreak": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.ctrlstru.swblock"
    },
    "EUDSwitchBreakIf": {
      "signature": "(conditions)",
      "doc": "",
      "module": "eudplib.ctrlstru.swblock"
    },
    "EUDSwitchBreakIfNot": {
      "signature": "(conditions)",
      "doc": "",
      "module": "eudplib.ctrlstru.swblock"
    },
    "EUDSwitchCase": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDSwitchDefault": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDBreak": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDBreakIf": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "eudplib.eudlib.stringf.cputf8"
    },
    "EUDBreakIfNot": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDContinue": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDContinueIf": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDContinueIfNot": {
      "signature": "(conditions) -> None",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDIsContinuePointSet": {
      "signature": "() -> bool",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDSetContinuePoint": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "EUDElse": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.eudlib.stringf.cputf8"
    },
    "EUDElseIf": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDElseIfNot": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDEndExecuteOnce": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDEndIf": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.eudlib.stringf.cputf8"
    },
    "EUDExecuteOnce": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDIf": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.eudlib.stringf.cputf8"
    },
    "EUDIfNot": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "call": {
      "signature": "(*popenargs, timeout=None, **kwargs)",
      "doc": "Run command with arguments.  Wait for command to complete or",
      "module": "subprocess"
    },
    "check_call": {
      "signature": "(*popenargs, **kwargs)",
      "doc": "Run command with arguments.  Wait for command to complete.  If",
      "module": "subprocess"
    },
    "check_output": {
      "signature": "(*popenargs, timeout=None, **kwargs)",
      "doc": "Run command with arguments and return its output.",
      "module": "subprocess"
    },
    "getoutput": {
      "signature": "(cmd)",
      "doc": "Return output (stdout or stderr) of executing cmd in a shell.",
      "module": "subprocess"
    },
    "getstatusoutput": {
      "signature": "(cmd)",
      "doc": "Return (exitcode, output) of executing cmd in a shell.",
      "module": "subprocess"
    },
    "list2cmdline": {
      "signature": "(seq)",
      "doc": "",
      "module": "subprocess"
    },
    "architecture": {
      "signature": "(executable='D:\\\\a\\\\eud_draft_parser\\\\eud_draft_parser\\\\euddraft0.9.9.4\\\\euddraft.exe', bits='', linkage='')",
      "doc": " Queries the given executable (defaults to the Python interpreter",
      "module": "platform"
    },
    "freedesktop_os_release": {
      "signature": "()",
      "doc": "Return operation system identification from freedesktop.org os-release",
      "module": "platform"
    },
    "java_ver": {
      "signature": "(release='', vendor='', vminfo=('', '', ''), osinfo=('', '', ''))",
      "doc": " Version interface for Jython.",
      "module": "platform"
    },
    "libc_ver": {
      "signature": "(executable=None, lib='', version='', chunksize=16384)",
      "doc": " Tries to determine the libc version that the file executable",
      "module": "platform"
    },
    "mac_ver": {
      "signature": "(release='', versioninfo=('', '', ''), machine='')",
      "doc": " Get macOS version information and return it as tuple (release,",
      "module": "platform"
    },
    "machine": {
      "signature": "()",
      "doc": " Returns the machine type, e.g. 'i386'",
      "module": "platform"
    },
    "node": {
      "signature": "()",
      "doc": " Returns the computer's network name (which may not be fully",
      "module": "platform"
    },
    "platform": {
      "signature": "(aliased=0, terse=0)",
      "doc": " Returns a single string identifying the underlying platform",
      "module": "platform"
    },
    "processor": {
      "signature": "()",
      "doc": " Returns the (true) processor name, e.g. 'amdk6'",
      "module": "platform"
    },
    "python_branch": {
      "signature": "()",
      "doc": " Returns a string identifying the Python implementation",
      "module": "platform"
    },
    "python_build": {
      "signature": "()",
      "doc": " Returns a tuple (buildno, builddate) stating the Python",
      "module": "platform"
    },
    "python_compiler": {
      "signature": "()",
      "doc": " Returns a string identifying the compiler used for compiling",
      "module": "platform"
    },
    "python_implementation": {
      "signature": "()",
      "doc": " Returns a string identifying the Python implementation.",
      "module": "platform"
    },
    "python_revision": {
      "signature": "()",
      "doc": " Returns a string identifying the Python implementation",
      "module": "platform"
    },
    "python_version": {
      "signature": "()",
      "doc": " Returns the Python version as string 'major.minor.patchlevel'",
      "module": "platform"
    },
    "python_version_tuple": {
      "signature": "()",
      "doc": " Returns the Python version as tuple (major, minor, patchlevel)",
      "module": "platform"
    },
    "release": {
      "signature": "()",
      "doc": " Returns the system's release, e.g. '2.2.0' or 'NT'",
      "module": "platform"
    },
    "system": {
      "signature": "()",
      "doc": " Returns the system/OS name, e.g. 'Linux', 'Windows' or 'Java'.",
      "module": "platform"
    },
    "system_alias": {
      "signature": "(system, release, version)",
      "doc": " Returns (system, release, version) aliased to common",
      "module": "platform"
    },
    "uname": {
      "signature": "()",
      "doc": " Fairly portable uname interface. Returns a tuple",
      "module": "platform"
    },
    "version": {
      "signature": "()",
      "doc": " Returns the system's release version, e.g. '#3 on degas'",
      "module": "platform"
    },
    "win32_edition": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "win32_is_iot": {
      "signature": "()",
      "doc": "",
      "module": "platform"
    },
    "win32_ver": {
      "signature": "(release='', version='', csd='', ptype='')",
      "doc": "",
      "module": "platform"
    },
    "EPS_SetDebug": {
      "signature": "(b)",
      "doc": "",
      "module": "eudplib.epscript"
    },
    "epsCompile": {
      "signature": "(filename, bCode)",
      "doc": "",
      "module": "eudplib.epscript"
    },
    "setEpsGlobals": {
      "signature": "(globalList)",
      "doc": "",
      "module": "eudplib.epscript.epscompile"
    },
    "setPyBuiltins": {
      "signature": "(builtinList)",
      "doc": "",
      "module": "eudplib.epscript.epscompile"
    },
    "setPyKeywords": {
      "signature": "(keywordList)",
      "doc": "",
      "module": "eudplib.epscript.epscompile"
    },
    "IsSCDBMap": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.epscript"
    },
    "modifyCodeLineno": {
      "signature": "(codeobj: code, codeMap)",
      "doc": "",
      "module": "eudplib.epscript.epsimp"
    },
    "MoveCP": {
      "signature": "(dest) -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "eudplib.eudlib.s"
    },
    "SetMemoryC": {
      "signature": "(dest, modtype, value) -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "freeze.crypt"
    },
    "SetMemoryS": {
      "signature": "(dest, modtype, value) -> tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "eudplib.eudlib.s"
    },
    "load": {
      "signature": "(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)",
      "doc": "",
      "module": "json"
    },
    "pop": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.eudlib.s"
    },
    "push": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.eudlib.s"
    },
    "rand": {
      "signature": "(dest) -> tuple[typing.Any, typing.Any]",
      "doc": "",
      "module": "eudplib.eudlib.s"
    },
    "srand": {
      "signature": "() -> eudplib.core.rawtrigger.action.Action",
      "doc": "",
      "module": "eudplib.eudlib.s"
    },
    "f_addcurpl": {
      "signature": "(cp)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_setcurpl": {
      "signature": "(cp, *, actions=[], set_modifier=True)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_setcurpl2cpcache": {
      "signature": "(v=[], actions=[])",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_dwadd_epd": {
      "signature": "(targetplayer, value)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_dwepdread_epd_safe": {
      "signature": "(*args, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_dwread_epd_safe": {
      "signature": "(*args, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_dwsubtract_epd": {
      "signature": "(targetplayer, value)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_dwwrite_epd": {
      "signature": "(targetplayer, value)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_epdread_epd_safe": {
      "signature": "(*args, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_flagread_epd": {
      "signature": "(targetplayer, *flags, _readerdict={})",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "setdw_epd": {
      "signature": "(targetplayer, modifier, value)",
      "doc": "",
      "module": "eudplib.eudlib.memiof.dwepdio"
    },
    "f_bread_cp": {
      "signature": "(cpo, subp, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_bwrite_cp": {
      "signature": "(cpo, subp, b)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_dwadd_cp": {
      "signature": "(cpo, value)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_dwepdread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_dwread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_dwsubtract_cp": {
      "signature": "(cpo, value)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_dwwrite_cp": {
      "signature": "(cpo, value)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_epdread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_maskwrite_cp": {
      "signature": "(cpo, value, mask)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_wread_cp": {
      "signature": "(cpo, subp, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_wwrite_cp": {
      "signature": "(cpo, subp, w)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_badd_epd": {
      "signature": "(epd, subp, b)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_bsubtract_epd": {
      "signature": "(epd, subp, b)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_bwrite_epd": {
      "signature": "(epd, subp, b)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_maskwrite_epd": {
      "signature": "(epd, value, mask)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_wadd_epd": {
      "signature": "(epd, subp, w)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_wsubtract_epd": {
      "signature": "(epd, subp, w)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_wwrite_epd": {
      "signature": "(epd, subp, w)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_memcpy": {
      "signature": "(dst, src, copylen, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_cunitepdread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_cunitread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_epdcunitread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_epdspriteread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_maskread_cp": {
      "signature": "(cpoffset, mask, _fdict={}, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_maskread_epd": {
      "signature": "(targetplayer, mask, _fdict={}, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_posread_cp": {
      "signature": "(cpoffset, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_posread_epd": {
      "signature": "(epd, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_readgen_cp": {
      "signature": "(mask, *args, docstring=None, _fdict={4194288: {(4194312, (16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152), True): <function f_readgen_cp.<locals>.f_read_cp_template at 0x0000014FB48B3880>, (4194312, -403671, (16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152), (4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288), True): <function f_readgen_cp.<locals>.f_read_cp_template at 0x0000014FB48B3E20>, (-403671, (4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288), True): <function f_readgen_cp.<locals>.f_read_cp_template at 0x0000014FB48C81F0>}, 131068: {(153383, (1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384), True): <function f_readgen_cp.<locals>.f_read_cp_template at 0x0000014FB48C85E0>, (6422528, 153383, (4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536), (1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384), True): <function f_readgen_cp.<locals>.f_read_cp_template at 0x0000014FB48C8B80>, (6422528, (4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536), True): <function f_readgen_cp.<locals>.f_read_cp_template at 0x0000014FB48C8EE0>}}, _check_empty=False)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_readgen_epd": {
      "signature": "(mask, *args, docstring=None, _fdict={4194288: {(4194312, (16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152), True): <eudplib.core.eudfunc.eudtypedfuncn.EUDTypedFuncN object at 0x0000014FB48A7A30>, (4194312, -403671, (16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152), (4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288), True): <eudplib.core.eudfunc.eudtypedfuncn.EUDTypedFuncN object at 0x0000014FB48A7D30>, (-403671, (4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288), True): <eudplib.core.eudfunc.eudtypedfuncn.EUDTypedFuncN object at 0x0000014FB48CC070>}, 131068: {(153383, (1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384), True): <eudplib.core.eudfunc.eudtypedfuncn.EUDTypedFuncN object at 0x0000014FB48CC3D0>, (6422528, 153383, (4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536), (1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384), True): <eudplib.core.eudfunc.eudtypedfuncn.EUDTypedFuncN object at 0x0000014FB48CC6D0>, (6422528, (4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536), True): <eudplib.core.eudfunc.eudtypedfuncn.EUDTypedFuncN object at 0x0000014FB48CC9D0>}}, _check_empty=False)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_spriteepdread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_spriteread_cp": {
      "signature": "(cpo, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_bread": {
      "signature": "(ptr, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_bwrite": {
      "signature": "(ptr, b)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_dwread": {
      "signature": "(ptr, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_dwwrite": {
      "signature": "(ptr, dw)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_wread": {
      "signature": "(ptr, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_wwrite": {
      "signature": "(ptr, w)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDStack": {
      "signature": "(basetype=None)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_addloc": {
      "signature": "(locID, *coords, action=False)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_dilateloc": {
      "signature": "(locID, *coords, action=False)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_getlocTL": {
      "signature": "(locID, **kwargs) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_setloc": {
      "signature": "(locID, *coords, action=False)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_setloc_epd": {
      "signature": "(locID, epd) -> None",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_pow": {
      "signature": "(a, b)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDBinaryMax": {
      "signature": "(cond, minv=0, maxv=4294967295) -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDBinaryMin": {
      "signature": "(cond, minv=0, maxv=4294967295) -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "Action": {
      "signature": "(locid1: int, strid: int, wavid: int, time: int, player1: int, player2: int, unitid: int, acttype: int, amount: int, flags: int, *, eudx: int = 0) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Briefing": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "Condition": {
      "signature": "(locid: int, player: int, amount: int, unitid: int, comparison: int, condtype: int, restype: int, flag: int, *, eudx: int = 0) -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "NoAction": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "NoCondition": {
      "signature": "() -> bytes",
      "doc": "",
      "module": "eudplib.trigtrg"
    },
    "GetFirstTrigTrigger": {
      "signature": "(player: 'Player') -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "eudplib.trigtrg.runtrigtrg"
    },
    "GetLastTrigTrigger": {
      "signature": "(player: 'Player') -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "eudplib.trigtrg.runtrigtrg"
    },
    "TrigTriggerBegin": {
      "signature": "(player: 'Player') -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "eudplib.trigtrg.runtrigtrg"
    },
    "TrigTriggerEnd": {
      "signature": "(player)",
      "doc": "",
      "module": "eudplib.trigtrg.runtrigtrg"
    },
    "copy": {
      "signature": "(src, dst, *, follow_symlinks=True)",
      "doc": "Copy data and mode bits (\"cp src dst\"). Return the file's destination.",
      "module": "shutil"
    },
    "deepcopy": {
      "signature": "(x, memo=None, _nil=[])",
      "doc": "Deep copy operation on arbitrary Python objects.",
      "module": "copy"
    },
    "asdict": {
      "signature": "(obj, *, dict_factory=<class 'dict'>)",
      "doc": "Return the fields of a dataclass instance as a new dictionary mapping",
      "module": "dataclasses"
    },
    "astuple": {
      "signature": "(obj, *, tuple_factory=<class 'tuple'>)",
      "doc": "Return the fields of a dataclass instance as a new tuple of field values.",
      "module": "dataclasses"
    },
    "dataclass": {
      "signature": "(cls=None, /, *, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False)",
      "doc": "Returns the same class as was passed in, with dunder methods",
      "module": "eudplib.eudlib.objpool"
    },
    "field": {
      "signature": "(*, default=<dataclasses._MISSING_TYPE object at 0x0000014FB48FD060>, default_factory=<dataclasses._MISSING_TYPE object at 0x0000014FB48FD060>, init=True, repr=True, hash=None, compare=True, metadata=None, kw_only=<dataclasses._MISSING_TYPE object at 0x0000014FB48FD060>)",
      "doc": "Return an object to identify dataclass fields.",
      "module": "dataclasses"
    },
    "fields": {
      "signature": "(class_or_instance)",
      "doc": "Return a tuple describing the fields of this dataclass.",
      "module": "dataclasses"
    },
    "is_dataclass": {
      "signature": "(obj)",
      "doc": "Returns True if obj is a dataclass or an instance of a",
      "module": "dataclasses"
    },
    "make_dataclass": {
      "signature": "(cls_name, fields, *, bases=(), namespace=None, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False)",
      "doc": "Return a new dynamically created dataclass.",
      "module": "dataclasses"
    },
    "replace": {
      "signature": "(obj, /, **changes)",
      "doc": "Return a new object replacing specified fields with new values.",
      "module": "dataclasses"
    },
    "IsUnlimiterOn": {
      "signature": "() -> bool",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EPDCache": {
      "signature": "(ptr: eudplib.core.variable.eudv.EUDVariable) -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "eudplib.offsetmap.csprite"
    },
    "PtrCache": {
      "signature": "(epd: eudplib.core.variable.eudv.EUDVariable) -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "eudplib.offsetmap.csprite"
    },
    "EUDAnd": {
      "signature": "(cond1, *conds) -> eudplib.core.variable.eudlv.EUDLightBool",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDNot": {
      "signature": "(cond)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDOr": {
      "signature": "(cond1, *conds) -> eudplib.core.variable.eudlv.EUDLightBool",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "poppatchstack": {
      "signature": "() -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "eudplib.eudlib.utilf.mempatch"
    },
    "pushpatchstack": {
      "signature": "(value: eudplib.core.variable.eudv.EUDVariable | int) -> None",
      "doc": "",
      "module": "eudplib.eudlib.utilf.mempatch"
    },
    "EUDEndPlayerLoop": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDLoopPlayer": {
      "signature": "(ptype: str | None = 'Human', force=None, race: str | None = None) -> collections.abc.Iterator[eudplib.core.variable.eudv.EUDVariable]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDPlayerLoop": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_getseed": {
      "signature": "() -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_srand": {
      "signature": "(seed) -> None",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "CenterViewAll": {
      "signature": "(location) -> tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "DisplayTextAll": {
      "signature": "(text) -> tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "IsUserCP": {
      "signature": "() -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "MinimapPingAll": {
      "signature": "(location) -> tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "PlayWAVAll": {
      "signature": "(soundpath) -> tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "RCPC_ResetUserP": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.eudlib.utilf.userpl"
    },
    "SetMissionObjectivesAll": {
      "signature": "(text) -> tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "TalkingPortraitAll": {
      "signature": "(unit, time) -> tuple[eudplib.core.rawtrigger.action.Action, eudplib.core.rawtrigger.action.Action]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_getuserplayerid": {
      "signature": "() -> eudplib.core.variable.eudv.EUDVariable",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDLoopBullet": {
      "signature": "() -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDLoopCUnit": {
      "signature": "() -> collections.abc.Iterator[eudplib.offsetmap.cunit.CUnit]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDLoopList": {
      "signature": "(header_offset, break_offset=None) -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDLoopNewCUnit": {
      "signature": "(allowance: int = 2) -> collections.abc.Iterator[eudplib.offsetmap.cunit.CUnit]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDLoopNewUnit": {
      "signature": "(allowance: int = 2) -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDLoopPlayerCUnit": {
      "signature": "(player) -> collections.abc.Iterator[eudplib.offsetmap.cunit.CUnit]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDLoopPlayerUnit": {
      "signature": "(player) -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDLoopSprite": {
      "signature": "() -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDLoopTrigger": {
      "signature": "(player) -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDLoopUnit": {
      "signature": "() -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDLoopUnit2": {
      "signature": "() -> collections.abc.Iterator[tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]]",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_dbstr_print": {
      "signature": "(dst, *args, EOS=True, encoding='UTF-8')",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "PColor": {
      "signature": "(i)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "PName": {
      "signature": "(x)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_cpstr_print": {
      "signature": "(*args, EOS=True, encoding='UTF-8')",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_eprintln": {
      "signature": "(*args)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_eprintln2": {
      "signature": "(*args)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "clear_cache": {
      "signature": "()",
      "doc": "Clear the parse cache and the quoters cache.",
      "module": "urllib.parse"
    },
    "parse_qs": {
      "signature": "(qs, keep_blank_values=False, strict_parsing=False, encoding='utf-8', errors='replace', max_num_fields=None, separator='&')",
      "doc": "Parse a query given as a string argument.",
      "module": "urllib.parse"
    },
    "parse_qsl": {
      "signature": "(qs, keep_blank_values=False, strict_parsing=False, encoding='utf-8', errors='replace', max_num_fields=None, separator='&')",
      "doc": "Parse a query given as a string argument.",
      "module": "urllib.parse"
    },
    "quote": {
      "signature": "(string, safe='/', encoding=None, errors=None)",
      "doc": "quote('abc def') -> 'abc%20def'",
      "module": "urllib.request"
    },
    "quote_from_bytes": {
      "signature": "(bs, safe='/')",
      "doc": "Like quote(), but accepts a bytes object rather than a str, and does",
      "module": "urllib.parse"
    },
    "quote_plus": {
      "signature": "(string, safe='', encoding=None, errors=None)",
      "doc": "Like quote(), but also replace ' ' with '+', as required for quoting",
      "module": "urllib.parse"
    },
    "splitattr": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splithost": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splitnport": {
      "signature": "(host, defport=-1)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splitpasswd": {
      "signature": "(user)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splitport": {
      "signature": "(host)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splitquery": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splittag": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splittype": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splituser": {
      "signature": "(host)",
      "doc": "",
      "module": "urllib.parse"
    },
    "splitvalue": {
      "signature": "(attr)",
      "doc": "",
      "module": "urllib.parse"
    },
    "to_bytes": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.parse"
    },
    "unquote": {
      "signature": "(string, encoding='utf-8', errors='replace')",
      "doc": "Replace %xx escapes by their single-character equivalent. The optional",
      "module": "urllib.request"
    },
    "unquote_plus": {
      "signature": "(string, encoding='utf-8', errors='replace')",
      "doc": "Like unquote(), but also replace plus signs by spaces, as required for",
      "module": "urllib.parse"
    },
    "unquote_to_bytes": {
      "signature": "(string)",
      "doc": "unquote_to_bytes('abc%20def') -> b'abc def'.",
      "module": "urllib.request"
    },
    "urldefrag": {
      "signature": "(url)",
      "doc": "Removes any existing fragment from URL.",
      "module": "urllib.parse"
    },
    "urlencode": {
      "signature": "(query, doseq=False, safe='', encoding=None, errors=None, quote_via=<function quote_plus at 0x0000014FB4E59120>)",
      "doc": "Encode a dict or sequence of two-element tuples into a URL query string.",
      "module": "urllib.parse"
    },
    "urljoin": {
      "signature": "(base, url, allow_fragments=True)",
      "doc": "Join a base URL and a possibly relative URL to form an absolute",
      "module": "urllib.request"
    },
    "urlparse": {
      "signature": "(url, scheme='', allow_fragments=True)",
      "doc": "Parse a URL into 6 components:",
      "module": "urllib.request"
    },
    "urlsplit": {
      "signature": "(url, scheme='', allow_fragments=True)",
      "doc": "Parse a URL into 5 components:",
      "module": "urllib.request"
    },
    "urlunparse": {
      "signature": "(components)",
      "doc": "Put a parsed URL back together again.  This may result in a",
      "module": "urllib.request"
    },
    "urlunsplit": {
      "signature": "(components)",
      "doc": "Combine the elements of a tuple as returned by urlsplit() into a",
      "module": "urllib.parse"
    },
    "message_from_binary_file": {
      "signature": "(fp, *args, **kws)",
      "doc": "Read a binary file and parse its contents into a Message object model.",
      "module": "email"
    },
    "message_from_bytes": {
      "signature": "(s, *args, **kws)",
      "doc": "Parse a bytes string into a Message object model.",
      "module": "email"
    },
    "message_from_file": {
      "signature": "(fp, *args, **kws)",
      "doc": "Read a file and parse its contents into a Message object model.",
      "module": "email"
    },
    "message_from_string": {
      "signature": "(s, *args, **kws)",
      "doc": "Parse a string into a Message object model.",
      "module": "email"
    },
    "body_check": {
      "signature": "(octet)",
      "doc": "Return True if the octet should be escaped with body quopri.",
      "module": "email.quoprimime"
    },
    "body_decode": {
      "signature": "(string)",
      "doc": "Decode a raw base64 string, returning a bytes object.",
      "module": "email.base64mime"
    },
    "body_encode": {
      "signature": "(s, maxlinelen=76, eol='\\n')",
      "doc": "Encode a string with base64.",
      "module": "email.base64mime"
    },
    "body_length": {
      "signature": "(bytearray)",
      "doc": "Return a body quoted-printable encoding length.",
      "module": "email.quoprimime"
    },
    "decodestring": {
      "signature": "(s, header=False)",
      "doc": "",
      "module": "quopri"
    },
    "header_check": {
      "signature": "(octet)",
      "doc": "Return True if the octet should be escaped with header quopri.",
      "module": "email.quoprimime"
    },
    "header_decode": {
      "signature": "(s)",
      "doc": "Decode a string encoded with RFC 2045 MIME header `Q' encoding.",
      "module": "email.quoprimime"
    },
    "header_encode": {
      "signature": "(header_bytes, charset='iso-8859-1')",
      "doc": "Encode a single header line with Base64 encoding in a given charset.",
      "module": "email.base64mime"
    },
    "header_length": {
      "signature": "(bytearray)",
      "doc": "Return the length of s when it is encoded with base64.",
      "module": "email.base64mime"
    },
    "a85decode": {
      "signature": "(b, *, foldspaces=False, adobe=False, ignorechars=b' \\t\\n\\r\\x0b')",
      "doc": "Decode the Ascii85 encoded bytes-like object or ASCII string b.",
      "module": "base64"
    },
    "a85encode": {
      "signature": "(b, *, foldspaces=False, wrapcol=0, pad=False, adobe=False)",
      "doc": "Encode bytes-like object b using Ascii85 and return a bytes object.",
      "module": "base64"
    },
    "b16decode": {
      "signature": "(s, casefold=False)",
      "doc": "Decode the Base16 encoded bytes-like object or ASCII string s.",
      "module": "base64"
    },
    "b16encode": {
      "signature": "(s)",
      "doc": "Encode the bytes-like object s using Base16 and return a bytes object.",
      "module": "base64"
    },
    "b32decode": {
      "signature": "(s, casefold=False, map01=None)",
      "doc": "",
      "module": "base64"
    },
    "b32encode": {
      "signature": "(s)",
      "doc": "",
      "module": "base64"
    },
    "b32hexdecode": {
      "signature": "(s, casefold=False)",
      "doc": "",
      "module": "base64"
    },
    "b32hexencode": {
      "signature": "(s)",
      "doc": "",
      "module": "base64"
    },
    "b64decode": {
      "signature": "(s, altchars=None, validate=False)",
      "doc": "Decode the Base64 encoded bytes-like object or ASCII string s.",
      "module": "base64"
    },
    "b64encode": {
      "signature": "(s, altchars=None)",
      "doc": "Encode the bytes-like object s using Base64 and return a bytes object.",
      "module": "email.base64mime"
    },
    "b85decode": {
      "signature": "(b)",
      "doc": "Decode the base85-encoded bytes-like object or ASCII string b",
      "module": "base64"
    },
    "b85encode": {
      "signature": "(b, pad=False)",
      "doc": "Encode bytes-like object b in base85 format and return a bytes object.",
      "module": "base64"
    },
    "decodebytes": {
      "signature": "(s)",
      "doc": "Decode a bytestring of base-64 data into a bytes object.",
      "module": "base64"
    },
    "encode": {
      "signature": "(string, charset='utf-8', encoding=None, lang='')",
      "doc": "Encode string using the CTE encoding that produces the shorter result.",
      "module": "email._encoded_words"
    },
    "encodebytes": {
      "signature": "(s)",
      "doc": "Encode a bytestring into a bytes object containing multiple lines",
      "module": "base64"
    },
    "standard_b64decode": {
      "signature": "(s)",
      "doc": "Decode bytes encoded with the standard Base64 alphabet.",
      "module": "base64"
    },
    "standard_b64encode": {
      "signature": "(s)",
      "doc": "Encode bytes-like object s using the standard Base64 alphabet.",
      "module": "base64"
    },
    "test": {
      "signature": "(environ=environ({'ACTIONS_RUNNER_ACTION_ARCHIVE_CACHE': 'C:\\\\actionarchivecache\\\\', 'AGENT_TOOLSDIRECTORY': 'C:\\\\hostedtoolcache\\\\windows', 'ALLUSERSPROFILE': 'C:\\\\ProgramData', 'ANDROID_HOME': 'C:\\\\Android\\\\android-sdk', 'ANDROID_NDK': 'C:\\\\Android\\\\android-sdk\\\\ndk\\\\27.2.12479018', 'ANDROID_NDK_HOME': 'C:\\\\Android\\\\android-sdk\\\\ndk\\\\27.2.12479018', 'ANDROID_NDK_LATEST_HOME': 'C:\\\\Android\\\\android-sdk\\\\ndk\\\\27.2.12479018', 'ANDROID_NDK_ROOT': 'C:\\\\Android\\\\android-sdk\\\\ndk\\\\27.2.12479018', 'ANDROID_SDK_ROOT': 'C:\\\\Android\\\\android-sdk', 'ANT_HOME': 'C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\ant\\\\tools\\\\apache-ant-1.10.14', 'APPDATA': 'C:\\\\Users\\\\runneradmin\\\\AppData\\\\Roaming', 'AZURE_CONFIG_DIR': 'C:\\\\azureCli', 'AZURE_DEVOPS_CACHE_DIR': 'C:\\\\azureDevOpsCli\\\\cache', 'AZURE_EXTENSION_DIR': 'C:\\\\Program Files\\\\Common Files\\\\AzureCliExtensionDirectory', 'AZ_DEVOPS_GLOBAL_CONFIG_DIR': 'C:\\\\azureDevOpsCli', 'CABAL_DIR': 'C:\\\\cabal', 'CHOCOLATEYINSTALL': 'C:\\\\ProgramData\\\\chocolatey', 'CHROMEWEBDRIVER': 'C:\\\\SeleniumWebDrivers\\\\ChromeDriver', 'CI': 'true', 'COBERTURA_HOME': 'C:\\\\cobertura-2.1.1', 'COMMONPROGRAMFILES': 'C:\\\\Program Files\\\\Common Files', 'COMMONPROGRAMFILES(X86)': 'C:\\\\Program Files (x86)\\\\Common Files', 'COMMONPROGRAMW6432': 'C:\\\\Program Files\\\\Common Files', 'COMPUTERNAME': 'fv-az688-556', 'COMSPEC': 'C:\\\\Windows\\\\system32\\\\cmd.exe', 'CONDA': 'C:\\\\Miniconda', 'DEPLOYMENT_BASEPATH': 'C:\\\\actions', 'DOTNET_MULTILEVEL_LOOKUP': '0', 'DOTNET_NOLOGO': '1', 'DOTNET_SKIP_FIRST_TIME_EXPERIENCE': '1', 'DRIVERDATA': 'C:\\\\Windows\\\\System32\\\\Drivers\\\\DriverData', 'EDGEWEBDRIVER': 'C:\\\\SeleniumWebDrivers\\\\EdgeDriver', 'GCM_INTERACTIVE': 'Never', 'GECKOWEBDRIVER': 'C:\\\\SeleniumWebDrivers\\\\GeckoDriver', 'GHCUP_INSTALL_BASE_PREFIX': 'C:\\\\', 'GHCUP_MSYS2': 'C:\\\\msys64', 'GITHUB_ACTION': '__run_2', 'GITHUB_ACTIONS': 'true', 'GITHUB_ACTION_REF': '', 'GITHUB_ACTION_REPOSITORY': '', 'GITHUB_ACTOR': 'Tb1281', 'GITHUB_ACTOR_ID': '96616508', 'GITHUB_API_URL': 'https://api.github.com', 'GITHUB_BASE_REF': '', 'GITHUB_ENV': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\set_env_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_EVENT_NAME': 'workflow_dispatch', 'GITHUB_EVENT_PATH': 'D:\\\\a\\\\_temp\\\\_github_workflow\\\\event.json', 'GITHUB_GRAPHQL_URL': 'https://api.github.com/graphql', 'GITHUB_HEAD_REF': '', 'GITHUB_JOB': 'download_and_run', 'GITHUB_OUTPUT': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\set_output_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_PATH': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\add_path_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_REF': 'refs/heads/main', 'GITHUB_REF_NAME': 'main', 'GITHUB_REF_PROTECTED': 'false', 'GITHUB_REF_TYPE': 'branch', 'GITHUB_REPOSITORY': 'Tb1281/eud_draft_parser', 'GITHUB_REPOSITORY_ID': '894892658', 'GITHUB_REPOSITORY_OWNER': 'Tb1281', 'GITHUB_REPOSITORY_OWNER_ID': '96616508', 'GITHUB_RETENTION_DAYS': '90', 'GITHUB_RUN_ATTEMPT': '1', 'GITHUB_RUN_ID': '12061405809', 'GITHUB_RUN_NUMBER': '21', 'GITHUB_SERVER_URL': 'https://github.com', 'GITHUB_SHA': 'f063bfe49187dd4de9c341b24a010a601ebc89b5', 'GITHUB_STATE': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\save_state_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_STEP_SUMMARY': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\step_summary_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_TRIGGERING_ACTOR': 'Tb1281', 'GITHUB_WORKFLOW': 'Sync and Run Other Repo Releases', 'GITHUB_WORKFLOW_REF': 'Tb1281/eud_draft_parser/.github/workflows/sync.yaml@refs/heads/main', 'GITHUB_WORKFLOW_SHA': 'f063bfe49187dd4de9c341b24a010a601ebc89b5', 'GITHUB_WORKSPACE': 'D:\\\\a\\\\eud_draft_parser\\\\eud_draft_parser', 'GOROOT_1_20_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.20.14\\\\x64', 'GOROOT_1_21_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.21.13\\\\x64', 'GOROOT_1_22_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.22.9\\\\x64', 'GOROOT_1_23_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.23.3\\\\x64', 'GRADLE_HOME': 'C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\gradle\\\\tools\\\\gradle-8.11.1', 'HOMEDRIVE': 'C:', 'HOMEPATH': '\\\\Users\\\\runneradmin', 'IEWEBDRIVER': 'C:\\\\SeleniumWebDrivers\\\\IEDriver', 'IMAGEOS': 'win22', 'IMAGEVERSION': '20241125.1.0', 'JAVA_HOME': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\8.0.432-6\\\\x64', 'JAVA_HOME_11_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\11.0.25-9\\\\x64', 'JAVA_HOME_17_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\17.0.13-11\\\\x64', 'JAVA_HOME_21_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\21.0.5-11.0\\\\x64', 'JAVA_HOME_8_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\8.0.432-6\\\\x64', 'LOCALAPPDATA': 'C:\\\\Users\\\\runneradmin\\\\AppData\\\\Local', 'LOGONSERVER': '\\\\\\\\fv-az688-556', 'M2': 'C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\maven\\\\apache-maven-3.8.7\\\\bin', 'M2_REPO': 'C:\\\\ProgramData\\\\m2', 'MAVEN_OPTS': '-Xms256m', 'NPM_CONFIG_PREFIX': 'C:\\\\npm\\\\prefix', 'NUMBER_OF_PROCESSORS': '2', 'OS': 'Windows_NT', 'PATH': 'C:\\\\Program Files\\\\PowerShell\\\\7;C:\\\\Program Files\\\\MongoDB\\\\Server\\\\5.0\\\\bin;C:\\\\aliyun-cli;C:\\\\vcpkg;C:\\\\Program Files (x86)\\\\NSIS\\\\;C:\\\\tools\\\\zstd;C:\\\\Program Files\\\\Mercurial\\\\;C:\\\\hostedtoolcache\\\\windows\\\\stack\\\\3.1.1\\\\x64;C:\\\\cabal\\\\bin;C:\\\\\\\\ghcup\\\\bin;C:\\\\mingw64\\\\bin;C:\\\\Program Files\\\\dotnet;C:\\\\Program Files\\\\MySQL\\\\MySQL Server 8.0\\\\bin;C:\\\\Program Files\\\\R\\\\R-4.4.2\\\\bin\\\\x64;C:\\\\SeleniumWebDrivers\\\\GeckoDriver;C:\\\\SeleniumWebDrivers\\\\EdgeDriver\\\\;C:\\\\SeleniumWebDrivers\\\\ChromeDriver;C:\\\\Program Files (x86)\\\\sbt\\\\bin;C:\\\\Program Files (x86)\\\\GitHub CLI;C:\\\\Program Files\\\\Git\\\\bin;C:\\\\Program Files (x86)\\\\pipx_bin;C:\\\\npm\\\\prefix;C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.21.13\\\\x64\\\\bin;C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\3.9.13\\\\x64\\\\Scripts;C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\3.9.13\\\\x64;C:\\\\hostedtoolcache\\\\windows\\\\Ruby\\\\3.0.7\\\\x64\\\\bin;C:\\\\Program Files\\\\OpenSSL\\\\bin;C:\\\\tools\\\\kotlinc\\\\bin;C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\8.0.432-6\\\\x64\\\\bin;C:\\\\Program Files\\\\ImageMagick-7.1.1-Q16-HDRI;C:\\\\Program Files\\\\Microsoft SDKs\\\\Azure\\\\CLI2\\\\wbin;C:\\\\ProgramData\\\\kind;C:\\\\ProgramData\\\\Chocolatey\\\\bin;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Windows\\\\System32\\\\OpenSSH\\\\;C:\\\\Program Files\\\\dotnet\\\\;C:\\\\Program Files\\\\PowerShell\\\\7\\\\;C:\\\\Program Files\\\\Microsoft\\\\Web Platform Installer\\\\;C:\\\\Program Files\\\\TortoiseSVN\\\\bin;C:\\\\Program Files\\\\Microsoft SQL Server\\\\Client SDK\\\\ODBC\\\\170\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\150\\\\Tools\\\\Binn\\\\;C:\\\\Program Files (x86)\\\\Windows Kits\\\\10\\\\Windows Performance Toolkit\\\\;C:\\\\Program Files (x86)\\\\WiX Toolset v3.14\\\\bin;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\DTS\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\140\\\\DTS\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\150\\\\DTS\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\160\\\\DTS\\\\Binn\\\\;C:\\\\Strawberry\\\\c\\\\bin;C:\\\\Strawberry\\\\perl\\\\site\\\\bin;C:\\\\Strawberry\\\\perl\\\\bin;C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\pulumi\\\\tools\\\\Pulumi\\\\bin;C:\\\\Program Files\\\\CMake\\\\bin;C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\maven\\\\apache-maven-3.8.7\\\\bin;C:\\\\Program Files\\\\Microsoft Service Fabric\\\\bin\\\\Fabric\\\\Fabric.Code;C:\\\\Program Files\\\\Microsoft SDKs\\\\Service Fabric\\\\Tools\\\\ServiceFabricLocalClusterManager;C:\\\\Program Files\\\\nodejs\\\\;C:\\\\Program Files\\\\Git\\\\cmd;C:\\\\Program Files\\\\Git\\\\mingw64\\\\bin;C:\\\\Program Files\\\\Git\\\\usr\\\\bin;C:\\\\Program Files\\\\GitHub CLI\\\\;c:\\\\tools\\\\php;C:\\\\Program Files (x86)\\\\sbt\\\\bin;C:\\\\Program Files\\\\Amazon\\\\AWSCLIV2\\\\;C:\\\\Program Files\\\\Amazon\\\\SessionManagerPlugin\\\\bin\\\\;C:\\\\Program Files\\\\Amazon\\\\AWSSAMCLI\\\\bin\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\LLVM\\\\bin;C:\\\\Users\\\\runneradmin\\\\.dotnet\\\\tools;C:\\\\Users\\\\runneradmin\\\\.cargo\\\\bin;C:\\\\Users\\\\runneradmin\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps', 'PATHEXT': '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.CPL', 'PERFLOG_LOCATION_SETTING': 'RUNNER_PERFLOG', 'PGBIN': 'C:\\\\Program Files\\\\PostgreSQL\\\\14\\\\bin', 'PGDATA': 'C:\\\\Program Files\\\\PostgreSQL\\\\14\\\\data', 'PGPASSWORD': 'root', 'PGROOT': 'C:\\\\Program Files\\\\PostgreSQL\\\\14', 'PGUSER': 'postgres', 'PHPROOT': 'c:\\\\tools\\\\php', 'PIPX_BIN_DIR': 'C:\\\\Program Files (x86)\\\\pipx_bin', 'PIPX_HOME': 'C:\\\\Program Files (x86)\\\\pipx', 'POWERSHELL_DISTRIBUTION_CHANNEL': 'GitHub-Actions-win22', 'POWERSHELL_UPDATECHECK': 'Off', 'PROCESSOR_ARCHITECTURE': 'AMD64', 'PROCESSOR_IDENTIFIER': 'AMD64 Family 25 Model 1 Stepping 1, AuthenticAMD', 'PROCESSOR_LEVEL': '25', 'PROCESSOR_REVISION': '0101', 'PROGRAMDATA': 'C:\\\\ProgramData', 'PROGRAMFILES': 'C:\\\\Program Files', 'PROGRAMFILES(X86)': 'C:\\\\Program Files (x86)', 'PROGRAMW6432': 'C:\\\\Program Files', 'PROMPT': '$P$G', 'PSMODULEANALYSISCACHEPATH': 'C:\\\\PSModuleAnalysisCachePath\\\\ModuleAnalysisCache', 'PSMODULEPATH': 'C:\\\\Users\\\\runneradmin\\\\Documents\\\\PowerShell\\\\Modules;C:\\\\Program Files\\\\PowerShell\\\\Modules;c:\\\\program files\\\\powershell\\\\7\\\\Modules;C:\\\\\\\\Modules\\\\azurerm_2.1.0;C:\\\\\\\\Modules\\\\azure_2.1.0;C:\\\\Users\\\\packer\\\\Documents\\\\WindowsPowerShell\\\\Modules;C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\Windows\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\Tools\\\\PowerShell\\\\Modules\\\\', 'PUBLIC': 'C:\\\\Users\\\\Public', 'RTOOLS44_HOME': 'C:\\\\rtools44', 'RUNNER_ARCH': 'X64', 'RUNNER_ENVIRONMENT': 'github-hosted', 'RUNNER_NAME': 'GitHub Actions 9', 'RUNNER_OS': 'Windows', 'RUNNER_PERFLOG': 'C:\\\\actions\\\\perflog', 'RUNNER_TEMP': 'D:\\\\a\\\\_temp', 'RUNNER_TOOL_CACHE': 'C:\\\\hostedtoolcache\\\\windows', 'RUNNER_TRACKING_ID': 'github_090bc668-8081-433b-9fac-107b5217c587', 'RUNNER_WORKSPACE': 'D:\\\\a\\\\eud_draft_parser', 'SBT_HOME': 'C:\\\\Program Files (x86)\\\\sbt\\\\', 'SELENIUM_JAR_PATH': 'C:\\\\selenium\\\\selenium-server.jar', 'STATS_D': 'true', 'STATS_D_D': 'true', 'STATS_D_TC': 'true', 'STATS_EXT': 'true', 'STATS_EXTP': 'https://provjobdprod.z13.web.core.windows.net/settings/provjobdsettings-latest/provjobd.data', 'STATS_PIP': 'false', 'STATS_RDCL': 'true', 'STATS_TRP': 'true', 'STATS_UE': 'true', 'STATS_V3PS': 'true', 'STATS_VMD': 'true', 'STATS_VMFE': 'true', 'SYSTEMDRIVE': 'C:', 'SYSTEMROOT': 'C:\\\\Windows', 'TEMP': 'C:\\\\Users\\\\RUNNER~1\\\\AppData\\\\Local\\\\Temp', 'TMP': 'C:\\\\Users\\\\RUNNER~1\\\\AppData\\\\Local\\\\Temp', 'USERDOMAIN': 'fv-az688-556', 'USERDOMAIN_ROAMINGPROFILE': 'fv-az688-556', 'USERNAME': 'runneradmin', 'USERPROFILE': 'C:\\\\Users\\\\runneradmin', 'VCPKG_INSTALLATION_ROOT': 'C:\\\\vcpkg', 'WINDIR': 'C:\\\\Windows', 'WIX': 'C:\\\\Program Files (x86)\\\\WiX Toolset v3.14\\\\'}))",
      "doc": "",
      "module": "cgi"
    },
    "urlsafe_b64decode": {
      "signature": "(s)",
      "doc": "Decode bytes using the URL- and filesystem-safe Base64 alphabet.",
      "module": "base64"
    },
    "urlsafe_b64encode": {
      "signature": "(s)",
      "doc": "Encode bytes using the URL- and filesystem-safe Base64 alphabet.",
      "module": "base64"
    },
    "encodestring": {
      "signature": "(s, quotetabs=False, header=False)",
      "doc": "",
      "module": "quopri"
    },
    "ishex": {
      "signature": "(c)",
      "doc": "Return true if the byte ordinal 'c' is a hexadecimal digit in ASCII.",
      "module": "quopri"
    },
    "needsquoting": {
      "signature": "(c, quotetabs, header)",
      "doc": "Decide whether a particular byte ordinal needs to be quoted.",
      "module": "quopri"
    },
    "unhex": {
      "signature": "(s)",
      "doc": "Get the integer value of a hexadecimal number.",
      "module": "quopri"
    },
    "encode_7or8bit": {
      "signature": "(msg)",
      "doc": "Set the Content-Transfer-Encoding header to 7bit or 8bit.",
      "module": "email.charset"
    },
    "encode_base64": {
      "signature": "(msg)",
      "doc": "Encode the message's payload in Base64.",
      "module": "email.encoders"
    },
    "encode_noop": {
      "signature": "(msg)",
      "doc": "Do nothing.",
      "module": "email.encoders"
    },
    "encode_quopri": {
      "signature": "(msg)",
      "doc": "Encode the message's payload in quoted-printable.",
      "module": "email.encoders"
    },
    "add_alias": {
      "signature": "(alias, canonical)",
      "doc": "Add a character set alias.",
      "module": "email.charset"
    },
    "add_charset": {
      "signature": "(charset, header_enc=None, body_enc=None, output_charset=None)",
      "doc": "Add character set properties to the global registry.",
      "module": "email.charset"
    },
    "add_codec": {
      "signature": "(charset, codecname)",
      "doc": "Add a codec that map characters in the given charset to/from Unicode.",
      "module": "email.charset"
    },
    "decode_header": {
      "signature": "(header)",
      "doc": "Decode a message header value without converting charset.",
      "module": "email.header"
    },
    "make_header": {
      "signature": "(decoded_seq, maxlinelen=None, header_name=None, continuation_ws=' ')",
      "doc": "Create a Header from a sequence of pairs as returned by decode_header()",
      "module": "email.header"
    },
    "formatstring": {
      "signature": "(cols, colwidth=20, spacing=6)",
      "doc": "Returns a string formatted from n strings, centered within n columns.",
      "module": "calendar"
    },
    "isleap": {
      "signature": "(year)",
      "doc": "Return True for leap years, False for non-leap years.",
      "module": "calendar"
    },
    "leapdays": {
      "signature": "(y1, y2)",
      "doc": "Return number of leap years in range [y1, y2).",
      "module": "calendar"
    },
    "monthrange": {
      "signature": "(year, month)",
      "doc": "Return weekday (0-6 ~ Mon-Sun) and number of days (28-31) for",
      "module": "calendar"
    },
    "setfirstweekday": {
      "signature": "(firstweekday)",
      "doc": "",
      "module": "calendar"
    },
    "timegm": {
      "signature": "(tuple)",
      "doc": "Unrelated but handy function to calculate Unix timestamp from GMT.",
      "module": "calendar"
    },
    "weekday": {
      "signature": "(year, month, day)",
      "doc": "Return weekday (0-6 ~ Mon-Sun) for year, month (1-12), day (1-31).",
      "module": "calendar"
    },
    "mktime_tz": {
      "signature": "(data)",
      "doc": "Turn a 10-tuple as returned by parsedate_tz() into a POSIX timestamp.",
      "module": "email.utils"
    },
    "parsedate": {
      "signature": "(data)",
      "doc": "Convert a time string to a time tuple.",
      "module": "email.utils"
    },
    "parsedate_tz": {
      "signature": "(data)",
      "doc": "Convert a date string to a time tuple.",
      "module": "email.utils"
    },
    "collapse_rfc2231_value": {
      "signature": "(value, errors='replace', fallback_charset='us-ascii')",
      "doc": "",
      "module": "email.utils"
    },
    "decode_params": {
      "signature": "(params)",
      "doc": "Decode parameters list according to RFC 2231.",
      "module": "email.utils"
    },
    "decode_rfc2231": {
      "signature": "(s)",
      "doc": "Decode string according to RFC 2231",
      "module": "email.utils"
    },
    "encode_rfc2231": {
      "signature": "(s, charset=None, language=None)",
      "doc": "Encode string according to RFC 2231.",
      "module": "email.utils"
    },
    "format_datetime": {
      "signature": "(dt, usegmt=False)",
      "doc": "Turn a datetime into a date string as specified in RFC 2822.",
      "module": "email.utils"
    },
    "formataddr": {
      "signature": "(pair, charset='utf-8')",
      "doc": "The inverse of parseaddr(), this takes a 2-tuple of the form",
      "module": "email.utils"
    },
    "formatdate": {
      "signature": "(timeval=None, localtime=False, usegmt=False)",
      "doc": "Returns a date string as specified by RFC 2822, e.g.:",
      "module": "email.utils"
    },
    "getaddresses": {
      "signature": "(fieldvalues)",
      "doc": "Return a list of (REALNAME, EMAIL) for each fieldvalue.",
      "module": "email.utils"
    },
    "localtime": {
      "signature": "(dt=None, isdst=-1)",
      "doc": "Return local time as an aware datetime object.",
      "module": "email.utils"
    },
    "make_msgid": {
      "signature": "(idstring=None, domain=None)",
      "doc": "Returns a string suitable for RFC 2822 compliant Message-ID, e.g:",
      "module": "email.utils"
    },
    "parseaddr": {
      "signature": "(addr)",
      "doc": "",
      "module": "email.utils"
    },
    "parsedate_to_datetime": {
      "signature": "(data)",
      "doc": "",
      "module": "email.utils"
    },
    "decode_b": {
      "signature": "(encoded)",
      "doc": "",
      "module": "email.message"
    },
    "decode_q": {
      "signature": "(encoded)",
      "doc": "",
      "module": "email._encoded_words"
    },
    "encode_b": {
      "signature": "(bstring)",
      "doc": "",
      "module": "email._encoded_words"
    },
    "encode_q": {
      "signature": "(bstring)",
      "doc": "",
      "module": "email._encoded_words"
    },
    "len_b": {
      "signature": "(bstring)",
      "doc": "",
      "module": "email._encoded_words"
    },
    "len_q": {
      "signature": "(bstring)",
      "doc": "",
      "module": "email._encoded_words"
    },
    "body_line_iterator": {
      "signature": "(msg, decode=False)",
      "doc": "Iterate over the parts, returning string payloads line-by-line.",
      "module": "email.iterators"
    },
    "typed_subpart_iterator": {
      "signature": "(msg, maintype='text', subtype=None)",
      "doc": "Iterate over the subparts with a given MIME type.",
      "module": "email.iterators"
    },
    "unescape": {
      "signature": "(s)",
      "doc": "",
      "module": "html"
    },
    "filter": {
      "signature": "(names, pat)",
      "doc": "Construct a list from those elements of the iterable NAMES that match PAT.",
      "module": "fnmatch"
    },
    "fnmatch": {
      "signature": "(name, pat)",
      "doc": "Test whether FILENAME matches PATTERN.",
      "module": "fnmatch"
    },
    "fnmatchcase": {
      "signature": "(name, pat)",
      "doc": "Test whether FILENAME matches PATTERN, including case.",
      "module": "fnmatch"
    },
    "translate": {
      "signature": "(pat)",
      "doc": "Translate a shell PATTERN to a regular expression.",
      "module": "fnmatch"
    },
    "compress": {
      "signature": "(data, format=1, check=-1, preset=None, filters=None)",
      "doc": "Compress a block of data.",
      "module": "lzma"
    },
    "decompress": {
      "signature": "(data, format=0, memlimit=None, filters=None)",
      "doc": "Decompress a block of data.",
      "module": "lzma"
    },
    "chown": {
      "signature": "(path, user=None, group=None)",
      "doc": "Change owner user and group of the given path.",
      "module": "shutil"
    },
    "copy2": {
      "signature": "(src, dst, *, follow_symlinks=True)",
      "doc": "Copy data and metadata. Return the file's destination.",
      "module": "shutil"
    },
    "copyfile": {
      "signature": "(src, dst, *, follow_symlinks=True)",
      "doc": "Copy data from src to dst in the most efficient way possible.",
      "module": "shutil"
    },
    "copyfileobj": {
      "signature": "(fsrc, fdst, length=0)",
      "doc": "copy data from file-like object fsrc to file-like object fdst",
      "module": "shutil"
    },
    "copymode": {
      "signature": "(src, dst, *, follow_symlinks=True)",
      "doc": "Copy mode bits from src to dst.",
      "module": "shutil"
    },
    "copystat": {
      "signature": "(src, dst, *, follow_symlinks=True)",
      "doc": "Copy file metadata",
      "module": "shutil"
    },
    "copytree": {
      "signature": "(src, dst, symlinks=False, ignore=None, copy_function=<function copy2 at 0x0000014FB51688B0>, ignore_dangling_symlinks=False, dirs_exist_ok=False)",
      "doc": "Recursively copy a directory tree and return the destination directory.",
      "module": "shutil"
    },
    "disk_usage": {
      "signature": "(path)",
      "doc": "Return disk usage statistics about the given path.",
      "module": "shutil"
    },
    "get_archive_formats": {
      "signature": "()",
      "doc": "Returns a list of supported formats for archiving and unarchiving.",
      "module": "shutil"
    },
    "get_terminal_size": {
      "signature": "(fallback=(80, 24))",
      "doc": "Get the size of the terminal window.",
      "module": "shutil"
    },
    "get_unpack_formats": {
      "signature": "()",
      "doc": "Returns a list of supported formats for unpacking.",
      "module": "shutil"
    },
    "ignore_patterns": {
      "signature": "(*patterns)",
      "doc": "Function that can be used as copytree() ignore parameter.",
      "module": "shutil"
    },
    "make_archive": {
      "signature": "(base_name, format, root_dir=None, base_dir=None, verbose=0, dry_run=0, owner=None, group=None, logger=None)",
      "doc": "Create an archive file (eg. zip or tar).",
      "module": "shutil"
    },
    "move": {
      "signature": "(src, dst, copy_function=<function copy2 at 0x0000014FB51688B0>)",
      "doc": "Recursively move a file or directory to another location. This is",
      "module": "shutil"
    },
    "register_archive_format": {
      "signature": "(name, function, extra_args=None, description='')",
      "doc": "Registers an archive format.",
      "module": "shutil"
    },
    "register_unpack_format": {
      "signature": "(name, extensions, function, extra_args=None, description='')",
      "doc": "Registers an unpack format.",
      "module": "shutil"
    },
    "rmtree": {
      "signature": "(path, ignore_errors=False, onerror=None)",
      "doc": "Recursively delete a directory tree.",
      "module": "shutil"
    },
    "unpack_archive": {
      "signature": "(filename, extract_dir=None, format=None)",
      "doc": "Unpack an archive.",
      "module": "shutil"
    },
    "unregister_archive_format": {
      "signature": "(name)",
      "doc": "",
      "module": "shutil"
    },
    "unregister_unpack_format": {
      "signature": "(name)",
      "doc": "Removes the pack format from the registry.",
      "module": "shutil"
    },
    "which": {
      "signature": "(cmd, mode=1, path=None)",
      "doc": "Given a command, mode, and a PATH string, return the path which",
      "module": "shutil"
    },
    "NamedTemporaryFile": {
      "signature": "(mode='w+b', buffering=-1, encoding=None, newline=None, suffix=None, prefix=None, dir=None, delete=True, *, errors=None)",
      "doc": "Create and return a temporary file.",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "TemporaryFile": {
      "signature": "(mode='w+b', buffering=-1, encoding=None, newline=None, suffix=None, prefix=None, dir=None, delete=True, *, errors=None)",
      "doc": "Create and return a temporary file.",
      "module": "tempfile"
    },
    "gettempdir": {
      "signature": "()",
      "doc": "Returns tempfile.tempdir as str.",
      "module": "tempfile"
    },
    "gettempdirb": {
      "signature": "()",
      "doc": "Returns tempfile.tempdir as bytes.",
      "module": "tempfile"
    },
    "gettempprefix": {
      "signature": "()",
      "doc": "The default prefix for temporary directories as string.",
      "module": "tempfile"
    },
    "gettempprefixb": {
      "signature": "()",
      "doc": "The default prefix for temporary directories as bytes.",
      "module": "tempfile"
    },
    "mkdtemp": {
      "signature": "(suffix=None, prefix=None, dir=None)",
      "doc": "User-callable function to create and return a unique temporary",
      "module": "tempfile"
    },
    "mkstemp": {
      "signature": "(suffix=None, prefix=None, dir=None, text=False)",
      "doc": "User-callable function to create and return a unique temporary",
      "module": "tempfile"
    },
    "mktemp": {
      "signature": "(suffix='', prefix='tmp', dir=None)",
      "doc": "User-callable function to return a unique temporary file name.  The",
      "module": "tempfile"
    },
    "closelog": {
      "signature": "()",
      "doc": "",
      "module": "cgi"
    },
    "dolog": {
      "signature": "(fmt, *args)",
      "doc": "",
      "module": "cgi"
    },
    "initlog": {
      "signature": "(*allargs)",
      "doc": "",
      "module": "cgi"
    },
    "log": {
      "signature": "(*allargs)",
      "doc": "",
      "module": "cgi"
    },
    "nolog": {
      "signature": "(*allargs)",
      "doc": "",
      "module": "cgi"
    },
    "parse_header": {
      "signature": "(line)",
      "doc": "",
      "module": "cgi"
    },
    "parse_multipart": {
      "signature": "(fp, pdict, encoding='utf-8', errors='replace', separator='&')",
      "doc": "",
      "module": "cgi"
    },
    "print_arguments": {
      "signature": "()",
      "doc": "",
      "module": "cgi"
    },
    "print_directory": {
      "signature": "()",
      "doc": "",
      "module": "cgi"
    },
    "print_environ": {
      "signature": "(environ=environ({'ACTIONS_RUNNER_ACTION_ARCHIVE_CACHE': 'C:\\\\actionarchivecache\\\\', 'AGENT_TOOLSDIRECTORY': 'C:\\\\hostedtoolcache\\\\windows', 'ALLUSERSPROFILE': 'C:\\\\ProgramData', 'ANDROID_HOME': 'C:\\\\Android\\\\android-sdk', 'ANDROID_NDK': 'C:\\\\Android\\\\android-sdk\\\\ndk\\\\27.2.12479018', 'ANDROID_NDK_HOME': 'C:\\\\Android\\\\android-sdk\\\\ndk\\\\27.2.12479018', 'ANDROID_NDK_LATEST_HOME': 'C:\\\\Android\\\\android-sdk\\\\ndk\\\\27.2.12479018', 'ANDROID_NDK_ROOT': 'C:\\\\Android\\\\android-sdk\\\\ndk\\\\27.2.12479018', 'ANDROID_SDK_ROOT': 'C:\\\\Android\\\\android-sdk', 'ANT_HOME': 'C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\ant\\\\tools\\\\apache-ant-1.10.14', 'APPDATA': 'C:\\\\Users\\\\runneradmin\\\\AppData\\\\Roaming', 'AZURE_CONFIG_DIR': 'C:\\\\azureCli', 'AZURE_DEVOPS_CACHE_DIR': 'C:\\\\azureDevOpsCli\\\\cache', 'AZURE_EXTENSION_DIR': 'C:\\\\Program Files\\\\Common Files\\\\AzureCliExtensionDirectory', 'AZ_DEVOPS_GLOBAL_CONFIG_DIR': 'C:\\\\azureDevOpsCli', 'CABAL_DIR': 'C:\\\\cabal', 'CHOCOLATEYINSTALL': 'C:\\\\ProgramData\\\\chocolatey', 'CHROMEWEBDRIVER': 'C:\\\\SeleniumWebDrivers\\\\ChromeDriver', 'CI': 'true', 'COBERTURA_HOME': 'C:\\\\cobertura-2.1.1', 'COMMONPROGRAMFILES': 'C:\\\\Program Files\\\\Common Files', 'COMMONPROGRAMFILES(X86)': 'C:\\\\Program Files (x86)\\\\Common Files', 'COMMONPROGRAMW6432': 'C:\\\\Program Files\\\\Common Files', 'COMPUTERNAME': 'fv-az688-556', 'COMSPEC': 'C:\\\\Windows\\\\system32\\\\cmd.exe', 'CONDA': 'C:\\\\Miniconda', 'DEPLOYMENT_BASEPATH': 'C:\\\\actions', 'DOTNET_MULTILEVEL_LOOKUP': '0', 'DOTNET_NOLOGO': '1', 'DOTNET_SKIP_FIRST_TIME_EXPERIENCE': '1', 'DRIVERDATA': 'C:\\\\Windows\\\\System32\\\\Drivers\\\\DriverData', 'EDGEWEBDRIVER': 'C:\\\\SeleniumWebDrivers\\\\EdgeDriver', 'GCM_INTERACTIVE': 'Never', 'GECKOWEBDRIVER': 'C:\\\\SeleniumWebDrivers\\\\GeckoDriver', 'GHCUP_INSTALL_BASE_PREFIX': 'C:\\\\', 'GHCUP_MSYS2': 'C:\\\\msys64', 'GITHUB_ACTION': '__run_2', 'GITHUB_ACTIONS': 'true', 'GITHUB_ACTION_REF': '', 'GITHUB_ACTION_REPOSITORY': '', 'GITHUB_ACTOR': 'Tb1281', 'GITHUB_ACTOR_ID': '96616508', 'GITHUB_API_URL': 'https://api.github.com', 'GITHUB_BASE_REF': '', 'GITHUB_ENV': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\set_env_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_EVENT_NAME': 'workflow_dispatch', 'GITHUB_EVENT_PATH': 'D:\\\\a\\\\_temp\\\\_github_workflow\\\\event.json', 'GITHUB_GRAPHQL_URL': 'https://api.github.com/graphql', 'GITHUB_HEAD_REF': '', 'GITHUB_JOB': 'download_and_run', 'GITHUB_OUTPUT': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\set_output_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_PATH': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\add_path_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_REF': 'refs/heads/main', 'GITHUB_REF_NAME': 'main', 'GITHUB_REF_PROTECTED': 'false', 'GITHUB_REF_TYPE': 'branch', 'GITHUB_REPOSITORY': 'Tb1281/eud_draft_parser', 'GITHUB_REPOSITORY_ID': '894892658', 'GITHUB_REPOSITORY_OWNER': 'Tb1281', 'GITHUB_REPOSITORY_OWNER_ID': '96616508', 'GITHUB_RETENTION_DAYS': '90', 'GITHUB_RUN_ATTEMPT': '1', 'GITHUB_RUN_ID': '12061405809', 'GITHUB_RUN_NUMBER': '21', 'GITHUB_SERVER_URL': 'https://github.com', 'GITHUB_SHA': 'f063bfe49187dd4de9c341b24a010a601ebc89b5', 'GITHUB_STATE': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\save_state_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_STEP_SUMMARY': 'D:\\\\a\\\\_temp\\\\_runner_file_commands\\\\step_summary_9da08aa6-5ab9-4162-b69c-ef5050b89101', 'GITHUB_TRIGGERING_ACTOR': 'Tb1281', 'GITHUB_WORKFLOW': 'Sync and Run Other Repo Releases', 'GITHUB_WORKFLOW_REF': 'Tb1281/eud_draft_parser/.github/workflows/sync.yaml@refs/heads/main', 'GITHUB_WORKFLOW_SHA': 'f063bfe49187dd4de9c341b24a010a601ebc89b5', 'GITHUB_WORKSPACE': 'D:\\\\a\\\\eud_draft_parser\\\\eud_draft_parser', 'GOROOT_1_20_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.20.14\\\\x64', 'GOROOT_1_21_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.21.13\\\\x64', 'GOROOT_1_22_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.22.9\\\\x64', 'GOROOT_1_23_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.23.3\\\\x64', 'GRADLE_HOME': 'C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\gradle\\\\tools\\\\gradle-8.11.1', 'HOMEDRIVE': 'C:', 'HOMEPATH': '\\\\Users\\\\runneradmin', 'IEWEBDRIVER': 'C:\\\\SeleniumWebDrivers\\\\IEDriver', 'IMAGEOS': 'win22', 'IMAGEVERSION': '20241125.1.0', 'JAVA_HOME': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\8.0.432-6\\\\x64', 'JAVA_HOME_11_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\11.0.25-9\\\\x64', 'JAVA_HOME_17_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\17.0.13-11\\\\x64', 'JAVA_HOME_21_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\21.0.5-11.0\\\\x64', 'JAVA_HOME_8_X64': 'C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\8.0.432-6\\\\x64', 'LOCALAPPDATA': 'C:\\\\Users\\\\runneradmin\\\\AppData\\\\Local', 'LOGONSERVER': '\\\\\\\\fv-az688-556', 'M2': 'C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\maven\\\\apache-maven-3.8.7\\\\bin', 'M2_REPO': 'C:\\\\ProgramData\\\\m2', 'MAVEN_OPTS': '-Xms256m', 'NPM_CONFIG_PREFIX': 'C:\\\\npm\\\\prefix', 'NUMBER_OF_PROCESSORS': '2', 'OS': 'Windows_NT', 'PATH': 'C:\\\\Program Files\\\\PowerShell\\\\7;C:\\\\Program Files\\\\MongoDB\\\\Server\\\\5.0\\\\bin;C:\\\\aliyun-cli;C:\\\\vcpkg;C:\\\\Program Files (x86)\\\\NSIS\\\\;C:\\\\tools\\\\zstd;C:\\\\Program Files\\\\Mercurial\\\\;C:\\\\hostedtoolcache\\\\windows\\\\stack\\\\3.1.1\\\\x64;C:\\\\cabal\\\\bin;C:\\\\\\\\ghcup\\\\bin;C:\\\\mingw64\\\\bin;C:\\\\Program Files\\\\dotnet;C:\\\\Program Files\\\\MySQL\\\\MySQL Server 8.0\\\\bin;C:\\\\Program Files\\\\R\\\\R-4.4.2\\\\bin\\\\x64;C:\\\\SeleniumWebDrivers\\\\GeckoDriver;C:\\\\SeleniumWebDrivers\\\\EdgeDriver\\\\;C:\\\\SeleniumWebDrivers\\\\ChromeDriver;C:\\\\Program Files (x86)\\\\sbt\\\\bin;C:\\\\Program Files (x86)\\\\GitHub CLI;C:\\\\Program Files\\\\Git\\\\bin;C:\\\\Program Files (x86)\\\\pipx_bin;C:\\\\npm\\\\prefix;C:\\\\hostedtoolcache\\\\windows\\\\go\\\\1.21.13\\\\x64\\\\bin;C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\3.9.13\\\\x64\\\\Scripts;C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\3.9.13\\\\x64;C:\\\\hostedtoolcache\\\\windows\\\\Ruby\\\\3.0.7\\\\x64\\\\bin;C:\\\\Program Files\\\\OpenSSL\\\\bin;C:\\\\tools\\\\kotlinc\\\\bin;C:\\\\hostedtoolcache\\\\windows\\\\Java_Temurin-Hotspot_jdk\\\\8.0.432-6\\\\x64\\\\bin;C:\\\\Program Files\\\\ImageMagick-7.1.1-Q16-HDRI;C:\\\\Program Files\\\\Microsoft SDKs\\\\Azure\\\\CLI2\\\\wbin;C:\\\\ProgramData\\\\kind;C:\\\\ProgramData\\\\Chocolatey\\\\bin;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Windows\\\\System32\\\\OpenSSH\\\\;C:\\\\Program Files\\\\dotnet\\\\;C:\\\\Program Files\\\\PowerShell\\\\7\\\\;C:\\\\Program Files\\\\Microsoft\\\\Web Platform Installer\\\\;C:\\\\Program Files\\\\TortoiseSVN\\\\bin;C:\\\\Program Files\\\\Microsoft SQL Server\\\\Client SDK\\\\ODBC\\\\170\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\150\\\\Tools\\\\Binn\\\\;C:\\\\Program Files (x86)\\\\Windows Kits\\\\10\\\\Windows Performance Toolkit\\\\;C:\\\\Program Files (x86)\\\\WiX Toolset v3.14\\\\bin;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\DTS\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\140\\\\DTS\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\150\\\\DTS\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\160\\\\DTS\\\\Binn\\\\;C:\\\\Strawberry\\\\c\\\\bin;C:\\\\Strawberry\\\\perl\\\\site\\\\bin;C:\\\\Strawberry\\\\perl\\\\bin;C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\pulumi\\\\tools\\\\Pulumi\\\\bin;C:\\\\Program Files\\\\CMake\\\\bin;C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\maven\\\\apache-maven-3.8.7\\\\bin;C:\\\\Program Files\\\\Microsoft Service Fabric\\\\bin\\\\Fabric\\\\Fabric.Code;C:\\\\Program Files\\\\Microsoft SDKs\\\\Service Fabric\\\\Tools\\\\ServiceFabricLocalClusterManager;C:\\\\Program Files\\\\nodejs\\\\;C:\\\\Program Files\\\\Git\\\\cmd;C:\\\\Program Files\\\\Git\\\\mingw64\\\\bin;C:\\\\Program Files\\\\Git\\\\usr\\\\bin;C:\\\\Program Files\\\\GitHub CLI\\\\;c:\\\\tools\\\\php;C:\\\\Program Files (x86)\\\\sbt\\\\bin;C:\\\\Program Files\\\\Amazon\\\\AWSCLIV2\\\\;C:\\\\Program Files\\\\Amazon\\\\SessionManagerPlugin\\\\bin\\\\;C:\\\\Program Files\\\\Amazon\\\\AWSSAMCLI\\\\bin\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\LLVM\\\\bin;C:\\\\Users\\\\runneradmin\\\\.dotnet\\\\tools;C:\\\\Users\\\\runneradmin\\\\.cargo\\\\bin;C:\\\\Users\\\\runneradmin\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps', 'PATHEXT': '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.CPL', 'PERFLOG_LOCATION_SETTING': 'RUNNER_PERFLOG', 'PGBIN': 'C:\\\\Program Files\\\\PostgreSQL\\\\14\\\\bin', 'PGDATA': 'C:\\\\Program Files\\\\PostgreSQL\\\\14\\\\data', 'PGPASSWORD': 'root', 'PGROOT': 'C:\\\\Program Files\\\\PostgreSQL\\\\14', 'PGUSER': 'postgres', 'PHPROOT': 'c:\\\\tools\\\\php', 'PIPX_BIN_DIR': 'C:\\\\Program Files (x86)\\\\pipx_bin', 'PIPX_HOME': 'C:\\\\Program Files (x86)\\\\pipx', 'POWERSHELL_DISTRIBUTION_CHANNEL': 'GitHub-Actions-win22', 'POWERSHELL_UPDATECHECK': 'Off', 'PROCESSOR_ARCHITECTURE': 'AMD64', 'PROCESSOR_IDENTIFIER': 'AMD64 Family 25 Model 1 Stepping 1, AuthenticAMD', 'PROCESSOR_LEVEL': '25', 'PROCESSOR_REVISION': '0101', 'PROGRAMDATA': 'C:\\\\ProgramData', 'PROGRAMFILES': 'C:\\\\Program Files', 'PROGRAMFILES(X86)': 'C:\\\\Program Files (x86)', 'PROGRAMW6432': 'C:\\\\Program Files', 'PROMPT': '$P$G', 'PSMODULEANALYSISCACHEPATH': 'C:\\\\PSModuleAnalysisCachePath\\\\ModuleAnalysisCache', 'PSMODULEPATH': 'C:\\\\Users\\\\runneradmin\\\\Documents\\\\PowerShell\\\\Modules;C:\\\\Program Files\\\\PowerShell\\\\Modules;c:\\\\program files\\\\powershell\\\\7\\\\Modules;C:\\\\\\\\Modules\\\\azurerm_2.1.0;C:\\\\\\\\Modules\\\\azure_2.1.0;C:\\\\Users\\\\packer\\\\Documents\\\\WindowsPowerShell\\\\Modules;C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\Windows\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\Tools\\\\PowerShell\\\\Modules\\\\', 'PUBLIC': 'C:\\\\Users\\\\Public', 'RTOOLS44_HOME': 'C:\\\\rtools44', 'RUNNER_ARCH': 'X64', 'RUNNER_ENVIRONMENT': 'github-hosted', 'RUNNER_NAME': 'GitHub Actions 9', 'RUNNER_OS': 'Windows', 'RUNNER_PERFLOG': 'C:\\\\actions\\\\perflog', 'RUNNER_TEMP': 'D:\\\\a\\\\_temp', 'RUNNER_TOOL_CACHE': 'C:\\\\hostedtoolcache\\\\windows', 'RUNNER_TRACKING_ID': 'github_090bc668-8081-433b-9fac-107b5217c587', 'RUNNER_WORKSPACE': 'D:\\\\a\\\\eud_draft_parser', 'SBT_HOME': 'C:\\\\Program Files (x86)\\\\sbt\\\\', 'SELENIUM_JAR_PATH': 'C:\\\\selenium\\\\selenium-server.jar', 'STATS_D': 'true', 'STATS_D_D': 'true', 'STATS_D_TC': 'true', 'STATS_EXT': 'true', 'STATS_EXTP': 'https://provjobdprod.z13.web.core.windows.net/settings/provjobdsettings-latest/provjobd.data', 'STATS_PIP': 'false', 'STATS_RDCL': 'true', 'STATS_TRP': 'true', 'STATS_UE': 'true', 'STATS_V3PS': 'true', 'STATS_VMD': 'true', 'STATS_VMFE': 'true', 'SYSTEMDRIVE': 'C:', 'SYSTEMROOT': 'C:\\\\Windows', 'TEMP': 'C:\\\\Users\\\\RUNNER~1\\\\AppData\\\\Local\\\\Temp', 'TMP': 'C:\\\\Users\\\\RUNNER~1\\\\AppData\\\\Local\\\\Temp', 'USERDOMAIN': 'fv-az688-556', 'USERDOMAIN_ROAMINGPROFILE': 'fv-az688-556', 'USERNAME': 'runneradmin', 'USERPROFILE': 'C:\\\\Users\\\\runneradmin', 'VCPKG_INSTALLATION_ROOT': 'C:\\\\vcpkg', 'WINDIR': 'C:\\\\Windows', 'WIX': 'C:\\\\Program Files (x86)\\\\WiX Toolset v3.14\\\\'}))",
      "doc": "",
      "module": "cgi"
    },
    "print_environ_usage": {
      "signature": "()",
      "doc": "",
      "module": "cgi"
    },
    "print_form": {
      "signature": "(form)",
      "doc": "",
      "module": "cgi"
    },
    "valid_boundary": {
      "signature": "(s)",
      "doc": "",
      "module": "cgi"
    },
    "f_eprintAll": {
      "signature": "(format_string, *args)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_eprintf": {
      "signature": "(format_string, *args)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_sprintf": {
      "signature": "(dst, format_string, *args, EOS=True, encoding='UTF-8')",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_sprintf_cp": {
      "signature": "(format_string, *args, EOS=True, encoding='UTF-8')",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_parse": {
      "signature": "(dst, radix=10)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_strlen": {
      "signature": "(src, /, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_strlen_epd": {
      "signature": "(epd, subp=0, /, **kwargs)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "GetIsPNameCondition": {
      "signature": "(name, _plvars={})",
      "doc": "",
      "module": "eudplib.eudlib.stringf.pname"
    },
    "GetPlayerLightVariable": {
      "signature": "() -> tuple[int, int]",
      "doc": "",
      "module": "eudplib.eudlib.stringf.pname"
    },
    "IsPName": {
      "signature": "(player, name)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "SetPName": {
      "signature": "(player, *name)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "SetPNamef": {
      "signature": "(player, format_string, *args)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "compare_sequence": {
      "signature": "(src: int, seq: str) -> list[eudplib.core.rawtrigger.condition.Condition]",
      "doc": "",
      "module": "eudplib.eudlib.stringf.pname"
    },
    "CountConditionsAndActions": {
      "signature": "(bTrigger: bytes) -> tuple[int, int]",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.btInliner"
    },
    "GetExecutingPlayers": {
      "signature": "(bTrigger: bytes) -> tuple[bool, bool, bool, bool, bool, bool, bool, bool]",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "GetTriggerSize": {
      "signature": "(bTrigger: bytes) -> int",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "InlineCodifyBinaryTrigger": {
      "signature": "(bTrigger: bytes) -> tuple[eudplib.core.allocator.constexpr.ConstExpr, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger]",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "InlineCodifyMultipleBinaryTriggers": {
      "signature": "(bTriggers: collections.abc.Collection[bytes | int]) -> tuple[eudplib.core.allocator.constexpr.ConstExpr, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger]",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "NoWaitAndPreserved": {
      "signature": "(bTrigger: collections.abc.ByteString) -> bool",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.btInliner"
    },
    "TryToShareTrigger": {
      "signature": "(bTrigger: bytes) -> int | bytes",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "CompileInlineCode": {
      "signature": "(code: str) -> tuple[eudplib.core.allocator.constexpr.ConstExpr, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger]",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "ComputeBaseInlineCodeGlobals": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "GetInlineCodeGlobals": {
      "signature": "() -> dict[str, typing.Any]",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilccompile"
    },
    "ConsecutiveInlineTrigSection": {
      "signature": "(trigSection: bytes) -> tuple[list[tuple[int, tuple[eudplib.core.allocator.constexpr.ConstExpr, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger]]], bytes]",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "CreateInlineCodeDispatcher": {
      "signature": "(inlineCodes: list[tuple[int, tuple[eudplib.core.allocator.constexpr.ConstExpr, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger]]], func: tuple[eudplib.core.allocator.constexpr.ConstExpr, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger], playerCode: int) -> bytearray",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "DispatchInlineCode": {
      "signature": "(inlineCodes: list[tuple[int, tuple[eudplib.core.allocator.constexpr.ConstExpr, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger]]], trigger_bytes: bytes) -> bytearray | None",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "GetInlineCodeList": {
      "signature": "() -> list[tuple[int, tuple[eudplib.core.allocator.constexpr.ConstExpr, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger]]]",
      "doc": "",
      "module": "eudplib.maprw.injector.injFinalizer"
    },
    "GetInlineCodePlayerList": {
      "signature": "(bTrigger: bytes) -> int | None",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "InlinifyNormalTrigger": {
      "signature": "(inlineCodes: list[tuple[int, tuple[eudplib.core.allocator.constexpr.ConstExpr, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger]]], trigger_bytes: bytes) -> bytearray",
      "doc": "",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "PRT_SetInliningRate": {
      "signature": "(rate: float) -> None",
      "doc": "",
      "module": "eudplib.maprw"
    },
    "PreprocessInlineCode": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK) -> None",
      "doc": "",
      "module": "eudplib.maprw.savemap"
    },
    "PreprocessTrigSection": {
      "signature": "(trigSection: bytes) -> tuple[list[tuple[int, tuple[eudplib.core.allocator.constexpr.ConstExpr, eudplib.core.rawtrigger.rawtriggerdef.RawTrigger]]], bytes]",
      "doc": "",
      "module": "eudplib.maprw.inlinecode"
    },
    "CreateInjectFinalizer": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK, root: eudplib.core.allocator.constexpr.Forward | eudplib.core.rawtrigger.rawtriggerdef.RawTrigger, mrgndata: bytes | None = None) -> eudplib.core.allocator.constexpr.Forward",
      "doc": "",
      "module": "eudplib.maprw.injector.applyInjector"
    },
    "InitializePayload": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK, payload: eudplib.core.allocator.pbuffer.Payload, mrgndata: collections.abc.ByteString | None = None) -> None",
      "doc": "",
      "module": "eudplib.maprw.injector.applyInjector"
    },
    "CreatePayloadRelocator": {
      "signature": "(payload: eudplib.core.allocator.pbuffer.Payload) -> eudplib.core.allocator.pbuffer.Payload",
      "doc": "",
      "module": "eudplib.maprw.injector.applyInjector"
    },
    "CopyDeaths": {
      "signature": "(iplayer: eudplib.core.rawtrigger.constenc._Player | int, oplayer: eudplib.core.rawtrigger.constenc._Player | int, copyepd: bool = False, initvalue: int | None = None) -> None",
      "doc": "",
      "module": "eudplib.maprw.injector.vectorReloc"
    },
    "CreateVectorRelocator": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK, payload: eudplib.core.allocator.pbuffer.Payload) -> None",
      "doc": "",
      "module": "eudplib.maprw.injector.applyInjector"
    },
    "PRT_SkipPayloadRelocator": {
      "signature": "(enable: bool) -> None",
      "doc": "",
      "module": "eudplib.maprw"
    },
    "applyInjector": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK, root: eudplib.core.allocator.constexpr.Forward | eudplib.core.rawtrigger.rawtriggerdef.RawTrigger) -> None",
      "doc": "",
      "module": "eudplib.maprw.savemap"
    },
    "EUDDoEvents": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.maprw"
    },
    "EUDOnStart": {
      "signature": "(func: collections.abc.Callable) -> None",
      "doc": "",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "InitMpqLibrary": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "GetAddedFiles": {
      "signature": "() -> set[str]",
      "doc": "",
      "module": "eudplib.maprw.mpqadd"
    },
    "MPQAddFile": {
      "signature": "(fname: str, content: bytes | None, isWave: bool = False) -> None",
      "doc": "",
      "module": "eudplib.maprw"
    },
    "MPQAddWave": {
      "signature": "(fname: str, content: bytes | None) -> None",
      "doc": "",
      "module": "eudplib.maprw"
    },
    "MPQCheckFile": {
      "signature": "(fname: str) -> bytes",
      "doc": "",
      "module": "eudplib.maprw"
    },
    "UpdateFileListByListfile": {
      "signature": "(mpqr: eudplib.core.mapdata.mpqapi.MPQ) -> None",
      "doc": "",
      "module": "eudplib.maprw.loadmap"
    },
    "UpdateMPQ": {
      "signature": "(mpqw: eudplib.core.mapdata.mpqapi.MPQ) -> None",
      "doc": "",
      "module": "eudplib.maprw.savemap"
    },
    "LoadMap": {
      "signature": "(fname: str) -> None",
      "doc": "",
      "module": "eudplib.maprw"
    },
    "ApplyRemasteredChk": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.fixmapdata"
    },
    "FixMTXM0_0Null": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.fixmapdata"
    },
    "FixMapData": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.fixmapdata"
    },
    "FixSettings": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.fixmapdata"
    },
    "FixUnitMap": {
      "signature": "(chkt: eudplib.core.mapdata.chktok.CHK) -> None",
      "doc": "",
      "module": "eudplib.core.mapdata.fixmapdata"
    },
    "SaveMap": {
      "signature": "(fname: str, rootf: collections.abc.Callable, *, sectorSize=None) -> None",
      "doc": "",
      "module": "eudplib.maprw"
    },
    "getTraceMap": {
      "signature": "() -> None",
      "doc": "",
      "module": "eudplib.maprw.savemap"
    },
    "R2L": {
      "signature": "(colors, colors_dict={})",
      "doc": "",
      "module": "eudplib.eudlib.stringf.texteffect"
    },
    "TextFX_FadeIn": {
      "signature": "(*args, color=None, wait=1, reset=True, tag=None, encoding='UTF-8')",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "TextFX_FadeOut": {
      "signature": "(*args, color=None, wait=1, reset=True, tag=None, encoding='UTF-8')",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "TextFX_Remove": {
      "signature": "(tag)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "TextFX_SetTimer": {
      "signature": "(tag, modtype, value)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_cpchar_addstr": {
      "signature": "(src)",
      "doc": "",
      "module": "eudplib.eudlib.stringf.texteffect"
    },
    "f_cpchar_addstr_epd": {
      "signature": "(src)",
      "doc": "",
      "module": "eudplib.eudlib.stringf.texteffect"
    },
    "f_cpchar_print": {
      "signature": "(*args, EOS=True, encoding='UTF-8')",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "GetGlobalStringBuffer": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_printAt": {
      "signature": "(line, format_string, *args)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_println": {
      "signature": "(format_string, *args)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_simpleprint": {
      "signature": "(*args, spaced=True)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_printAll": {
      "signature": "(format_string, *args)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_printAllAt": {
      "signature": "(line, format_string, *args)",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_settbl": {
      "signature": "(tblID, offset, *args, encoding='cp949')",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_settbl2": {
      "signature": "(tblID, offset, *args, encoding='cp949')",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_settblf": {
      "signature": "(tblID, offset, format_string, *args, encoding='cp949')",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "f_settblf2": {
      "signature": "(tblID, offset, format_string, *args, encoding='cp949')",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "Is64BitWireframe": {
      "signature": "() -> eudplib.core.rawtrigger.condition.Condition",
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "find_spec": {
      "signature": "(name, package=None)",
      "doc": "Return the spec for the specified module.",
      "module": "importlib.util"
    },
    "module_for_loader": {
      "signature": "(fxn)",
      "doc": "Decorator to handle selecting the proper module for loaders.",
      "module": "importlib.util"
    },
    "resolve_name": {
      "signature": "(name)",
      "doc": "",
      "module": "pkgutil"
    },
    "set_loader": {
      "signature": "(fxn)",
      "doc": "Set __loader__ on the returned module.",
      "module": "importlib.util"
    },
    "set_package": {
      "signature": "(fxn)",
      "doc": "Set __package__ on the returned module.",
      "module": "importlib.util"
    },
    "source_hash": {
      "signature": "(source_bytes)",
      "doc": "Return the hash of *source_bytes* as used in hash-based pyc files.",
      "module": "importlib.util"
    },
    "urlquote_from_bytes": {
      "signature": "(bs, safe='/')",
      "doc": "Like quote(), but accepts a bytes object rather than a str, and does",
      "module": "pathlib"
    },
    "is_zipfile": {
      "signature": "(filename)",
      "doc": "Quickly see if a file is a ZIP file by checking the magic number.",
      "module": "zipfile"
    },
    "new": {
      "signature": "(name, data=b'', **kwargs)",
      "doc": "new(name, data=b'') - Return a new hashing object using the named algorithm;",
      "module": "hashlib"
    },
    "DER_cert_to_PEM_cert": {
      "signature": "(der_cert_bytes)",
      "doc": "Takes a certificate in binary DER format and returns the",
      "module": "ssl"
    },
    "PEM_cert_to_DER_cert": {
      "signature": "(pem_cert_string)",
      "doc": "Takes a certificate in ASCII PEM format and returns the",
      "module": "ssl"
    },
    "cert_time_to_seconds": {
      "signature": "(cert_time)",
      "doc": "Return the time in seconds since the Epoch, given the timestring",
      "module": "ssl"
    },
    "create_default_context": {
      "signature": "(purpose=<Purpose.SERVER_AUTH: _ASN1Object(nid=129, shortname='serverAuth', longname='TLS Web Server Authentication', oid='1.3.6.1.5.5.7.3.1')>, *, cafile=None, capath=None, cadata=None)",
      "doc": "Create a SSLContext object with default settings.",
      "module": "ssl"
    },
    "get_default_verify_paths": {
      "signature": "()",
      "doc": "Return paths to default cafile and capath.",
      "module": "ssl"
    },
    "get_protocol_name": {
      "signature": "(protocol_code)",
      "doc": "",
      "module": "ssl"
    },
    "get_server_certificate": {
      "signature": "(addr, ssl_version=<_SSLMethod.PROTOCOL_TLS_CLIENT: 16>, ca_certs=None, timeout=<object object at 0x0000014FB25B8650>)",
      "doc": "Retrieve the certificate from the server at the specified address,",
      "module": "ssl"
    },
    "match_hostname": {
      "signature": "(cert, hostname)",
      "doc": "Verify that *cert* (in decoded format as returned by",
      "module": "ssl"
    },
    "wrap_socket": {
      "signature": "(sock, keyfile=None, certfile=None, server_side=False, cert_reqs=<VerifyMode.CERT_NONE: 0>, ssl_version=<_SSLMethod.PROTOCOL_TLS: 2>, ca_certs=None, do_handshake_on_connect=True, suppress_ragged_eofs=True, ciphers=None)",
      "doc": "",
      "module": "ssl"
    },
    "parse_headers": {
      "signature": "(fp, _class=<class 'http.client.HTTPMessage'>)",
      "doc": "Parses only RFC2822 headers from a file pointer.",
      "module": "http.client"
    },
    "pathname2url": {
      "signature": "(p)",
      "doc": "",
      "module": "urllib.request"
    },
    "url2pathname": {
      "signature": "(url)",
      "doc": "",
      "module": "urllib.request"
    },
    "build_opener": {
      "signature": "(*handlers)",
      "doc": "",
      "module": "urllib.request"
    },
    "ftperrors": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "getproxies": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "getproxies_environment": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "getproxies_registry": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "install_opener": {
      "signature": "(opener)",
      "doc": "",
      "module": "urllib.request"
    },
    "localhost": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "noheaders": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "parse_http_list": {
      "signature": "(s)",
      "doc": "",
      "module": "urllib.request"
    },
    "parse_keqv_list": {
      "signature": "(l)",
      "doc": "",
      "module": "urllib.request"
    },
    "proxy_bypass": {
      "signature": "(host)",
      "doc": "",
      "module": "urllib.request"
    },
    "proxy_bypass_environment": {
      "signature": "(host, proxies=None)",
      "doc": "",
      "module": "urllib.request"
    },
    "proxy_bypass_registry": {
      "signature": "(host)",
      "doc": "",
      "module": "urllib.request"
    },
    "request_host": {
      "signature": "(request)",
      "doc": "",
      "module": "urllib.request"
    },
    "thishost": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "urlcleanup": {
      "signature": "()",
      "doc": "",
      "module": "urllib.request"
    },
    "urlopen": {
      "signature": "(url, data=None, timeout=<object object at 0x0000014FB25B8650>, *, cafile=None, capath=None, cadefault=False, context=None)",
      "doc": "",
      "module": "autoupdate"
    },
    "urlretrieve": {
      "signature": "(url, filename=None, reporthook=None, data=None)",
      "doc": "",
      "module": "urllib.request"
    },
    "RGB": {
      "signature": "(red, green, blue)",
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "IsThisForeground": {
      "signature": "()",
      "doc": "",
      "module": "msgbox"
    },
    "MessageBox": {
      "signature": "(title, text, style=0, textio=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)",
      "doc": "",
      "module": "applyeuddraft"
    },
    "checkUpdate": {
      "signature": "()",
      "doc": "",
      "module": "autoupdate"
    },
    "download": {
      "signature": "(url)",
      "doc": "",
      "module": "autoupdate"
    },
    "getLatestUpdateCheckpoint": {
      "signature": "()",
      "doc": "",
      "module": "autoupdate"
    },
    "getLatestVersion": {
      "signature": "()",
      "doc": "",
      "module": "autoupdate"
    },
    "getRelease": {
      "signature": "(version)",
      "doc": "",
      "module": "autoupdate"
    },
    "issueAutoUpdate": {
      "signature": "()",
      "doc": "",
      "module": "autoupdate"
    },
    "versionLt": {
      "signature": "(version1, version2)",
      "doc": "",
      "module": "autoupdate"
    },
    "writeVersionCheckpoint": {
      "signature": "(version)",
      "doc": "",
      "module": "autoupdate"
    },
    "empty": {
      "signature": "()",
      "doc": "",
      "module": "pluginLoader"
    },
    "getGlobalPluginDirectory": {
      "signature": "()",
      "doc": "",
      "module": "euddraft"
    },
    "getPluginPath": {
      "signature": "(pluginName)",
      "doc": "",
      "module": "pluginLoader"
    },
    "getSCBankSettings": {
      "signature": "()",
      "doc": "",
      "module": "pluginLoader"
    },
    "isFreezeIssued": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "isPromptIssued": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "isSCBankIssued": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "loadPluginsFromConfig": {
      "signature": "(ep, config)",
      "doc": "",
      "module": "applyeuddraft"
    },
    "dedent": {
      "signature": "(text)",
      "doc": "Remove any common leading whitespace from every line in `text`.",
      "module": "textwrap"
    },
    "fill": {
      "signature": "(text, width=70, **kwargs)",
      "doc": "Fill a single paragraph of text, returning a new string.",
      "module": "textwrap"
    },
    "indent": {
      "signature": "(text, prefix, predicate=None)",
      "doc": "Adds 'prefix' to the beginning of selected lines in 'text'.",
      "module": "textwrap"
    },
    "shorten": {
      "signature": "(text, width, **kwargs)",
      "doc": "Collapse and truncate the given text to fit in the given width.",
      "module": "textwrap"
    },
    "wrap": {
      "signature": "(text, width=70, **kwargs)",
      "doc": "Wrap a single paragraph of text, returning a list of wrapped lines.",
      "module": "textwrap"
    },
    "clear_line": {
      "signature": "(mode=2)",
      "doc": "",
      "module": "colorama.ansi"
    },
    "clear_screen": {
      "signature": "(mode=2)",
      "doc": "",
      "module": "colorama.ansi"
    },
    "code_to_chars": {
      "signature": "(code)",
      "doc": "",
      "module": "colorama.ansi"
    },
    "set_title": {
      "signature": "(title)",
      "doc": "",
      "module": "colorama.ansi"
    },
    "FillConsoleOutputAttribute": {
      "signature": "(stream_id, attr, length, start)",
      "doc": "",
      "module": "colorama.win32"
    },
    "FillConsoleOutputCharacter": {
      "signature": "(stream_id, char, length, start)",
      "doc": "",
      "module": "colorama.win32"
    },
    "GetConsoleMode": {
      "signature": "(handle)",
      "doc": "",
      "module": "colorama.win32"
    },
    "GetConsoleScreenBufferInfo": {
      "signature": "(stream_id=-11)",
      "doc": "",
      "module": "colorama.win32"
    },
    "SetConsoleCursorPosition": {
      "signature": "(stream_id, position, adjust=True)",
      "doc": "",
      "module": "colorama.win32"
    },
    "SetConsoleMode": {
      "signature": "(handle, mode)",
      "doc": "",
      "module": "colorama.win32"
    },
    "SetConsoleTextAttribute": {
      "signature": "(stream_id, attrs)",
      "doc": "",
      "module": "colorama.win32"
    },
    "SetConsoleTitle": {
      "signature": "(title)",
      "doc": "",
      "module": "colorama.win32"
    },
    "winapi_test": {
      "signature": "()",
      "doc": "",
      "module": "colorama.ansitowin32"
    },
    "enable_vt_processing": {
      "signature": "(fd)",
      "doc": "",
      "module": "colorama.ansitowin32"
    },
    "colorama_text": {
      "signature": "(*args, **kwargs)",
      "doc": "",
      "module": "colorama"
    },
    "deinit": {
      "signature": "()",
      "doc": "",
      "module": "colorama"
    },
    "init": {
      "signature": "(autoreset=False, convert=None, strip=None, wrap=True)",
      "doc": "",
      "module": "readconfig"
    },
    "just_fix_windows_console": {
      "signature": "()",
      "doc": "",
      "module": "colorama"
    },
    "reinit": {
      "signature": "()",
      "doc": "",
      "module": "colorama"
    },
    "reset_all": {
      "signature": "()",
      "doc": "",
      "module": "colorama.initialise"
    },
    "wrap_stream": {
      "signature": "(stream, convert, strip, autoreset, wrap)",
      "doc": "",
      "module": "colorama.initialise"
    },
    "readconfig": {
      "signature": "(fname) -> Dict[str, Dict[str, str]]",
      "doc": "",
      "module": "applyeuddraft"
    },
    "run_module": {
      "signature": "(mod_name, init_globals=None, run_name=None, alter_sys=False)",
      "doc": "Execute a module's code without importing it.",
      "module": "runpy"
    },
    "run_path": {
      "signature": "(path_name, init_globals=None, run_name=None)",
      "doc": "Execute code located at the specified filesystem location.",
      "module": "runpy"
    },
    "close_all_fds_except": {
      "signature": "(fds)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "close_fds": {
      "signature": "(*fds)",
      "doc": "Close each file descriptor given as an argument",
      "module": "multiprocessing.util"
    },
    "debug": {
      "signature": "(msg, *args)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "get_logger": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "get_temp_dir": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "info": {
      "signature": "(msg, *args)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "is_abstract_socket_namespace": {
      "signature": "(address)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "is_exiting": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "log_to_stderr": {
      "signature": "(level=None)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "register_after_fork": {
      "signature": "(obj, func)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "spawnv_passfds": {
      "signature": "(path, args, passfds)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "sub_debug": {
      "signature": "(msg, *args)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "sub_warning": {
      "signature": "(msg, *args)",
      "doc": "",
      "module": "multiprocessing.util"
    },
    "freeze_support": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "get_command_line": {
      "signature": "(**kwds)",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "get_executable": {
      "signature": "()",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "get_preparation_data": {
      "signature": "(name)",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "import_main_path": {
      "signature": "(main_path)",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "is_forking": {
      "signature": "(argv)",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "prepare": {
      "signature": "(data)",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "set_executable": {
      "signature": "(exe)",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "spawn_main": {
      "signature": "(pipe_handle, parent_pid=None, tracker_fd=None)",
      "doc": "",
      "module": "multiprocessing.spawn"
    },
    "applyEUDDraft": {
      "signature": "(sfname)",
      "doc": "",
      "module": "applyeuddraft"
    },
    "applylib": {
      "signature": "()",
      "doc": "",
      "module": "euddraft"
    },
    "hasModifiedFile": {
      "signature": "(dirname, since)",
      "doc": "",
      "module": "euddraft"
    },
    "isFileModified": {
      "signature": "(path, since)",
      "doc": "",
      "module": "euddraft"
    },
    "T2": {
      "signature": "(x)",
      "doc": "",
      "module": "freeze.utils"
    },
    "mix2": {
      "signature": "(x, y)",
      "doc": "",
      "module": "freeze.crypt"
    },
    "tryUnT": {
      "signature": "(x)",
      "doc": "",
      "module": "freeze.utils"
    },
    "unT2": {
      "signature": "(y)",
      "doc": "",
      "module": "freeze.crypt"
    },
    "unmix2": {
      "signature": "(z, y)",
      "doc": "",
      "module": "freeze.crypt"
    },
    "assignerMerge": {
      "signature": "(op1, op2)",
      "doc": "",
      "module": "freeze.utils"
    },
    "obfuscatedValueAssigner": {
      "signature": "(v, vInsert)",
      "doc": "",
      "module": "freeze.utils"
    },
    "writeAssigner": {
      "signature": "(operations)",
      "doc": "",
      "module": "freeze.utils"
    },
    "ObfuscatedJump": {
      "signature": "()",
      "doc": "",
      "module": "freeze"
    },
    "issuePatcher": {
      "signature": "(parent, attrname, ratio)",
      "doc": "",
      "module": "freeze.obfpatch"
    },
    "obfpatch": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "obfunpatch": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "decryptOffsets": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "encryptOffsets": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "unFreeze": {
      "signature": "()",
      "doc": "",
      "module": "applyeuddraft"
    },
    "createPayloadMain": {
      "signature": "(pluginList, pluginFuncDict)",
      "doc": "",
      "module": "applyeuddraft"
    },
    "isEpExc": {
      "signature": "(s)",
      "doc": "",
      "module": "applyeuddraft"
    },
    "GetGlobalPool": {
      "signature": "()",
      "doc": "",
      "module": "eudplib.eudlib.objpool"
    },
    "SetGlobalPoolFieldN": {
      "signature": "(fieldn: int)",
      "doc": "",
      "module": "eudplib.eudlib.objpool"
    },
    "py_make_scanner": {
      "signature": "(context)",
      "doc": "",
      "module": "json.scanner"
    },
    "JSONArray": {
      "signature": "(s_and_end, scan_once, _w=<built-in method match of re.Pattern object at 0x0000014FB54F41E0>, _ws=' \\t\\n\\r')",
      "doc": "",
      "module": "json.decoder"
    },
    "JSONObject": {
      "signature": "(s_and_end, strict, scan_once, object_hook, object_pairs_hook, memo=None, _w=<built-in method match of re.Pattern object at 0x0000014FB54F41E0>, _ws=' \\t\\n\\r')",
      "doc": "",
      "module": "json.decoder"
    },
    "py_scanstring": {
      "signature": "(s, end, strict=True, _b={'\"': '\"', '\\\\': '\\\\', '/': '/', 'b': '\\x08', 'f': '\\x0c', 'n': '\\n', 'r': '\\r', 't': '\\t'}, _m=<built-in method match of re.Pattern object at 0x0000014FB4E8FB50>)",
      "doc": "",
      "module": "json.decoder"
    },
    "py_encode_basestring": {
      "signature": "(s)",
      "doc": "",
      "module": "json.encoder"
    },
    "py_encode_basestring_ascii": {
      "signature": "(s)",
      "doc": "",
      "module": "json.encoder"
    },
    "dumps": {
      "signature": "(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)",
      "doc": "",
      "module": "json"
    },
    "loads": {
      "signature": "(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)",
      "doc": "",
      "module": "json"
    },
    "extend_path": {
      "signature": "(path, name)",
      "doc": "Extend a package's path.",
      "module": "pkgutil"
    },
    "get_data": {
      "signature": "(package, resource)",
      "doc": "Get a resource from a package.",
      "module": "pkgutil"
    },
    "get_importer": {
      "signature": "(path_item)",
      "doc": "Retrieve a finder for the given path item",
      "module": "pkgutil"
    },
    "get_loader": {
      "signature": "(module_or_name)",
      "doc": "Get a \"loader\" object for module_or_name",
      "module": "pkgutil"
    },
    "iter_importer_modules": {
      "signature": "(importer, prefix='')",
      "doc": "",
      "module": "pkgutil"
    },
    "iter_importers": {
      "signature": "(fullname='')",
      "doc": "Yield finders for the given module name",
      "module": "pkgutil"
    },
    "iter_modules": {
      "signature": "(path=None, prefix='')",
      "doc": "Yields ModuleInfo for all submodules on path,",
      "module": "pkgutil"
    },
    "iter_zipimport_modules": {
      "signature": "(importer, prefix='')",
      "doc": "",
      "module": "pkgutil"
    },
    "read_code": {
      "signature": "(stream)",
      "doc": "",
      "module": "pkgutil"
    },
    "simplegeneric": {
      "signature": "(func)",
      "doc": "Single-dispatch generic function decorator.",
      "module": "pkgutil"
    },
    "walk_packages": {
      "signature": "(path=None, prefix='', onerror=None)",
      "doc": "Yields ModuleInfo for all modules recursively",
      "module": "pkgutil"
    }
  },
  "classes": {
    "ArithmeticError": {
      "methods": {},
      "doc": "Base class for arithmetic errors.",
      "module": "builtins"
    },
    "AssertionError": {
      "methods": {},
      "doc": "Assertion failed.",
      "module": "builtins"
    },
    "AttributeError": {
      "methods": {},
      "doc": "Attribute not found.",
      "module": "builtins"
    },
    "BaseException": {
      "methods": {},
      "doc": "Common base class for all exceptions",
      "module": "builtins"
    },
    "BlockingIOError": {
      "methods": {},
      "doc": "I/O operation would block.",
      "module": "io"
    },
    "BrokenPipeError": {
      "methods": {},
      "doc": "Broken pipe.",
      "module": "builtins"
    },
    "BufferError": {
      "methods": {},
      "doc": "Buffer error.",
      "module": "builtins"
    },
    "BytesWarning": {
      "methods": {},
      "doc": "Base class for warnings about bytes and buffer related problems, mostly",
      "module": "builtins"
    },
    "ChildProcessError": {
      "methods": {},
      "doc": "Child process error.",
      "module": "builtins"
    },
    "ConnectionAbortedError": {
      "methods": {},
      "doc": "Connection aborted.",
      "module": "builtins"
    },
    "ConnectionError": {
      "methods": {},
      "doc": "Connection error.",
      "module": "builtins"
    },
    "ConnectionRefusedError": {
      "methods": {},
      "doc": "Connection refused.",
      "module": "builtins"
    },
    "ConnectionResetError": {
      "methods": {},
      "doc": "Connection reset.",
      "module": "builtins"
    },
    "DeprecationWarning": {
      "methods": {},
      "doc": "Base class for warnings about deprecated features.",
      "module": "builtins"
    },
    "EOFError": {
      "methods": {},
      "doc": "Read beyond end of file.",
      "module": "builtins"
    },
    "EncodingWarning": {
      "methods": {},
      "doc": "Base class for warnings about encodings.",
      "module": "builtins"
    },
    "EnvironmentError": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "builtins"
    },
    "Exception": {
      "methods": {},
      "doc": "Common base class for all non-exit exceptions.",
      "module": "builtins"
    },
    "FileExistsError": {
      "methods": {},
      "doc": "File already exists.",
      "module": "builtins"
    },
    "FileNotFoundError": {
      "methods": {},
      "doc": "File not found.",
      "module": "builtins"
    },
    "FloatingPointError": {
      "methods": {},
      "doc": "Floating point operation failed.",
      "module": "builtins"
    },
    "FutureWarning": {
      "methods": {},
      "doc": "Base class for warnings about constructs that will change semantically",
      "module": "builtins"
    },
    "GeneratorExit": {
      "methods": {},
      "doc": "Request that a generator exit.",
      "module": "builtins"
    },
    "IOError": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "builtins"
    },
    "ImportError": {
      "methods": {},
      "doc": "Import can't find module, or can't find name in module.",
      "module": "builtins"
    },
    "ImportWarning": {
      "methods": {},
      "doc": "Base class for warnings about probable mistakes in module imports",
      "module": "builtins"
    },
    "IndentationError": {
      "methods": {},
      "doc": "Improper indentation.",
      "module": "builtins"
    },
    "IndexError": {
      "methods": {},
      "doc": "Sequence index out of range.",
      "module": "builtins"
    },
    "InterruptedError": {
      "methods": {},
      "doc": "Interrupted by signal.",
      "module": "builtins"
    },
    "IsADirectoryError": {
      "methods": {},
      "doc": "Operation doesn't work on directories.",
      "module": "builtins"
    },
    "KeyError": {
      "methods": {},
      "doc": "Mapping key not found.",
      "module": "builtins"
    },
    "KeyboardInterrupt": {
      "methods": {},
      "doc": "Program interrupted by user.",
      "module": "builtins"
    },
    "LookupError": {
      "methods": {},
      "doc": "Base class for lookup errors.",
      "module": "builtins"
    },
    "MemoryError": {
      "methods": {},
      "doc": "Out of memory.",
      "module": "builtins"
    },
    "ModuleNotFoundError": {
      "methods": {},
      "doc": "Module not found.",
      "module": "builtins"
    },
    "NameError": {
      "methods": {},
      "doc": "Name not found globally.",
      "module": "builtins"
    },
    "NotADirectoryError": {
      "methods": {},
      "doc": "Operation only works on directories.",
      "module": "builtins"
    },
    "NotImplementedError": {
      "methods": {},
      "doc": "Method or function hasn't been implemented yet.",
      "module": "builtins"
    },
    "OSError": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "builtins"
    },
    "OverflowError": {
      "methods": {},
      "doc": "Result too large to be represented.",
      "module": "builtins"
    },
    "PendingDeprecationWarning": {
      "methods": {},
      "doc": "Base class for warnings about features which will be deprecated",
      "module": "builtins"
    },
    "PermissionError": {
      "methods": {},
      "doc": "Not enough permissions.",
      "module": "builtins"
    },
    "ProcessLookupError": {
      "methods": {},
      "doc": "Process not found.",
      "module": "builtins"
    },
    "RecursionError": {
      "methods": {},
      "doc": "Recursion limit exceeded.",
      "module": "builtins"
    },
    "ReferenceError": {
      "methods": {},
      "doc": "Weak ref proxy used after referent went away.",
      "module": "builtins"
    },
    "ResourceWarning": {
      "methods": {},
      "doc": "Base class for warnings about resource usage.",
      "module": "builtins"
    },
    "RuntimeError": {
      "methods": {},
      "doc": "Unspecified run-time error.",
      "module": "builtins"
    },
    "RuntimeWarning": {
      "methods": {},
      "doc": "Base class for warnings about dubious runtime behavior.",
      "module": "builtins"
    },
    "StopAsyncIteration": {
      "methods": {},
      "doc": "Signal the end from iterator.__anext__().",
      "module": "builtins"
    },
    "StopIteration": {
      "methods": {},
      "doc": "Signal the end from iterator.__next__().",
      "module": "builtins"
    },
    "SyntaxError": {
      "methods": {},
      "doc": "Invalid syntax.",
      "module": "builtins"
    },
    "SyntaxWarning": {
      "methods": {},
      "doc": "Base class for warnings about dubious syntax.",
      "module": "builtins"
    },
    "SystemError": {
      "methods": {},
      "doc": "Internal error in the Python interpreter.",
      "module": "builtins"
    },
    "SystemExit": {
      "methods": {},
      "doc": "Request to exit from the interpreter.",
      "module": "builtins"
    },
    "TabError": {
      "methods": {},
      "doc": "Improper mixture of spaces and tabs.",
      "module": "builtins"
    },
    "TimeoutError": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing"
    },
    "TypeError": {
      "methods": {},
      "doc": "Inappropriate argument type.",
      "module": "builtins"
    },
    "UnboundLocalError": {
      "methods": {},
      "doc": "Local name referenced but not bound to a value.",
      "module": "builtins"
    },
    "UnicodeDecodeError": {
      "methods": {},
      "doc": "Unicode decoding error.",
      "module": "builtins"
    },
    "UnicodeEncodeError": {
      "methods": {},
      "doc": "Unicode encoding error.",
      "module": "builtins"
    },
    "UnicodeError": {
      "methods": {},
      "doc": "Unicode related error.",
      "module": "builtins"
    },
    "UnicodeTranslateError": {
      "methods": {},
      "doc": "Unicode translation error.",
      "module": "builtins"
    },
    "UnicodeWarning": {
      "methods": {},
      "doc": "Base class for warnings about Unicode related problems, mostly",
      "module": "builtins"
    },
    "UserWarning": {
      "methods": {},
      "doc": "Base class for warnings generated by user code.",
      "module": "builtins"
    },
    "ValueError": {
      "methods": {},
      "doc": "Inappropriate argument value (of correct type).",
      "module": "builtins"
    },
    "Warning": {
      "methods": {},
      "doc": "Base class for warning categories.",
      "module": "builtins"
    },
    "WindowsError": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "builtins"
    },
    "ZeroDivisionError": {
      "methods": {},
      "doc": "Second argument to a division or modulo operation was zero.",
      "module": "builtins"
    },
    "bool": {
      "methods": {},
      "doc": "bool(x) -> bool",
      "module": "builtins"
    },
    "bytearray": {
      "methods": {},
      "doc": "bytearray(iterable_of_ints) -> bytearray",
      "module": "builtins"
    },
    "bytes": {
      "methods": {},
      "doc": "bytes(iterable_of_ints) -> bytes",
      "module": "builtins"
    },
    "classmethod": {
      "methods": {},
      "doc": "classmethod(function) -> method",
      "module": "builtins"
    },
    "complex": {
      "methods": {},
      "doc": "Create a complex number from a real part and an optional imaginary part.",
      "module": "builtins"
    },
    "dict": {
      "methods": {},
      "doc": "dict() -> new empty dictionary",
      "module": "builtins"
    },
    "enumerate": {
      "methods": {},
      "doc": "Return an enumerate object.",
      "module": "builtins"
    },
    "filter": {
      "methods": {},
      "doc": "filter(function or None, iterable) --> filter object",
      "module": "builtins"
    },
    "float": {
      "methods": {},
      "doc": "Convert a string or number to a floating point number, if possible.",
      "module": "builtins"
    },
    "frozenset": {
      "methods": {},
      "doc": "frozenset() -> empty frozenset object",
      "module": "builtins"
    },
    "int": {
      "methods": {},
      "doc": "int([x]) -> integer",
      "module": "builtins"
    },
    "list": {
      "methods": {},
      "doc": "Built-in mutable sequence.",
      "module": "builtins"
    },
    "map": {
      "methods": {},
      "doc": "map(func, *iterables) --> map object",
      "module": "builtins"
    },
    "memoryview": {
      "methods": {},
      "doc": "Create a new memoryview object which references the given object.",
      "module": "builtins"
    },
    "object": {
      "methods": {},
      "doc": "The base class of the class hierarchy.",
      "module": "builtins"
    },
    "property": {
      "methods": {},
      "doc": "Property attribute.",
      "module": "builtins"
    },
    "range": {
      "methods": {},
      "doc": "range(stop) -> range object",
      "module": "builtins"
    },
    "reversed": {
      "methods": {},
      "doc": "Return a reverse iterator over the values of the given sequence.",
      "module": "builtins"
    },
    "set": {
      "methods": {},
      "doc": "set() -> new empty set object",
      "module": "builtins"
    },
    "slice": {
      "methods": {},
      "doc": "Deprecated AST node class.",
      "module": "ast"
    },
    "staticmethod": {
      "methods": {},
      "doc": "staticmethod(function) -> method",
      "module": "builtins"
    },
    "str": {
      "methods": {},
      "doc": "str(object='') -> str",
      "module": "builtins"
    },
    "super": {
      "methods": {},
      "doc": "super() -> same as super(__class__, <first argument>)",
      "module": "builtins"
    },
    "tuple": {
      "methods": {},
      "doc": "Built-in immutable sequence.",
      "module": "builtins"
    },
    "type": {
      "methods": {},
      "doc": "type(object) -> the object's type",
      "module": "builtins"
    },
    "zip": {
      "methods": {},
      "doc": "zip(*iterables, strict=False) --> Yield tuples until an input is exhausted.",
      "module": "builtins"
    },
    "DirEntry": {
      "methods": {},
      "doc": "",
      "module": "os"
    },
    "error": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "stat_result": {
      "methods": {},
      "doc": "stat_result: Result from stat, fstat, or lstat.",
      "module": "os"
    },
    "statvfs_result": {
      "methods": {},
      "doc": "statvfs_result: Result from statvfs or fstatvfs.",
      "module": "os"
    },
    "terminal_size": {
      "methods": {},
      "doc": "A tuple of (columns, lines) for holding terminal window size",
      "module": "os"
    },
    "times_result": {
      "methods": {},
      "doc": "times_result: Result from os.times().",
      "module": "os"
    },
    "uname_result": {
      "methods": {},
      "doc": "",
      "module": "platform"
    },
    "HKEYType": {
      "methods": {},
      "doc": "PyHKEY Object - A Python object, representing a win32 registry key.",
      "module": "winreg"
    },
    "struct_time": {
      "methods": {},
      "doc": "The time value as returned by gmtime(), localtime(), and strptime(), and",
      "module": "time"
    },
    "ZipImportError": {
      "methods": {},
      "doc": "",
      "module": "zipimport"
    },
    "zipimporter": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Use default semantics for module creation."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "find_loader": {
          "signature": "(self, fullname, path=None)",
          "doc": "find_loader(fullname, path=None) -> self, str or None."
        },
        "find_module": {
          "signature": "(self, fullname, path=None)",
          "doc": "find_module(fullname, path=None) -> self or None."
        },
        "find_spec": {
          "signature": "(self, fullname, target=None)",
          "doc": "Create a ModuleSpec for the specified module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "get_code(fullname) -> code object."
        },
        "get_data": {
          "signature": "(self, pathname)",
          "doc": "get_data(pathname) -> string with file data."
        },
        "get_filename": {
          "signature": "(self, fullname)",
          "doc": "get_filename(fullname) -> filename string."
        },
        "get_resource_reader": {
          "signature": "(self, fullname)",
          "doc": "Return the ResourceReader for a package in a zip file."
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "get_source(fullname) -> source string."
        },
        "invalidate_caches": {
          "signature": "(self)",
          "doc": "Reload the file data of the archive path."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "is_package(fullname) -> bool."
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": "load_module(fullname) -> module."
        }
      },
      "doc": "zipimporter(archivepath) -> zipimporter object",
      "module": "pkgutil"
    },
    "BufferedIncrementalDecoder": {
      "methods": {
        "decode": {
          "signature": "(self, input, final=False)",
          "doc": ""
        },
        "getstate": {
          "signature": "(self)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "setstate": {
          "signature": "(self, state)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "codecs"
    },
    "BufferedIncrementalEncoder": {
      "methods": {
        "encode": {
          "signature": "(self, input, final=False)",
          "doc": ""
        },
        "getstate": {
          "signature": "(self)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "setstate": {
          "signature": "(self, state)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "codecs"
    },
    "Codec": {
      "methods": {},
      "doc": "",
      "module": "encodings.cp949"
    },
    "CodecInfo": {
      "methods": {},
      "doc": "Codec details when looking up the codec registry",
      "module": "codecs"
    },
    "IncrementalDecoder": {
      "methods": {},
      "doc": "",
      "module": "encodings.cp949"
    },
    "IncrementalEncoder": {
      "methods": {},
      "doc": "",
      "module": "encodings.cp949"
    },
    "StreamReader": {
      "methods": {
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": " Set the input stream's current position."
        }
      },
      "doc": "",
      "module": "encodings.cp949"
    },
    "StreamReaderWriter": {
      "methods": {
        "read": {
          "signature": "(self, size=-1)",
          "doc": ""
        },
        "readline": {
          "signature": "(self, size=None)",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, sizehint=None)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": ""
        },
        "write": {
          "signature": "(self, data)",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, list)",
          "doc": ""
        }
      },
      "doc": " StreamReaderWriter instances allow wrapping streams which",
      "module": "codecs"
    },
    "StreamRecoder": {
      "methods": {
        "read": {
          "signature": "(self, size=-1)",
          "doc": ""
        },
        "readline": {
          "signature": "(self, size=None)",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, sizehint=None)",
          "doc": ""
        },
        "reset": {
          "signature": "(self)",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": ""
        },
        "write": {
          "signature": "(self, data)",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, list)",
          "doc": ""
        }
      },
      "doc": " StreamRecoder instances translate data from one encoding to another.",
      "module": "codecs"
    },
    "StreamWriter": {
      "methods": {
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "encodings.cp949"
    },
    "CodecRegistryError": {
      "methods": {},
      "doc": "",
      "module": "encodings"
    },
    "ABC": {
      "methods": {},
      "doc": "Helper class that provides a standard way to create an ABC using",
      "module": "abc"
    },
    "ABCMeta": {
      "methods": {
        "register": {
          "signature": "(cls, subclass)",
          "doc": "Register a virtual subclass of an ABC."
        }
      },
      "doc": "Metaclass for defining Abstract Base Classes (ABCs).",
      "module": "eudplib.offsetmap.epdoffsetmap"
    },
    "abstractclassmethod": {
      "methods": {},
      "doc": "A decorator indicating abstract classmethods.",
      "module": "abc"
    },
    "abstractproperty": {
      "methods": {},
      "doc": "A decorator indicating abstract properties.",
      "module": "abc"
    },
    "abstractstaticmethod": {
      "methods": {},
      "doc": "A decorator indicating abstract staticmethods.",
      "module": "abc"
    },
    "BufferedIOBase": {
      "methods": {},
      "doc": "Base class for buffered IO objects.",
      "module": "io"
    },
    "BufferedRWPair": {
      "methods": {},
      "doc": "A buffered reader and writer object together.",
      "module": "io"
    },
    "BufferedRandom": {
      "methods": {},
      "doc": "A buffered interface to random access streams.",
      "module": "io"
    },
    "BufferedReader": {
      "methods": {},
      "doc": "Create a new buffered reader using the given readable raw IO object.",
      "module": "io"
    },
    "BufferedWriter": {
      "methods": {},
      "doc": "A buffer for a writeable sequential RawIO object.",
      "module": "io"
    },
    "BytesIO": {
      "methods": {},
      "doc": "Buffered I/O implementation using an in-memory bytes buffer.",
      "module": "cgi"
    },
    "FileIO": {
      "methods": {},
      "doc": "Open a file.",
      "module": "io"
    },
    "IOBase": {
      "methods": {},
      "doc": "The abstract base class for all I/O classes.",
      "module": "io"
    },
    "IncrementalNewlineDecoder": {
      "methods": {},
      "doc": "Codec used when reading a file in universal newlines mode.",
      "module": "io"
    },
    "RawIOBase": {
      "methods": {},
      "doc": "Base class for raw binary I/O.",
      "module": "io"
    },
    "StringIO": {
      "methods": {},
      "doc": "Text I/O implementation using an in-memory buffer.",
      "module": "cgi"
    },
    "TextIOBase": {
      "methods": {},
      "doc": "Base class for text I/O.",
      "module": "io"
    },
    "TextIOWrapper": {
      "methods": {},
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "module": "cgi"
    },
    "UnsupportedOperation": {
      "methods": {},
      "doc": "",
      "module": "io"
    },
    "GenericAlias": {
      "methods": {},
      "doc": "Represent a PEP 585 generic type",
      "module": "dataclasses"
    },
    "Mapping": {
      "methods": {
        "get": {
          "signature": "(self, key, default=None)",
          "doc": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None."
        },
        "items": {
          "signature": "(self)",
          "doc": "D.items() -> a set-like object providing a view on D's items"
        },
        "keys": {
          "signature": "(self)",
          "doc": "D.keys() -> a set-like object providing a view on D's keys"
        },
        "values": {
          "signature": "(self)",
          "doc": "D.values() -> an object providing a view on D's values"
        }
      },
      "doc": "A Mapping is a generic container for associating key/value",
      "module": "cgi"
    },
    "MutableMapping": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": "D.clear() -> None.  Remove all items from D."
        },
        "get": {
          "signature": "(self, key, default=None)",
          "doc": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None."
        },
        "items": {
          "signature": "(self)",
          "doc": "D.items() -> a set-like object providing a view on D's items"
        },
        "keys": {
          "signature": "(self)",
          "doc": "D.keys() -> a set-like object providing a view on D's keys"
        },
        "pop": {
          "signature": "(self, key, default=<object object at 0x0000014FB25B82A0>)",
          "doc": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value."
        },
        "popitem": {
          "signature": "(self)",
          "doc": "D.popitem() -> (k, v), remove and return some (key, value) pair"
        },
        "setdefault": {
          "signature": "(self, key, default=None)",
          "doc": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D"
        },
        "update": {
          "signature": "(self, other=(), /, **kwds)",
          "doc": " D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F."
        },
        "values": {
          "signature": "(self)",
          "doc": "D.values() -> an object providing a view on D's values"
        }
      },
      "doc": "A MutableMapping is a generic container for associating",
      "module": "collections.abc"
    },
    "PathLike": {
      "methods": {},
      "doc": "Abstract base class for implementing the file system path protocol.",
      "module": "os"
    },
    "AsyncGeneratorType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "BuiltinFunctionType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'builtin_function_or_method' objects>",
      "module": "types"
    },
    "BuiltinMethodType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'builtin_function_or_method' objects>",
      "module": "types"
    },
    "CellType": {
      "methods": {},
      "doc": "Create a new cell object.",
      "module": "types"
    },
    "ClassMethodDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'classmethod_descriptor' objects>",
      "module": "types"
    },
    "CodeType": {
      "methods": {},
      "doc": "Create a code object.  Not for the faint of heart.",
      "module": "types"
    },
    "CoroutineType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "DynamicClassAttribute": {
      "methods": {
        "deleter": {
          "signature": "(self, fdel)",
          "doc": ""
        },
        "getter": {
          "signature": "(self, fget)",
          "doc": ""
        },
        "setter": {
          "signature": "(self, fset)",
          "doc": ""
        }
      },
      "doc": "Route attribute access on a class to __getattr__.",
      "module": "enum"
    },
    "EllipsisType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "FrameType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "FunctionType": {
      "methods": {},
      "doc": "Create a function object.",
      "module": "dataclasses"
    },
    "GeneratorType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "GetSetDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'getset_descriptor' objects>",
      "module": "types"
    },
    "LambdaType": {
      "methods": {},
      "doc": "Create a function object.",
      "module": "types"
    },
    "MappingProxyType": {
      "methods": {},
      "doc": "",
      "module": "enum"
    },
    "MemberDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'member_descriptor' objects>",
      "module": "types"
    },
    "MethodDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'method_descriptor' objects>",
      "module": "typing"
    },
    "MethodType": {
      "methods": {},
      "doc": "method(function, instance)",
      "module": "contextlib"
    },
    "MethodWrapperType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'method-wrapper' objects>",
      "module": "typing"
    },
    "ModuleType": {
      "methods": {},
      "doc": "Create a module object.",
      "module": "pkgutil"
    },
    "NoneType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "NotImplementedType": {
      "methods": {},
      "doc": "",
      "module": "types"
    },
    "SimpleNamespace": {
      "methods": {},
      "doc": "A simple attribute-based namespace.",
      "module": "types"
    },
    "TracebackType": {
      "methods": {},
      "doc": "TracebackType(tb_next, tb_frame, tb_lasti, tb_lineno)",
      "module": "eudplib.localize"
    },
    "UnionType": {
      "methods": {},
      "doc": "Represent a PEP 604 union type",
      "module": "types"
    },
    "WrapperDescriptorType": {
      "methods": {},
      "doc": "<attribute '__doc__' of 'wrapper_descriptor' objects>",
      "module": "typing"
    },
    "Enum": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.allocator.payload"
    },
    "EnumMeta": {
      "methods": {},
      "doc": "",
      "module": "enum"
    },
    "Flag": {
      "methods": {},
      "doc": "",
      "module": "eudplib.offsetmap.csprite"
    },
    "IntEnum": {
      "methods": {},
      "doc": "Enum where members are also (and must be) ints",
      "module": "http"
    },
    "IntFlag": {
      "methods": {},
      "doc": "",
      "module": "socket"
    },
    "auto": {
      "methods": {},
      "doc": "",
      "module": "ast"
    },
    "State": {
      "methods": {
        "checkgroup": {
          "signature": "(self, gid)",
          "doc": ""
        },
        "checklookbehindgroup": {
          "signature": "(self, gid, source)",
          "doc": ""
        },
        "closegroup": {
          "signature": "(self, gid, p)",
          "doc": ""
        },
        "opengroup": {
          "signature": "(self, name=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "sre_parse"
    },
    "SubPattern": {
      "methods": {
        "append": {
          "signature": "(self, code)",
          "doc": ""
        },
        "dump": {
          "signature": "(self, level=0)",
          "doc": ""
        },
        "getwidth": {
          "signature": "(self)",
          "doc": ""
        },
        "insert": {
          "signature": "(self, index, code)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "sre_parse"
    },
    "Tokenizer": {
      "methods": {
        "error": {
          "signature": "(self, msg, offset=0)",
          "doc": ""
        },
        "get": {
          "signature": "(self)",
          "doc": ""
        },
        "getuntil": {
          "signature": "(self, terminator, name)",
          "doc": ""
        },
        "getwhile": {
          "signature": "(self, n, charset)",
          "doc": ""
        },
        "match": {
          "signature": "(self, char)",
          "doc": ""
        },
        "seek": {
          "signature": "(self, index)",
          "doc": ""
        },
        "tell": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "sre_parse"
    },
    "Verbose": {
      "methods": {},
      "doc": "",
      "module": "sre_parse"
    },
    "accumulate": {
      "methods": {},
      "doc": "Return series of accumulated sums (or other binary function results).",
      "module": "itertools"
    },
    "chain": {
      "methods": {},
      "doc": "chain(*iterables) --> chain object",
      "module": "eudplib.ctrlstru.swblock"
    },
    "combinations": {
      "methods": {},
      "doc": "Return successive r-length combinations of elements in the iterable.",
      "module": "eudplib.ctrlstru.swblock"
    },
    "combinations_with_replacement": {
      "methods": {},
      "doc": "Return successive r-length combinations of elements in the iterable allowing individual elements to have successive repeats.",
      "module": "itertools"
    },
    "compress": {
      "methods": {},
      "doc": "Return data elements corresponding to true selector elements.",
      "module": "itertools"
    },
    "count": {
      "methods": {},
      "doc": "Return a count object whose .__next__() method returns consecutive values.",
      "module": "itertools"
    },
    "cycle": {
      "methods": {},
      "doc": "Return elements from the iterable until it is exhausted. Then repeat the sequence indefinitely.",
      "module": "itertools"
    },
    "dropwhile": {
      "methods": {},
      "doc": "Drop items from the iterable while predicate(item) is true.",
      "module": "itertools"
    },
    "filterfalse": {
      "methods": {},
      "doc": "Return those items of iterable for which function(item) is false.",
      "module": "itertools"
    },
    "groupby": {
      "methods": {},
      "doc": "make an iterator that returns consecutive keys and groups from the iterable",
      "module": "itertools"
    },
    "islice": {
      "methods": {},
      "doc": "islice(iterable, stop) --> islice object",
      "module": "pickle"
    },
    "pairwise": {
      "methods": {},
      "doc": "Return an iterator of overlapping pairs taken from the input iterator.",
      "module": "itertools"
    },
    "permutations": {
      "methods": {},
      "doc": "Return successive r-length permutations of elements in the iterable.",
      "module": "itertools"
    },
    "product": {
      "methods": {},
      "doc": "product(*iterables, repeat=1) --> product object",
      "module": "itertools"
    },
    "repeat": {
      "methods": {},
      "doc": "repeat(object [,times]) -> create an iterator which returns the object",
      "module": "calendar"
    },
    "starmap": {
      "methods": {},
      "doc": "Return an iterator whose values are returned from the function evaluated with an argument tuple taken from the given sequence.",
      "module": "itertools"
    },
    "takewhile": {
      "methods": {},
      "doc": "Return successive entries from an iterable as long as the predicate evaluates to true for each entry.",
      "module": "itertools"
    },
    "zip_longest": {
      "methods": {},
      "doc": "zip_longest(iter1 [,iter2 [...]], [fillvalue=None]) --> zip_longest object",
      "module": "itertools"
    },
    "attrgetter": {
      "methods": {},
      "doc": "attrgetter(attr, ...) --> attrgetter object",
      "module": "pathlib"
    },
    "itemgetter": {
      "methods": {},
      "doc": "itemgetter(item, ...) --> itemgetter object",
      "module": "operator"
    },
    "methodcaller": {
      "methods": {},
      "doc": "methodcaller(name, ...) --> methodcaller object",
      "module": "operator"
    },
    "Repr": {
      "methods": {
        "repr": {
          "signature": "(self, x)",
          "doc": ""
        },
        "repr1": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_array": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_deque": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_dict": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_frozenset": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_instance": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_int": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_list": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_set": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_str": {
          "signature": "(self, x, level)",
          "doc": ""
        },
        "repr_tuple": {
          "signature": "(self, x, level)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "reprlib"
    },
    "ChainMap": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": "Clear maps[0], leaving maps[1:] intact."
        },
        "copy": {
          "signature": "(self)",
          "doc": "New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]"
        },
        "get": {
          "signature": "(self, key, default=None)",
          "doc": ""
        },
        "items": {
          "signature": "(self)",
          "doc": "D.items() -> a set-like object providing a view on D's items"
        },
        "keys": {
          "signature": "(self)",
          "doc": "D.keys() -> a set-like object providing a view on D's keys"
        },
        "new_child": {
          "signature": "(self, m=None, **kwargs)",
          "doc": "New ChainMap with a new map followed by all previous maps."
        },
        "pop": {
          "signature": "(self, key, *args)",
          "doc": "Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0]."
        },
        "popitem": {
          "signature": "(self)",
          "doc": "Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty."
        },
        "setdefault": {
          "signature": "(self, key, default=None)",
          "doc": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D"
        },
        "update": {
          "signature": "(self, other=(), /, **kwds)",
          "doc": " D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F."
        },
        "values": {
          "signature": "(self)",
          "doc": "D.values() -> an object providing a view on D's values"
        }
      },
      "doc": " A ChainMap groups multiple dicts (or other mappings) together",
      "module": "collections"
    },
    "Counter": {
      "methods": {
        "copy": {
          "signature": "(self)",
          "doc": "Return a shallow copy."
        },
        "elements": {
          "signature": "(self)",
          "doc": "Iterator over elements repeating each as many times as its count."
        },
        "most_common": {
          "signature": "(self, n=None)",
          "doc": "List the n most common elements and their counts from the most"
        },
        "subtract": {
          "signature": "(self, iterable=None, /, **kwds)",
          "doc": "Like dict.update() but subtracts counts instead of replacing them."
        },
        "total": {
          "signature": "(self)",
          "doc": "Sum of the counts"
        },
        "update": {
          "signature": "(self, iterable=None, /, **kwds)",
          "doc": "Like dict.update() but add counts instead of replacing them."
        }
      },
      "doc": "Dict subclass for counting hashable items.  Sometimes called a bag",
      "module": "collections"
    },
    "OrderedDict": {
      "methods": {},
      "doc": "Dictionary that remembers insertion order",
      "module": "readconfig"
    },
    "UserDict": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": "D.clear() -> None.  Remove all items from D."
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "get": {
          "signature": "(self, key, default=None)",
          "doc": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None."
        },
        "items": {
          "signature": "(self)",
          "doc": "D.items() -> a set-like object providing a view on D's items"
        },
        "keys": {
          "signature": "(self)",
          "doc": "D.keys() -> a set-like object providing a view on D's keys"
        },
        "pop": {
          "signature": "(self, key, default=<object object at 0x0000014FB25B82A0>)",
          "doc": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value."
        },
        "popitem": {
          "signature": "(self)",
          "doc": "D.popitem() -> (k, v), remove and return some (key, value) pair"
        },
        "setdefault": {
          "signature": "(self, key, default=None)",
          "doc": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D"
        },
        "update": {
          "signature": "(self, other=(), /, **kwds)",
          "doc": " D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F."
        },
        "values": {
          "signature": "(self)",
          "doc": "D.values() -> an object providing a view on D's values"
        }
      },
      "doc": "",
      "module": "collections"
    },
    "UserList": {
      "methods": {
        "append": {
          "signature": "(self, item)",
          "doc": ""
        },
        "clear": {
          "signature": "(self)",
          "doc": ""
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "count": {
          "signature": "(self, item)",
          "doc": ""
        },
        "extend": {
          "signature": "(self, other)",
          "doc": ""
        },
        "index": {
          "signature": "(self, item, *args)",
          "doc": ""
        },
        "insert": {
          "signature": "(self, i, item)",
          "doc": ""
        },
        "pop": {
          "signature": "(self, i=-1)",
          "doc": ""
        },
        "remove": {
          "signature": "(self, item)",
          "doc": ""
        },
        "reverse": {
          "signature": "(self)",
          "doc": ""
        },
        "sort": {
          "signature": "(self, /, *args, **kwds)",
          "doc": ""
        }
      },
      "doc": "A more or less complete user-defined wrapper around list objects.",
      "module": "collections"
    },
    "UserString": {
      "methods": {
        "capitalize": {
          "signature": "(self)",
          "doc": ""
        },
        "casefold": {
          "signature": "(self)",
          "doc": ""
        },
        "center": {
          "signature": "(self, width, *args)",
          "doc": ""
        },
        "count": {
          "signature": "(self, sub, start=0, end=9223372036854775807)",
          "doc": ""
        },
        "encode": {
          "signature": "(self, encoding='utf-8', errors='strict')",
          "doc": ""
        },
        "endswith": {
          "signature": "(self, suffix, start=0, end=9223372036854775807)",
          "doc": ""
        },
        "expandtabs": {
          "signature": "(self, tabsize=8)",
          "doc": ""
        },
        "find": {
          "signature": "(self, sub, start=0, end=9223372036854775807)",
          "doc": ""
        },
        "format": {
          "signature": "(self, /, *args, **kwds)",
          "doc": ""
        },
        "format_map": {
          "signature": "(self, mapping)",
          "doc": ""
        },
        "index": {
          "signature": "(self, sub, start=0, end=9223372036854775807)",
          "doc": ""
        },
        "isalnum": {
          "signature": "(self)",
          "doc": ""
        },
        "isalpha": {
          "signature": "(self)",
          "doc": ""
        },
        "isascii": {
          "signature": "(self)",
          "doc": ""
        },
        "isdecimal": {
          "signature": "(self)",
          "doc": ""
        },
        "isdigit": {
          "signature": "(self)",
          "doc": ""
        },
        "isidentifier": {
          "signature": "(self)",
          "doc": ""
        },
        "islower": {
          "signature": "(self)",
          "doc": ""
        },
        "isnumeric": {
          "signature": "(self)",
          "doc": ""
        },
        "isprintable": {
          "signature": "(self)",
          "doc": ""
        },
        "isspace": {
          "signature": "(self)",
          "doc": ""
        },
        "istitle": {
          "signature": "(self)",
          "doc": ""
        },
        "isupper": {
          "signature": "(self)",
          "doc": ""
        },
        "join": {
          "signature": "(self, seq)",
          "doc": ""
        },
        "ljust": {
          "signature": "(self, width, *args)",
          "doc": ""
        },
        "lower": {
          "signature": "(self)",
          "doc": ""
        },
        "lstrip": {
          "signature": "(self, chars=None)",
          "doc": ""
        },
        "partition": {
          "signature": "(self, sep)",
          "doc": ""
        },
        "removeprefix": {
          "signature": "(self, prefix, /)",
          "doc": ""
        },
        "removesuffix": {
          "signature": "(self, suffix, /)",
          "doc": ""
        },
        "replace": {
          "signature": "(self, old, new, maxsplit=-1)",
          "doc": ""
        },
        "rfind": {
          "signature": "(self, sub, start=0, end=9223372036854775807)",
          "doc": ""
        },
        "rindex": {
          "signature": "(self, sub, start=0, end=9223372036854775807)",
          "doc": ""
        },
        "rjust": {
          "signature": "(self, width, *args)",
          "doc": ""
        },
        "rpartition": {
          "signature": "(self, sep)",
          "doc": ""
        },
        "rsplit": {
          "signature": "(self, sep=None, maxsplit=-1)",
          "doc": ""
        },
        "rstrip": {
          "signature": "(self, chars=None)",
          "doc": ""
        },
        "split": {
          "signature": "(self, sep=None, maxsplit=-1)",
          "doc": ""
        },
        "splitlines": {
          "signature": "(self, keepends=False)",
          "doc": ""
        },
        "startswith": {
          "signature": "(self, prefix, start=0, end=9223372036854775807)",
          "doc": ""
        },
        "strip": {
          "signature": "(self, chars=None)",
          "doc": ""
        },
        "swapcase": {
          "signature": "(self)",
          "doc": ""
        },
        "title": {
          "signature": "(self)",
          "doc": ""
        },
        "translate": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "upper": {
          "signature": "(self)",
          "doc": ""
        },
        "zfill": {
          "signature": "(self, width)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "collections"
    },
    "defaultdict": {
      "methods": {},
      "doc": "defaultdict(default_factory=None, /, [...]) --> dict with default factory",
      "module": "collections"
    },
    "deque": {
      "methods": {},
      "doc": "deque([iterable[, maxlen]]) --> deque object",
      "module": "email.feedparser"
    },
    "RLock": {
      "methods": {},
      "doc": "",
      "module": "functools"
    },
    "cached_property": {
      "methods": {},
      "doc": "",
      "module": "functools"
    },
    "partial": {
      "methods": {},
      "doc": "partial(func, *args, **keywords) - new function with partial application",
      "module": "email.charset"
    },
    "partialmethod": {
      "methods": {},
      "doc": "Method descriptor with partial application of the given arguments",
      "module": "functools"
    },
    "singledispatchmethod": {
      "methods": {
        "register": {
          "signature": "(self, cls, method=None)",
          "doc": "generic_method.register(cls, func) -> func"
        }
      },
      "doc": "Single-dispatch generic method descriptor.",
      "module": "functools"
    },
    "Match": {
      "methods": {},
      "doc": "Match(expr subject, match_case* cases)",
      "module": "ast"
    },
    "Pattern": {
      "methods": {},
      "doc": "Compiled regular expression object.",
      "module": "re"
    },
    "RegexFlag": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "re"
    },
    "Scanner": {
      "methods": {
        "scan": {
          "signature": "(self, string)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "re"
    },
    "Formatter": {
      "methods": {
        "check_unused_args": {
          "signature": "(self, used_args, args, kwargs)",
          "doc": ""
        },
        "convert_field": {
          "signature": "(self, value, conversion)",
          "doc": ""
        },
        "format": {
          "signature": "(self, format_string, /, *args, **kwargs)",
          "doc": ""
        },
        "format_field": {
          "signature": "(self, value, format_spec)",
          "doc": ""
        },
        "get_field": {
          "signature": "(self, field_name, args, kwargs)",
          "doc": ""
        },
        "get_value": {
          "signature": "(self, key, args, kwargs)",
          "doc": ""
        },
        "parse": {
          "signature": "(self, format_string)",
          "doc": ""
        },
        "vformat": {
          "signature": "(self, format_string, args, kwargs)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "string"
    },
    "Template": {
      "methods": {
        "safe_substitute": {
          "signature": "(self, mapping={}, /, **kws)",
          "doc": ""
        },
        "substitute": {
          "signature": "(self, mapping={}, /, **kws)",
          "doc": ""
        }
      },
      "doc": "A string class for supporting $-substitutions.",
      "module": "string"
    },
    "BuiltinImporter": {
      "methods": {
        "create_module": {
          "signature": "(spec)",
          "doc": "Create a built-in module"
        },
        "exec_module": {
          "signature": "(module)",
          "doc": "Exec a built-in module"
        },
        "module_repr": {
          "signature": "(module)",
          "doc": "Return repr for the module."
        }
      },
      "doc": "Meta path import for built-in modules.",
      "module": "importlib.machinery"
    },
    "FrozenImporter": {
      "methods": {
        "create_module": {
          "signature": "(spec)",
          "doc": "Use default semantics for module creation."
        },
        "exec_module": {
          "signature": "(module)",
          "doc": ""
        },
        "module_repr": {
          "signature": "(m)",
          "doc": "Return repr for the module."
        }
      },
      "doc": "Meta path import for frozen modules.",
      "module": "importlib.machinery"
    },
    "ModuleSpec": {
      "methods": {},
      "doc": "The specification for a module, used for loading.",
      "module": "importlib.machinery"
    },
    "ExtensionFileLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Create an unitialized extension module"
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Initialize an extension module"
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "Return None as an extension module cannot create a code object."
        },
        "get_data": {
          "signature": "(self, path)",
          "doc": "Return the data from path as raw bytes."
        },
        "get_filename": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Return the path to the source file as found by the finder."
        },
        "get_resource_reader": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Return None as extension modules have no source code."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Return True if the extension module is a package."
        },
        "load_module": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Load a module from a file."
        }
      },
      "doc": "Loader for extension modules.",
      "module": "importlib.machinery"
    },
    "FileFinder": {
      "methods": {
        "find_loader": {
          "signature": "(self, fullname)",
          "doc": "Try to find a loader for the specified module, or the namespace"
        },
        "find_module": {
          "signature": "(self, fullname)",
          "doc": "Try to find a loader for the specified module by delegating to"
        },
        "find_spec": {
          "signature": "(self, fullname, target=None)",
          "doc": "Try to find a spec for the specified module."
        },
        "invalidate_caches": {
          "signature": "(self)",
          "doc": "Invalidate the directory mtime."
        }
      },
      "doc": "File-based finder.",
      "module": "eudplib.epscript.epsimp"
    },
    "FileLoader": {
      "methods": {
        "get_data": {
          "signature": "(self, path)",
          "doc": "Return the data from path as raw bytes."
        },
        "get_filename": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Return the path to the source file as found by the finder."
        },
        "get_resource_reader": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": ""
        },
        "load_module": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Load a module from a file."
        }
      },
      "doc": "Base file loader class which implements the loader protocol methods that",
      "module": "importlib._bootstrap_external"
    },
    "PathFinder": {
      "methods": {
        "find_distributions": {
          "signature": "(*args, **kwargs)",
          "doc": ""
        },
        "invalidate_caches": {
          "signature": "()",
          "doc": "Call the invalidate_caches() method on all path entry finders"
        }
      },
      "doc": "Meta path finder for sys.path and package __path__ attributes.",
      "module": "importlib.machinery"
    },
    "SourceFileLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Use default semantics for module creation."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_code."
        },
        "get_data": {
          "signature": "(self, path)",
          "doc": "Return the data from path as raw bytes."
        },
        "get_filename": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Return the path to the source file as found by the finder."
        },
        "get_resource_reader": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_source."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.is_package by checking if"
        },
        "load_module": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Load a module from a file."
        },
        "path_mtime": {
          "signature": "(self, path)",
          "doc": "Optional method that returns the modification time (an int) for the"
        },
        "path_stats": {
          "signature": "(self, path)",
          "doc": "Return the metadata for the path."
        },
        "set_data": {
          "signature": "(self, path, data, *, _mode=438)",
          "doc": "Write bytes data to a file."
        },
        "source_to_code": {
          "signature": "(self, data, path, *, _optimize=-1)",
          "doc": "Return the code object compiled from source."
        }
      },
      "doc": "Concrete implementation of SourceLoader using the file system.",
      "module": "pluginLoader"
    },
    "SourceLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Use default semantics for module creation."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_code."
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_source."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.is_package by checking if"
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": "This method is deprecated."
        },
        "path_mtime": {
          "signature": "(self, path)",
          "doc": "Optional method that returns the modification time (an int) for the"
        },
        "path_stats": {
          "signature": "(self, path)",
          "doc": "Optional method returning a metadata dict for the specified"
        },
        "set_data": {
          "signature": "(self, path, data)",
          "doc": "Optional method which writes data (bytes) to a file path (a str)."
        },
        "source_to_code": {
          "signature": "(self, data, path, *, _optimize=-1)",
          "doc": "Return the code object compiled from source."
        }
      },
      "doc": "",
      "module": "importlib._bootstrap_external"
    },
    "SourcelessFileLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Use default semantics for module creation."
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": ""
        },
        "get_data": {
          "signature": "(self, path)",
          "doc": "Return the data from path as raw bytes."
        },
        "get_filename": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Return the path to the source file as found by the finder."
        },
        "get_resource_reader": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Return None as there is no source code."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.is_package by checking if"
        },
        "load_module": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Load a module from a file."
        }
      },
      "doc": "Loader which handles sourceless file imports.",
      "module": "importlib.machinery"
    },
    "WindowsRegistryFinder": {
      "methods": {},
      "doc": "Meta path finder for modules declared in the Windows registry.",
      "module": "importlib.machinery"
    },
    "WarningMessage": {
      "methods": {},
      "doc": "",
      "module": "warnings"
    },
    "catch_warnings": {
      "methods": {},
      "doc": "A context manager that copies and restores the warnings filter upon",
      "module": "warnings"
    },
    "AsyncGenerator": {
      "methods": {
        "aclose": {
          "signature": "(self)",
          "doc": "Raise GeneratorExit inside coroutine."
        },
        "asend": {
          "signature": "(self, value)",
          "doc": "Send a value into the asynchronous generator."
        },
        "athrow": {
          "signature": "(self, typ, val=None, tb=None)",
          "doc": "Raise an exception in the asynchronous generator."
        }
      },
      "doc": "",
      "module": "collections.abc"
    },
    "AsyncIterable": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "AsyncIterator": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "Awaitable": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "ByteString": {
      "methods": {
        "count": {
          "signature": "(self, value)",
          "doc": "S.count(value) -> integer -- return number of occurrences of value"
        },
        "index": {
          "signature": "(self, value, start=0, stop=None)",
          "doc": "S.index(value, [start, [stop]]) -> integer -- return first index of value."
        }
      },
      "doc": "This unifies bytes and bytearray.",
      "module": "eudplib.maprw.injector.payloadInit"
    },
    "Callable": {
      "methods": {},
      "doc": "",
      "module": "eudplib.maprw.savemap"
    },
    "Collection": {
      "methods": {},
      "doc": "",
      "module": "eudplib.maprw.inlinecode.btInliner"
    },
    "Container": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "Coroutine": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Raise GeneratorExit inside coroutine."
        },
        "send": {
          "signature": "(self, value)",
          "doc": "Send a value into the coroutine."
        },
        "throw": {
          "signature": "(self, typ, val=None, tb=None)",
          "doc": "Raise an exception in the coroutine."
        }
      },
      "doc": "",
      "module": "collections.abc"
    },
    "Generator": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Raise GeneratorExit inside generator."
        },
        "send": {
          "signature": "(self, value)",
          "doc": "Send a value into the generator."
        },
        "throw": {
          "signature": "(self, typ, val=None, tb=None)",
          "doc": "Raise an exception in the generator."
        }
      },
      "doc": "",
      "module": "collections.abc"
    },
    "Hashable": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "ItemsView": {
      "methods": {
        "isdisjoint": {
          "signature": "(self, other)",
          "doc": "Return True if two sets have a null intersection."
        }
      },
      "doc": "",
      "module": "collections.abc"
    },
    "Iterable": {
      "methods": {},
      "doc": "",
      "module": "eudplib.trigger.ptrigger"
    },
    "Iterator": {
      "methods": {},
      "doc": "",
      "module": "eudplib.eudlib.utilf.pexist"
    },
    "KeysView": {
      "methods": {
        "isdisjoint": {
          "signature": "(self, other)",
          "doc": "Return True if two sets have a null intersection."
        }
      },
      "doc": "",
      "module": "collections.abc"
    },
    "MappingView": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "MutableSequence": {
      "methods": {
        "append": {
          "signature": "(self, value)",
          "doc": "S.append(value) -- append value to the end of the sequence"
        },
        "clear": {
          "signature": "(self)",
          "doc": "S.clear() -> None -- remove all items from S"
        },
        "count": {
          "signature": "(self, value)",
          "doc": "S.count(value) -> integer -- return number of occurrences of value"
        },
        "extend": {
          "signature": "(self, values)",
          "doc": "S.extend(iterable) -- extend sequence by appending elements from the iterable"
        },
        "index": {
          "signature": "(self, value, start=0, stop=None)",
          "doc": "S.index(value, [start, [stop]]) -> integer -- return first index of value."
        },
        "insert": {
          "signature": "(self, index, value)",
          "doc": "S.insert(index, value) -- insert value before index"
        },
        "pop": {
          "signature": "(self, index=-1)",
          "doc": "S.pop([index]) -> item -- remove and return item at index (default last)."
        },
        "remove": {
          "signature": "(self, value)",
          "doc": "S.remove(value) -- remove first occurrence of value."
        },
        "reverse": {
          "signature": "(self)",
          "doc": "S.reverse() -- reverse *IN PLACE*"
        }
      },
      "doc": "All the operations on a read-write sequence.",
      "module": "collections.abc"
    },
    "MutableSet": {
      "methods": {
        "add": {
          "signature": "(self, value)",
          "doc": "Add an element."
        },
        "clear": {
          "signature": "(self)",
          "doc": "This is slow (creates N new iterators!) but effective."
        },
        "discard": {
          "signature": "(self, value)",
          "doc": "Remove an element.  Do not raise an exception if absent."
        },
        "isdisjoint": {
          "signature": "(self, other)",
          "doc": "Return True if two sets have a null intersection."
        },
        "pop": {
          "signature": "(self)",
          "doc": "Return the popped value.  Raise KeyError if empty."
        },
        "remove": {
          "signature": "(self, value)",
          "doc": "Remove an element. If not a member, raise a KeyError."
        }
      },
      "doc": "A mutable set is a finite, iterable container.",
      "module": "collections.abc"
    },
    "Reversible": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "Sequence": {
      "methods": {
        "count": {
          "signature": "(self, value)",
          "doc": "S.count(value) -> integer -- return number of occurrences of value"
        },
        "index": {
          "signature": "(self, value, start=0, stop=None)",
          "doc": "S.index(value, [start, [stop]]) -> integer -- return first index of value."
        }
      },
      "doc": "All the operations on a read-only sequence.",
      "module": "pathlib"
    },
    "Set": {
      "methods": {},
      "doc": "Set(expr* elts)",
      "module": "ast"
    },
    "Sized": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "ValuesView": {
      "methods": {},
      "doc": "",
      "module": "collections.abc"
    },
    "AbstractAsyncContextManager": {
      "methods": {},
      "doc": "An abstract base class for asynchronous context managers.",
      "module": "contextlib"
    },
    "AbstractContextManager": {
      "methods": {},
      "doc": "An abstract base class for context managers.",
      "module": "contextlib"
    },
    "AsyncContextDecorator": {
      "methods": {},
      "doc": "A base class or mixin that enables async context managers to work as decorators.",
      "module": "contextlib"
    },
    "AsyncExitStack": {
      "methods": {
        "aclose": {
          "signature": "(self)",
          "doc": "Immediately unwind the context stack."
        },
        "callback": {
          "signature": "(self, callback, /, *args, **kwds)",
          "doc": "Registers an arbitrary callback and arguments."
        },
        "enter_async_context": {
          "signature": "(self, cm)",
          "doc": "Enters the supplied async context manager."
        },
        "enter_context": {
          "signature": "(self, cm)",
          "doc": "Enters the supplied context manager."
        },
        "pop_all": {
          "signature": "(self)",
          "doc": "Preserve the context stack by transferring it to a new instance."
        },
        "push": {
          "signature": "(self, exit)",
          "doc": "Registers a callback with the standard __exit__ method signature."
        },
        "push_async_callback": {
          "signature": "(self, callback, /, *args, **kwds)",
          "doc": "Registers an arbitrary coroutine function and arguments."
        },
        "push_async_exit": {
          "signature": "(self, exit)",
          "doc": "Registers a coroutine function with the standard __aexit__ method"
        }
      },
      "doc": "Async context manager for dynamic management of a stack of exit",
      "module": "contextlib"
    },
    "ContextDecorator": {
      "methods": {},
      "doc": "A base class or mixin that enables context managers to work as decorators.",
      "module": "contextlib"
    },
    "ExitStack": {
      "methods": {
        "callback": {
          "signature": "(self, callback, /, *args, **kwds)",
          "doc": "Registers an arbitrary callback and arguments."
        },
        "close": {
          "signature": "(self)",
          "doc": "Immediately unwind the context stack."
        },
        "enter_context": {
          "signature": "(self, cm)",
          "doc": "Enters the supplied context manager."
        },
        "pop_all": {
          "signature": "(self)",
          "doc": "Preserve the context stack by transferring it to a new instance."
        },
        "push": {
          "signature": "(self, exit)",
          "doc": "Registers a callback with the standard __exit__ method signature."
        }
      },
      "doc": "Context manager for dynamic management of a stack of exit callbacks.",
      "module": "contextlib"
    },
    "aclosing": {
      "methods": {},
      "doc": "Async context manager for safely finalizing an asynchronously cleaned-up",
      "module": "contextlib"
    },
    "closing": {
      "methods": {},
      "doc": "Context to automatically close something at the end of a block.",
      "module": "contextlib"
    },
    "nullcontext": {
      "methods": {},
      "doc": "Context manager that does no additional processing.",
      "module": "ast"
    },
    "redirect_stderr": {
      "methods": {},
      "doc": "Context manager for temporarily redirecting stderr to another file.",
      "module": "contextlib"
    },
    "redirect_stdout": {
      "methods": {},
      "doc": "Context manager for temporarily redirecting stdout to another file.",
      "module": "contextlib"
    },
    "suppress": {
      "methods": {},
      "doc": "Context manager to suppress specified exceptions",
      "module": "contextlib"
    },
    "BinaryIO": {
      "methods": {
        "close": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "fileno": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "flush": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "isatty": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "read": {
          "signature": "(self, n: int = -1) -> ~AnyStr",
          "doc": ""
        },
        "readable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "readline": {
          "signature": "(self, limit: int = -1) -> ~AnyStr",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, hint: int = -1) -> List[~AnyStr]",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset: int, whence: int = 0) -> int",
          "doc": ""
        },
        "seekable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "tell": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "truncate": {
          "signature": "(self, size: int = None) -> int",
          "doc": ""
        },
        "writable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "write": {
          "signature": "(self, s: Union[bytes, bytearray]) -> int",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, lines: List[~AnyStr]) -> None",
          "doc": ""
        }
      },
      "doc": "Typed version of the return of open() in binary mode.",
      "module": "typing"
    },
    "IO": {
      "methods": {
        "close": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "fileno": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "flush": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "isatty": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "read": {
          "signature": "(self, n: int = -1) -> ~AnyStr",
          "doc": ""
        },
        "readable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "readline": {
          "signature": "(self, limit: int = -1) -> ~AnyStr",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, hint: int = -1) -> List[~AnyStr]",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset: int, whence: int = 0) -> int",
          "doc": ""
        },
        "seekable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "tell": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "truncate": {
          "signature": "(self, size: int = None) -> int",
          "doc": ""
        },
        "writable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "write": {
          "signature": "(self, s: ~AnyStr) -> int",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, lines: List[~AnyStr]) -> None",
          "doc": ""
        }
      },
      "doc": "Generic base class for TextIO and BinaryIO.",
      "module": "typing"
    },
    "TextIO": {
      "methods": {
        "close": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "fileno": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "flush": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "isatty": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "read": {
          "signature": "(self, n: int = -1) -> ~AnyStr",
          "doc": ""
        },
        "readable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "readline": {
          "signature": "(self, limit: int = -1) -> ~AnyStr",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, hint: int = -1) -> List[~AnyStr]",
          "doc": ""
        },
        "seek": {
          "signature": "(self, offset: int, whence: int = 0) -> int",
          "doc": ""
        },
        "seekable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "tell": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "truncate": {
          "signature": "(self, size: int = None) -> int",
          "doc": ""
        },
        "writable": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "write": {
          "signature": "(self, s: ~AnyStr) -> int",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, lines: List[~AnyStr]) -> None",
          "doc": ""
        }
      },
      "doc": "Typed version of the return of open() in text mode.",
      "module": "typing"
    },
    "Annotated": {
      "methods": {},
      "doc": "Add context specific metadata to a type.",
      "module": "typing"
    },
    "ForwardRef": {
      "methods": {},
      "doc": "Internal wrapper to hold a forward reference.",
      "module": "typing"
    },
    "Generic": {
      "methods": {},
      "doc": "Abstract base class for generic types.",
      "module": "eudplib.utils.exprproxy"
    },
    "NamedTupleMeta": {
      "methods": {},
      "doc": "",
      "module": "typing"
    },
    "NewType": {
      "methods": {},
      "doc": "NewType creates simple unique types with almost zero",
      "module": "typing"
    },
    "ParamSpec": {
      "methods": {},
      "doc": "Parameter specification variable.",
      "module": "typing"
    },
    "ParamSpecArgs": {
      "methods": {},
      "doc": "The args for a ParamSpec object.",
      "module": "typing"
    },
    "ParamSpecKwargs": {
      "methods": {},
      "doc": "The kwargs for a ParamSpec object.",
      "module": "typing"
    },
    "Protocol": {
      "methods": {},
      "doc": "Base class for protocol classes.",
      "module": "typing"
    },
    "SupportsAbs": {
      "methods": {},
      "doc": "An ABC with one abstract method __abs__ that is covariant in its return type.",
      "module": "typing"
    },
    "SupportsBytes": {
      "methods": {},
      "doc": "An ABC with one abstract method __bytes__.",
      "module": "typing"
    },
    "SupportsComplex": {
      "methods": {},
      "doc": "An ABC with one abstract method __complex__.",
      "module": "typing"
    },
    "SupportsFloat": {
      "methods": {},
      "doc": "An ABC with one abstract method __float__.",
      "module": "typing"
    },
    "SupportsIndex": {
      "methods": {},
      "doc": "An ABC with one abstract method __index__.",
      "module": "typing"
    },
    "SupportsInt": {
      "methods": {},
      "doc": "An ABC with one abstract method __int__.",
      "module": "typing"
    },
    "SupportsRound": {
      "methods": {},
      "doc": "An ABC with one abstract method __round__ that is covariant in its return type.",
      "module": "typing"
    },
    "Text": {
      "methods": {},
      "doc": "str(object='') -> str",
      "module": "typing"
    },
    "TypeVar": {
      "methods": {},
      "doc": "Type variable.",
      "module": "eudplib.offsetmap.csprite"
    },
    "io": {
      "methods": {},
      "doc": "Wrapper namespace for IO generic classes.",
      "module": "typing"
    },
    "re": {
      "methods": {},
      "doc": "Wrapper namespace for re type aliases.",
      "module": "typing"
    },
    "Barrier": {
      "methods": {
        "abort": {
          "signature": "(self)",
          "doc": "Place the barrier into a 'broken' state."
        },
        "reset": {
          "signature": "(self)",
          "doc": "Reset the barrier to the initial state."
        },
        "wait": {
          "signature": "(self, timeout=None)",
          "doc": "Wait for the barrier."
        }
      },
      "doc": "Implements a Barrier.",
      "module": "threading"
    },
    "BoundedSemaphore": {
      "methods": {
        "acquire": {
          "signature": "(self, blocking=True, timeout=None)",
          "doc": "Acquire a semaphore, decrementing the internal counter by one."
        },
        "release": {
          "signature": "(self, n=1)",
          "doc": "Release a semaphore, incrementing the internal counter by one or more."
        }
      },
      "doc": "Implements a bounded semaphore.",
      "module": "threading"
    },
    "BrokenBarrierError": {
      "methods": {},
      "doc": "",
      "module": "threading"
    },
    "Condition": {
      "methods": {
        "CheckArgs": {
          "signature": "(self, i: int) -> None",
          "doc": ""
        },
        "CollectDependency": {
          "signature": "(self, pbuffer: '_PayloadBuffer') -> None",
          "doc": ""
        },
        "Disabled": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> 'RlocInt_C'",
          "doc": ""
        },
        "Negate": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "SetParentTrigger": {
          "signature": "(self, trg: 'RawTrigger', index: int) -> None",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, pbuffer: '_PayloadBuffer') -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib.s"
    },
    "Event": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": "Reset the internal flag to false."
        },
        "isSet": {
          "signature": "(self)",
          "doc": "Return true if and only if the internal flag is true."
        },
        "is_set": {
          "signature": "(self)",
          "doc": "Return true if and only if the internal flag is true."
        },
        "set": {
          "signature": "(self)",
          "doc": "Set the internal flag to true."
        },
        "wait": {
          "signature": "(self, timeout=None)",
          "doc": "Block until the internal flag is true."
        }
      },
      "doc": "Class implementing event objects.",
      "module": "threading"
    },
    "ExceptHookArgs": {
      "methods": {},
      "doc": "ExceptHookArgs",
      "module": "threading"
    },
    "Semaphore": {
      "methods": {
        "acquire": {
          "signature": "(self, blocking=True, timeout=None)",
          "doc": "Acquire a semaphore, decrementing the internal counter by one."
        },
        "release": {
          "signature": "(self, n=1)",
          "doc": "Release a semaphore, incrementing the internal counter by one or more."
        }
      },
      "doc": "This class implements semaphore objects.",
      "module": "threading"
    },
    "Thread": {
      "methods": {
        "getName": {
          "signature": "(self)",
          "doc": "Return a string used for identification purposes only."
        },
        "isDaemon": {
          "signature": "(self)",
          "doc": "Return whether this thread is a daemon."
        },
        "is_alive": {
          "signature": "(self)",
          "doc": "Return whether the thread is alive."
        },
        "join": {
          "signature": "(self, timeout=None)",
          "doc": "Wait until the thread terminates."
        },
        "run": {
          "signature": "(self)",
          "doc": "Method representing the thread's activity."
        },
        "setDaemon": {
          "signature": "(self, daemonic)",
          "doc": "Set whether this thread is a daemon."
        },
        "setName": {
          "signature": "(self, name)",
          "doc": "Set the name string for this thread."
        },
        "start": {
          "signature": "(self)",
          "doc": "Start the thread's activity."
        }
      },
      "doc": "A class that represents a thread of control.",
      "module": "autoupdate"
    },
    "ThreadError": {
      "methods": {},
      "doc": "Unspecified run-time error.",
      "module": "threading"
    },
    "Timer": {
      "methods": {
        "cancel": {
          "signature": "(self)",
          "doc": "Stop the timer if it hasn't finished yet."
        },
        "getName": {
          "signature": "(self)",
          "doc": "Return a string used for identification purposes only."
        },
        "isDaemon": {
          "signature": "(self)",
          "doc": "Return whether this thread is a daemon."
        },
        "is_alive": {
          "signature": "(self)",
          "doc": "Return whether the thread is alive."
        },
        "join": {
          "signature": "(self, timeout=None)",
          "doc": "Wait until the thread terminates."
        },
        "run": {
          "signature": "(self)",
          "doc": ""
        },
        "setDaemon": {
          "signature": "(self, daemonic)",
          "doc": "Set whether this thread is a daemon."
        },
        "setName": {
          "signature": "(self, name)",
          "doc": "Set the name string for this thread."
        },
        "start": {
          "signature": "(self)",
          "doc": "Start the thread's activity."
        }
      },
      "doc": "Call a function after a specified number of seconds:",
      "module": "threading"
    },
    "WeakSet": {
      "methods": {
        "add": {
          "signature": "(self, item)",
          "doc": ""
        },
        "clear": {
          "signature": "(self)",
          "doc": ""
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "difference": {
          "signature": "(self, other)",
          "doc": ""
        },
        "difference_update": {
          "signature": "(self, other)",
          "doc": ""
        },
        "discard": {
          "signature": "(self, item)",
          "doc": ""
        },
        "intersection": {
          "signature": "(self, other)",
          "doc": ""
        },
        "intersection_update": {
          "signature": "(self, other)",
          "doc": ""
        },
        "isdisjoint": {
          "signature": "(self, other)",
          "doc": ""
        },
        "issubset": {
          "signature": "(self, other)",
          "doc": ""
        },
        "issuperset": {
          "signature": "(self, other)",
          "doc": ""
        },
        "pop": {
          "signature": "(self)",
          "doc": ""
        },
        "remove": {
          "signature": "(self, item)",
          "doc": ""
        },
        "symmetric_difference": {
          "signature": "(self, other)",
          "doc": ""
        },
        "symmetric_difference_update": {
          "signature": "(self, other)",
          "doc": ""
        },
        "union": {
          "signature": "(self, other)",
          "doc": ""
        },
        "update": {
          "signature": "(self, other)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "weakref"
    },
    "local": {
      "methods": {},
      "doc": "Thread-local data",
      "module": "threading"
    },
    "Handlers": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "signal"
    },
    "Signals": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "signal"
    },
    "AuthenticationString": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing.process"
    },
    "BaseProcess": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "is_alive": {
          "signature": "(self)",
          "doc": ""
        },
        "join": {
          "signature": "(self, timeout=None)",
          "doc": ""
        },
        "kill": {
          "signature": "(self)",
          "doc": ""
        },
        "run": {
          "signature": "(self)",
          "doc": ""
        },
        "start": {
          "signature": "(self)",
          "doc": ""
        },
        "terminate": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing.process"
    },
    "Struct": {
      "methods": {},
      "doc": "Struct(fmt) --> compiled struct object",
      "module": "struct"
    },
    "PickleBuffer": {
      "methods": {},
      "doc": "Wrapper for potentially out-of-band buffers",
      "module": "pickle"
    },
    "PickleError": {
      "methods": {},
      "doc": "",
      "module": "pickle"
    },
    "Pickler": {
      "methods": {},
      "doc": "This takes a binary file for writing a pickle data stream.",
      "module": "pickle"
    },
    "PicklingError": {
      "methods": {},
      "doc": "",
      "module": "pickle"
    },
    "Unpickler": {
      "methods": {},
      "doc": "This takes a binary file for reading a pickle data stream.",
      "module": "pickle"
    },
    "UnpicklingError": {
      "methods": {},
      "doc": "",
      "module": "pickle"
    },
    "BaseSelector": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Close the selector."
        },
        "get_key": {
          "signature": "(self, fileobj)",
          "doc": "Return the key associated to a registered file object."
        },
        "get_map": {
          "signature": "(self)",
          "doc": "Return a mapping of file objects to selector keys."
        },
        "modify": {
          "signature": "(self, fileobj, events, data=None)",
          "doc": "Change a registered file object monitored events or attached data."
        },
        "register": {
          "signature": "(self, fileobj, events, data=None)",
          "doc": "Register a file object."
        },
        "select": {
          "signature": "(self, timeout=None)",
          "doc": "Perform the actual selection, until some monitored file objects are"
        },
        "unregister": {
          "signature": "(self, fileobj)",
          "doc": "Unregister a file object."
        }
      },
      "doc": "Selector abstract base class.",
      "module": "selectors"
    },
    "DefaultSelector": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "get_key": {
          "signature": "(self, fileobj)",
          "doc": "Return the key associated to a registered file object."
        },
        "get_map": {
          "signature": "(self)",
          "doc": ""
        },
        "modify": {
          "signature": "(self, fileobj, events, data=None)",
          "doc": ""
        },
        "register": {
          "signature": "(self, fileobj, events, data=None)",
          "doc": ""
        },
        "select": {
          "signature": "(self, timeout=None)",
          "doc": ""
        },
        "unregister": {
          "signature": "(self, fileobj)",
          "doc": ""
        }
      },
      "doc": "Select-based selector.",
      "module": "selectors"
    },
    "SelectSelector": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "get_key": {
          "signature": "(self, fileobj)",
          "doc": "Return the key associated to a registered file object."
        },
        "get_map": {
          "signature": "(self)",
          "doc": ""
        },
        "modify": {
          "signature": "(self, fileobj, events, data=None)",
          "doc": ""
        },
        "register": {
          "signature": "(self, fileobj, events, data=None)",
          "doc": ""
        },
        "select": {
          "signature": "(self, timeout=None)",
          "doc": ""
        },
        "unregister": {
          "signature": "(self, fileobj)",
          "doc": ""
        }
      },
      "doc": "Select-based selector.",
      "module": "selectors"
    },
    "SelectorKey": {
      "methods": {},
      "doc": "SelectorKey(fileobj, fd, events, data)",
      "module": "selectors"
    },
    "AddressFamily": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "socket"
    },
    "AddressInfo": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "socket"
    },
    "MsgFlag": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "socket"
    },
    "SocketIO": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Close the SocketIO object.  This doesn't close the underlying"
        },
        "fileno": {
          "signature": "(self)",
          "doc": "Return the file descriptor of the underlying socket."
        },
        "readable": {
          "signature": "(self)",
          "doc": "True if the SocketIO is open for reading."
        },
        "readinto": {
          "signature": "(self, b)",
          "doc": "Read up to len(b) bytes into the writable buffer *b* and return"
        },
        "seekable": {
          "signature": "(self)",
          "doc": "True if the SocketIO is open for seeking."
        },
        "writable": {
          "signature": "(self)",
          "doc": "True if the SocketIO is open for writing."
        },
        "write": {
          "signature": "(self, b)",
          "doc": "Write the given bytes or bytearray object *b* to the socket"
        }
      },
      "doc": "Raw I/O implementation for stream sockets.",
      "module": "socket"
    },
    "SocketKind": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "socket"
    },
    "SocketType": {
      "methods": {},
      "doc": "socket(family=AF_INET, type=SOCK_STREAM, proto=0) -> socket object",
      "module": "socket"
    },
    "gaierror": {
      "methods": {},
      "doc": "",
      "module": "socket"
    },
    "herror": {
      "methods": {},
      "doc": "",
      "module": "socket"
    },
    "socket": {
      "methods": {
        "accept": {
          "signature": "(self)",
          "doc": "accept() -> (socket object, address info)"
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "detach": {
          "signature": "(self)",
          "doc": "detach() -> file descriptor"
        },
        "dup": {
          "signature": "(self)",
          "doc": "dup() -> socket object"
        },
        "get_inheritable": {
          "signature": "(self)",
          "doc": "Get the inheritable flag of the socket"
        },
        "makefile": {
          "signature": "(self, mode='r', buffering=None, *, encoding=None, errors=None, newline=None)",
          "doc": "makefile(...) -> an I/O stream connected to the socket"
        },
        "sendfile": {
          "signature": "(self, file, offset=0, count=None)",
          "doc": "sendfile(file[, offset[, count]]) -> sent"
        },
        "set_inheritable": {
          "signature": "(self, inheritable)",
          "doc": "Set the inheritable flag of the socket"
        }
      },
      "doc": "A subclass of _socket.socket adding the makefile() method.",
      "module": "ssl"
    },
    "timeout": {
      "methods": {},
      "doc": "Timeout expired.",
      "module": "socket"
    },
    "AbstractReducer": {
      "methods": {
        "dump": {
          "signature": "(obj, file, protocol=None)",
          "doc": "Replacement for pickle.dump() using ForkingPickler."
        },
        "duplicate": {
          "signature": "(handle, target_process=None, inheritable=False, *, source_process=None)",
          "doc": "Duplicate a handle.  (target_process is a handle not a pid!)"
        },
        "recv_handle": {
          "signature": "(conn)",
          "doc": "Receive a handle over a local connection."
        },
        "send_handle": {
          "signature": "(conn, handle, destination_pid)",
          "doc": "Send a handle over a local connection."
        },
        "steal_handle": {
          "signature": "(source_pid, handle)",
          "doc": "Steal a handle from process identified by source_pid."
        }
      },
      "doc": "Abstract base class for use in implementing a Reduction class",
      "module": "multiprocessing.reduction"
    },
    "DupHandle": {
      "methods": {
        "detach": {
          "signature": "(self)",
          "doc": "Get the handle.  This should only be called once."
        }
      },
      "doc": "Picklable wrapper for a handle.",
      "module": "multiprocessing.reduction"
    },
    "ForkingPickler": {
      "methods": {},
      "doc": "Pickler subclass used by multiprocessing.",
      "module": "multiprocessing.reduction"
    },
    "AuthenticationError": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing"
    },
    "BaseContext": {
      "methods": {
        "Array": {
          "signature": "(self, typecode_or_type, size_or_initializer, *, lock=True)",
          "doc": "Returns a synchronized shared array"
        },
        "Barrier": {
          "signature": "(self, parties, action=None, timeout=None)",
          "doc": "Returns a barrier object"
        },
        "BoundedSemaphore": {
          "signature": "(self, value=1)",
          "doc": "Returns a bounded semaphore object"
        },
        "Condition": {
          "signature": "(self, lock=None)",
          "doc": "Returns a condition object"
        },
        "Event": {
          "signature": "(self)",
          "doc": "Returns an event object"
        },
        "JoinableQueue": {
          "signature": "(self, maxsize=0)",
          "doc": "Returns a queue object"
        },
        "Lock": {
          "signature": "(self)",
          "doc": "Returns a non-recursive lock object"
        },
        "Manager": {
          "signature": "(self)",
          "doc": "Returns a manager associated with a running server process"
        },
        "Pipe": {
          "signature": "(self, duplex=True)",
          "doc": "Returns two connection object connected by a pipe"
        },
        "Pool": {
          "signature": "(self, processes=None, initializer=None, initargs=(), maxtasksperchild=None)",
          "doc": "Returns a process pool object"
        },
        "Queue": {
          "signature": "(self, maxsize=0)",
          "doc": "Returns a queue object"
        },
        "RLock": {
          "signature": "(self)",
          "doc": "Returns a recursive lock object"
        },
        "RawArray": {
          "signature": "(self, typecode_or_type, size_or_initializer)",
          "doc": "Returns a shared array"
        },
        "RawValue": {
          "signature": "(self, typecode_or_type, *args)",
          "doc": "Returns a shared object"
        },
        "Semaphore": {
          "signature": "(self, value=1)",
          "doc": "Returns a semaphore object"
        },
        "SimpleQueue": {
          "signature": "(self)",
          "doc": "Returns a queue object"
        },
        "Value": {
          "signature": "(self, typecode_or_type, *args, lock=True)",
          "doc": "Returns a synchronized shared object"
        },
        "active_children": {
          "signature": "()",
          "doc": ""
        },
        "allow_connection_pickling": {
          "signature": "(self)",
          "doc": "Install support for sending connections and sockets"
        },
        "cpu_count": {
          "signature": "(self)",
          "doc": "Returns the number of CPUs in the system"
        },
        "current_process": {
          "signature": "()",
          "doc": ""
        },
        "freeze_support": {
          "signature": "(self)",
          "doc": "Check whether this is a fake forked process in a frozen executable."
        },
        "get_context": {
          "signature": "(self, method=None)",
          "doc": ""
        },
        "get_logger": {
          "signature": "(self)",
          "doc": "Return package logger -- if it does not already exist then"
        },
        "get_start_method": {
          "signature": "(self, allow_none=False)",
          "doc": ""
        },
        "log_to_stderr": {
          "signature": "(self, level=None)",
          "doc": "Turn on logging and add a handler which prints to stderr"
        },
        "parent_process": {
          "signature": "()",
          "doc": ""
        },
        "set_executable": {
          "signature": "(self, executable)",
          "doc": "Sets the path to a python.exe or pythonw.exe binary used to run"
        },
        "set_forkserver_preload": {
          "signature": "(self, module_names)",
          "doc": "Set list of module names to try to load in forkserver process."
        },
        "set_start_method": {
          "signature": "(self, method, force=False)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing.context"
    },
    "BufferTooShort": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing"
    },
    "DefaultContext": {
      "methods": {
        "Array": {
          "signature": "(self, typecode_or_type, size_or_initializer, *, lock=True)",
          "doc": "Returns a synchronized shared array"
        },
        "Barrier": {
          "signature": "(self, parties, action=None, timeout=None)",
          "doc": "Returns a barrier object"
        },
        "BoundedSemaphore": {
          "signature": "(self, value=1)",
          "doc": "Returns a bounded semaphore object"
        },
        "Condition": {
          "signature": "(self, lock=None)",
          "doc": "Returns a condition object"
        },
        "Event": {
          "signature": "(self)",
          "doc": "Returns an event object"
        },
        "JoinableQueue": {
          "signature": "(self, maxsize=0)",
          "doc": "Returns a queue object"
        },
        "Lock": {
          "signature": "(self)",
          "doc": "Returns a non-recursive lock object"
        },
        "Manager": {
          "signature": "(self)",
          "doc": "Returns a manager associated with a running server process"
        },
        "Pipe": {
          "signature": "(self, duplex=True)",
          "doc": "Returns two connection object connected by a pipe"
        },
        "Pool": {
          "signature": "(self, processes=None, initializer=None, initargs=(), maxtasksperchild=None)",
          "doc": "Returns a process pool object"
        },
        "Queue": {
          "signature": "(self, maxsize=0)",
          "doc": "Returns a queue object"
        },
        "RLock": {
          "signature": "(self)",
          "doc": "Returns a recursive lock object"
        },
        "RawArray": {
          "signature": "(self, typecode_or_type, size_or_initializer)",
          "doc": "Returns a shared array"
        },
        "RawValue": {
          "signature": "(self, typecode_or_type, *args)",
          "doc": "Returns a shared object"
        },
        "Semaphore": {
          "signature": "(self, value=1)",
          "doc": "Returns a semaphore object"
        },
        "SimpleQueue": {
          "signature": "(self)",
          "doc": "Returns a queue object"
        },
        "Value": {
          "signature": "(self, typecode_or_type, *args, lock=True)",
          "doc": "Returns a synchronized shared object"
        },
        "active_children": {
          "signature": "()",
          "doc": ""
        },
        "allow_connection_pickling": {
          "signature": "(self)",
          "doc": "Install support for sending connections and sockets"
        },
        "cpu_count": {
          "signature": "(self)",
          "doc": "Returns the number of CPUs in the system"
        },
        "current_process": {
          "signature": "()",
          "doc": ""
        },
        "freeze_support": {
          "signature": "(self)",
          "doc": "Check whether this is a fake forked process in a frozen executable."
        },
        "get_all_start_methods": {
          "signature": "(self)",
          "doc": ""
        },
        "get_context": {
          "signature": "(self, method=None)",
          "doc": ""
        },
        "get_logger": {
          "signature": "(self)",
          "doc": "Return package logger -- if it does not already exist then"
        },
        "get_start_method": {
          "signature": "(self, allow_none=False)",
          "doc": ""
        },
        "log_to_stderr": {
          "signature": "(self, level=None)",
          "doc": "Turn on logging and add a handler which prints to stderr"
        },
        "parent_process": {
          "signature": "()",
          "doc": ""
        },
        "set_executable": {
          "signature": "(self, executable)",
          "doc": "Sets the path to a python.exe or pythonw.exe binary used to run"
        },
        "set_forkserver_preload": {
          "signature": "(self, module_names)",
          "doc": "Set list of module names to try to load in forkserver process."
        },
        "set_start_method": {
          "signature": "(self, method, force=False)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing.context"
    },
    "Process": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "is_alive": {
          "signature": "(self)",
          "doc": ""
        },
        "join": {
          "signature": "(self, timeout=None)",
          "doc": ""
        },
        "kill": {
          "signature": "(self)",
          "doc": ""
        },
        "run": {
          "signature": "(self)",
          "doc": ""
        },
        "start": {
          "signature": "(self)",
          "doc": ""
        },
        "terminate": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing"
    },
    "ProcessError": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing"
    },
    "SpawnContext": {
      "methods": {
        "Array": {
          "signature": "(self, typecode_or_type, size_or_initializer, *, lock=True)",
          "doc": "Returns a synchronized shared array"
        },
        "Barrier": {
          "signature": "(self, parties, action=None, timeout=None)",
          "doc": "Returns a barrier object"
        },
        "BoundedSemaphore": {
          "signature": "(self, value=1)",
          "doc": "Returns a bounded semaphore object"
        },
        "Condition": {
          "signature": "(self, lock=None)",
          "doc": "Returns a condition object"
        },
        "Event": {
          "signature": "(self)",
          "doc": "Returns an event object"
        },
        "JoinableQueue": {
          "signature": "(self, maxsize=0)",
          "doc": "Returns a queue object"
        },
        "Lock": {
          "signature": "(self)",
          "doc": "Returns a non-recursive lock object"
        },
        "Manager": {
          "signature": "(self)",
          "doc": "Returns a manager associated with a running server process"
        },
        "Pipe": {
          "signature": "(self, duplex=True)",
          "doc": "Returns two connection object connected by a pipe"
        },
        "Pool": {
          "signature": "(self, processes=None, initializer=None, initargs=(), maxtasksperchild=None)",
          "doc": "Returns a process pool object"
        },
        "Queue": {
          "signature": "(self, maxsize=0)",
          "doc": "Returns a queue object"
        },
        "RLock": {
          "signature": "(self)",
          "doc": "Returns a recursive lock object"
        },
        "RawArray": {
          "signature": "(self, typecode_or_type, size_or_initializer)",
          "doc": "Returns a shared array"
        },
        "RawValue": {
          "signature": "(self, typecode_or_type, *args)",
          "doc": "Returns a shared object"
        },
        "Semaphore": {
          "signature": "(self, value=1)",
          "doc": "Returns a semaphore object"
        },
        "SimpleQueue": {
          "signature": "(self)",
          "doc": "Returns a queue object"
        },
        "Value": {
          "signature": "(self, typecode_or_type, *args, lock=True)",
          "doc": "Returns a synchronized shared object"
        },
        "active_children": {
          "signature": "()",
          "doc": ""
        },
        "allow_connection_pickling": {
          "signature": "(self)",
          "doc": "Install support for sending connections and sockets"
        },
        "cpu_count": {
          "signature": "(self)",
          "doc": "Returns the number of CPUs in the system"
        },
        "current_process": {
          "signature": "()",
          "doc": ""
        },
        "freeze_support": {
          "signature": "(self)",
          "doc": "Check whether this is a fake forked process in a frozen executable."
        },
        "get_context": {
          "signature": "(self, method=None)",
          "doc": ""
        },
        "get_logger": {
          "signature": "(self)",
          "doc": "Return package logger -- if it does not already exist then"
        },
        "get_start_method": {
          "signature": "(self, allow_none=False)",
          "doc": ""
        },
        "log_to_stderr": {
          "signature": "(self, level=None)",
          "doc": "Turn on logging and add a handler which prints to stderr"
        },
        "parent_process": {
          "signature": "()",
          "doc": ""
        },
        "set_executable": {
          "signature": "(self, executable)",
          "doc": "Sets the path to a python.exe or pythonw.exe binary used to run"
        },
        "set_forkserver_preload": {
          "signature": "(self, module_names)",
          "doc": "Set list of module names to try to load in forkserver process."
        },
        "set_start_method": {
          "signature": "(self, method, force=False)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing.context"
    },
    "SpawnProcess": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "is_alive": {
          "signature": "(self)",
          "doc": ""
        },
        "join": {
          "signature": "(self, timeout=None)",
          "doc": ""
        },
        "kill": {
          "signature": "(self)",
          "doc": ""
        },
        "run": {
          "signature": "(self)",
          "doc": ""
        },
        "start": {
          "signature": "(self)",
          "doc": ""
        },
        "terminate": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing.context"
    },
    "GNUTranslations": {
      "methods": {
        "add_fallback": {
          "signature": "(self, fallback)",
          "doc": ""
        },
        "charset": {
          "signature": "(self)",
          "doc": ""
        },
        "gettext": {
          "signature": "(self, message)",
          "doc": ""
        },
        "info": {
          "signature": "(self)",
          "doc": ""
        },
        "install": {
          "signature": "(self, names=None)",
          "doc": ""
        },
        "lgettext": {
          "signature": "(self, message)",
          "doc": ""
        },
        "lngettext": {
          "signature": "(self, msgid1, msgid2, n)",
          "doc": ""
        },
        "ngettext": {
          "signature": "(self, msgid1, msgid2, n)",
          "doc": ""
        },
        "npgettext": {
          "signature": "(self, context, msgid1, msgid2, n)",
          "doc": ""
        },
        "output_charset": {
          "signature": "(self)",
          "doc": ""
        },
        "pgettext": {
          "signature": "(self, context, message)",
          "doc": ""
        },
        "set_output_charset": {
          "signature": "(self, charset)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "gettext"
    },
    "NullTranslations": {
      "methods": {
        "add_fallback": {
          "signature": "(self, fallback)",
          "doc": ""
        },
        "charset": {
          "signature": "(self)",
          "doc": ""
        },
        "gettext": {
          "signature": "(self, message)",
          "doc": ""
        },
        "info": {
          "signature": "(self)",
          "doc": ""
        },
        "install": {
          "signature": "(self, names=None)",
          "doc": ""
        },
        "lgettext": {
          "signature": "(self, message)",
          "doc": ""
        },
        "lngettext": {
          "signature": "(self, msgid1, msgid2, n)",
          "doc": ""
        },
        "ngettext": {
          "signature": "(self, msgid1, msgid2, n)",
          "doc": ""
        },
        "npgettext": {
          "signature": "(self, context, msgid1, msgid2, n)",
          "doc": ""
        },
        "output_charset": {
          "signature": "(self)",
          "doc": ""
        },
        "pgettext": {
          "signature": "(self, context, message)",
          "doc": ""
        },
        "set_output_charset": {
          "signature": "(self, charset)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "gettext"
    },
    "Error": {
      "methods": {},
      "doc": "",
      "module": "shutil"
    },
    "EPError": {
      "methods": {},
      "doc": "",
      "module": "eudplib.maprw.savemap"
    },
    "EPWarning": {
      "methods": {},
      "doc": "",
      "module": "eudplib.utils"
    },
    "TriggerScopeError": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.rawtrigger.triggerscope"
    },
    "BlockStruManager": {
      "methods": {
        "empty": {
          "signature": "(self) -> bool",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.maprw.injector.applyInjector"
    },
    "block": {
      "methods": {},
      "doc": "Built-in immutable sequence.",
      "module": "eudplib.utils.blockstru"
    },
    "Random": {
      "methods": {
        "betavariate": {
          "signature": "(self, alpha, beta)",
          "doc": "Beta distribution."
        },
        "choice": {
          "signature": "(self, seq)",
          "doc": "Choose a random element from a non-empty sequence."
        },
        "choices": {
          "signature": "(self, population, weights=None, *, cum_weights=None, k=1)",
          "doc": "Return a k sized list of population elements chosen with replacement."
        },
        "expovariate": {
          "signature": "(self, lambd)",
          "doc": "Exponential distribution."
        },
        "gammavariate": {
          "signature": "(self, alpha, beta)",
          "doc": "Gamma distribution.  Not the gamma function!"
        },
        "gauss": {
          "signature": "(self, mu, sigma)",
          "doc": "Gaussian distribution."
        },
        "getstate": {
          "signature": "(self)",
          "doc": "Return internal state; can be passed to setstate() later."
        },
        "lognormvariate": {
          "signature": "(self, mu, sigma)",
          "doc": "Log normal distribution."
        },
        "normalvariate": {
          "signature": "(self, mu, sigma)",
          "doc": "Normal distribution."
        },
        "paretovariate": {
          "signature": "(self, alpha)",
          "doc": "Pareto distribution.  alpha is the shape parameter."
        },
        "randbytes": {
          "signature": "(self, n)",
          "doc": "Generate n random bytes."
        },
        "randint": {
          "signature": "(self, a, b)",
          "doc": "Return random integer in range [a, b], including both end points."
        },
        "randrange": {
          "signature": "(self, start, stop=None, step=1)",
          "doc": "Choose a random item from range(start, stop[, step])."
        },
        "sample": {
          "signature": "(self, population, k, *, counts=None)",
          "doc": "Chooses k unique random elements from a population sequence or set."
        },
        "seed": {
          "signature": "(self, a=None, version=2)",
          "doc": "Initialize internal state from a seed."
        },
        "setstate": {
          "signature": "(self, state)",
          "doc": "Restore internal state from object returned by getstate()."
        },
        "shuffle": {
          "signature": "(self, x, random=None)",
          "doc": "Shuffle list x in place, and return None."
        },
        "triangular": {
          "signature": "(self, low=0.0, high=1.0, mode=None)",
          "doc": "Triangular distribution."
        },
        "uniform": {
          "signature": "(self, a, b)",
          "doc": "Get a random number in the range [a, b) or [a, b] depending on rounding."
        },
        "vonmisesvariate": {
          "signature": "(self, mu, kappa)",
          "doc": "Circular data distribution."
        },
        "weibullvariate": {
          "signature": "(self, alpha, beta)",
          "doc": "Weibull distribution."
        }
      },
      "doc": "Random number generator base class used by bound module functions.",
      "module": "random"
    },
    "SystemRandom": {
      "methods": {
        "betavariate": {
          "signature": "(self, alpha, beta)",
          "doc": "Beta distribution."
        },
        "choice": {
          "signature": "(self, seq)",
          "doc": "Choose a random element from a non-empty sequence."
        },
        "choices": {
          "signature": "(self, population, weights=None, *, cum_weights=None, k=1)",
          "doc": "Return a k sized list of population elements chosen with replacement."
        },
        "expovariate": {
          "signature": "(self, lambd)",
          "doc": "Exponential distribution."
        },
        "gammavariate": {
          "signature": "(self, alpha, beta)",
          "doc": "Gamma distribution.  Not the gamma function!"
        },
        "gauss": {
          "signature": "(self, mu, sigma)",
          "doc": "Gaussian distribution."
        },
        "getrandbits": {
          "signature": "(self, k)",
          "doc": "getrandbits(k) -> x.  Generates an int with k random bits."
        },
        "getstate": {
          "signature": "(self, *args, **kwds)",
          "doc": "Method should not be called for a system random number generator."
        },
        "lognormvariate": {
          "signature": "(self, mu, sigma)",
          "doc": "Log normal distribution."
        },
        "normalvariate": {
          "signature": "(self, mu, sigma)",
          "doc": "Normal distribution."
        },
        "paretovariate": {
          "signature": "(self, alpha)",
          "doc": "Pareto distribution.  alpha is the shape parameter."
        },
        "randbytes": {
          "signature": "(self, n)",
          "doc": "Generate n random bytes."
        },
        "randint": {
          "signature": "(self, a, b)",
          "doc": "Return random integer in range [a, b], including both end points."
        },
        "random": {
          "signature": "(self)",
          "doc": "Get the next random number in the range [0.0, 1.0)."
        },
        "randrange": {
          "signature": "(self, start, stop=None, step=1)",
          "doc": "Choose a random item from range(start, stop[, step])."
        },
        "sample": {
          "signature": "(self, population, k, *, counts=None)",
          "doc": "Chooses k unique random elements from a population sequence or set."
        },
        "seed": {
          "signature": "(self, *args, **kwds)",
          "doc": "Stub method.  Not used for a system random number generator."
        },
        "setstate": {
          "signature": "(self, *args, **kwds)",
          "doc": "Method should not be called for a system random number generator."
        },
        "shuffle": {
          "signature": "(self, x, random=None)",
          "doc": "Shuffle list x in place, and return None."
        },
        "triangular": {
          "signature": "(self, low=0.0, high=1.0, mode=None)",
          "doc": "Triangular distribution."
        },
        "uniform": {
          "signature": "(self, a, b)",
          "doc": "Get a random number in the range [a, b) or [a, b] depending on rounding."
        },
        "vonmisesvariate": {
          "signature": "(self, mu, kappa)",
          "doc": "Circular data distribution."
        },
        "weibullvariate": {
          "signature": "(self, alpha, beta)",
          "doc": "Weibull distribution."
        }
      },
      "doc": "Alternate random number generator using sources provided",
      "module": "random"
    },
    "ExprProxy": {
      "methods": {
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.trigtrg.runtrigtrg"
    },
    "RlocInt_C": {
      "methods": {},
      "doc": "",
      "module": "eudplib.trigger.filler"
    },
    "ConstExpr": {
      "methods": {
        "Evaluate": {
          "signature": "(self) -> eudplib.core.allocator.rlocint.RlocInt_C",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "Forward": {
      "methods": {
        "Evaluate": {
          "signature": "(self) -> eudplib.core.allocator.rlocint.RlocInt_C",
          "doc": ""
        },
        "IsSet": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "Reset": {
          "signature": "(self) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "Payload": {
      "methods": {},
      "doc": "",
      "module": "eudplib.maprw.injector.vectorReloc"
    },
    "PayloadBuffer": {
      "methods": {
        "CreatePayload": {
          "signature": "(self) -> eudplib.core.allocator.pbuffer.Payload",
          "doc": ""
        },
        "EndWrite": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "StartWrite": {
          "signature": "(self, writeaddr: int) -> None",
          "doc": ""
        },
        "WriteByte": {
          "signature": "(self, number: int) -> None",
          "doc": ""
        },
        "WriteBytes": {
          "signature": "(self, b: bytes) -> None",
          "doc": ""
        },
        "WriteDword": {
          "signature": "(self, obj: Union[eudplib.core.allocator.constexpr.ConstExpr, int, eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.constexpr.ConstExpr], eudplib.core.allocator.rlocint.RlocInt_C]) -> None",
          "doc": ""
        },
        "WritePack": {
          "signature": "(self, structformat: str, arglist: list[typing.Union[eudplib.core.allocator.constexpr.ConstExpr, int, eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.constexpr.ConstExpr], eudplib.core.allocator.rlocint.RlocInt_C]]) -> None",
          "doc": ""
        },
        "WriteSpace": {
          "signature": "(self, spacesize: int) -> None",
          "doc": ""
        },
        "WriteWord": {
          "signature": "(self, number: int) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.allocator.payload"
    },
    "ObjAllocator": {
      "methods": {
        "EndWrite": {
          "signature": "(self) -> list[int]",
          "doc": ""
        },
        "StartWrite": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "WriteByte": {
          "signature": "(self, number: int) -> None",
          "doc": ""
        },
        "WriteBytes": {
          "signature": "(self, b: bytes) -> None",
          "doc": ""
        },
        "WriteDword": {
          "signature": "(self, obj: Union[eudplib.core.allocator.constexpr.ConstExpr, int, eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.constexpr.ConstExpr], eudplib.core.allocator.rlocint.RlocInt_C]) -> None",
          "doc": ""
        },
        "WritePack": {
          "signature": "(self, structformat: str, arglist: list[typing.Union[eudplib.core.allocator.constexpr.ConstExpr, int, eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.constexpr.ConstExpr], eudplib.core.allocator.rlocint.RlocInt_C]]) -> None",
          "doc": ""
        },
        "WriteSpace": {
          "signature": "(self, ssize: int) -> None",
          "doc": ""
        },
        "WriteWord": {
          "signature": "(self, number: int) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.allocator.payload"
    },
    "ObjCollector": {
      "methods": {
        "EndWrite": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "StartWrite": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "WriteByte": {
          "signature": "(self, number: int) -> None",
          "doc": ""
        },
        "WriteBytes": {
          "signature": "(self, b: bytes) -> None",
          "doc": ""
        },
        "WriteDword": {
          "signature": "(self, obj: Union[eudplib.core.allocator.constexpr.ConstExpr, int, eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.constexpr.ConstExpr], eudplib.core.allocator.rlocint.RlocInt_C]) -> None",
          "doc": ""
        },
        "WritePack": {
          "signature": "(self, structformat: str, arglist: list[typing.Union[eudplib.core.allocator.constexpr.ConstExpr, int, eudplib.utils.exprproxy.ExprProxy[eudplib.core.allocator.constexpr.ConstExpr], eudplib.core.allocator.rlocint.RlocInt_C]]) -> None",
          "doc": ""
        },
        "WriteSpace": {
          "signature": "(self, spacesize: int) -> None",
          "doc": ""
        },
        "WriteWord": {
          "signature": "(self, number: int) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.allocator.payload"
    },
    "PHASE": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "eudplib.core.allocator.payload"
    },
    "CHK": {
      "methods": {
        "clone": {
          "signature": "(self) -> 'CHK'",
          "doc": ""
        },
        "delsection": {
          "signature": "(self, sectionname: str | bytes) -> None",
          "doc": ""
        },
        "enumsection": {
          "signature": "(self) -> list[bytes]",
          "doc": ""
        },
        "getsection": {
          "signature": "(self, sectionname: str | bytes) -> bytes",
          "doc": ""
        },
        "loadblank": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "loadchk": {
          "signature": "(self, b: bytes) -> bool",
          "doc": ""
        },
        "optimize": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "savechk": {
          "signature": "(self) -> bytes",
          "doc": ""
        },
        "setsection": {
          "signature": "(self, sectionname: str | bytes, b: bytes) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.mapdata.fixmapdata"
    },
    "PlayerInfo": {
      "methods": {},
      "doc": "",
      "module": "eudplib.trigger.ptrigger"
    },
    "ArgumentError": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "Array": {
      "methods": {},
      "doc": "XXX to be provided",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "BigEndianStructure": {
      "methods": {},
      "doc": "Structure with big endian byte order",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "CDLL": {
      "methods": {},
      "doc": "An instance of this class represents a loaded dll/shared",
      "module": "eudplib.epscript.epscompile"
    },
    "HRESULT": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "LibraryLoader": {
      "methods": {
        "LoadLibrary": {
          "signature": "(self, name)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "colorama.win32"
    },
    "LittleEndianStructure": {
      "methods": {},
      "doc": "Structure base class",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "OleDLL": {
      "methods": {},
      "doc": "This class represents a dll exporting functions using the",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "PyDLL": {
      "methods": {},
      "doc": "This class represents the Python library itself.  It allows",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "Structure": {
      "methods": {},
      "doc": "Structure base class",
      "module": "colorama.win32"
    },
    "Union": {
      "methods": {},
      "doc": "Union base class",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "WinDLL": {
      "methods": {},
      "doc": "This class represents a dll exporting functions using the",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_bool": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_byte": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_char": {
      "methods": {},
      "doc": "",
      "module": "colorama.win32"
    },
    "c_char_p": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "c_double": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_float": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_int": {
      "methods": {},
      "doc": "",
      "module": "msgbox"
    },
    "c_long": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_longdouble": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_longlong": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_short": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_size_t": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_ssize_t": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_ubyte": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_uint": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_ulong": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_ulonglong": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_ushort": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_void_p": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "c_voidp": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_wchar": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_wchar_p": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "py_object": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_int16": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_int32": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_int64": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_int8": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_uint16": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_uint32": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_uint64": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "c_uint8": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "UnitProperty": {
      "methods": {},
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "TBL": {
      "methods": {
        "AddString": {
          "signature": "(self, string: str | bytes) -> int",
          "doc": ""
        },
        "ForceAddString": {
          "signature": "(self, string: str | bytes) -> int",
          "doc": ""
        },
        "GetString": {
          "signature": "(self, index: int) -> bytes | None",
          "doc": ""
        },
        "GetStringIndex": {
          "signature": "(self, string: str | bytes) -> int",
          "doc": ""
        },
        "LoadTBL": {
          "signature": "(self, content: bytes) -> None",
          "doc": ""
        },
        "LoadTBLWithChk": {
          "signature": "(self, content: bytes, init_chkt: 'tuple[CHK, StringIdMap, StringIdMap, StringIdMap]') -> None",
          "doc": ""
        },
        "SaveTBL": {
          "signature": "(self) -> bytes",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core"
    },
    "StringIdMap": {
      "methods": {
        "AddItem": {
          "signature": "(self, string: str | bytes, strid: int) -> None",
          "doc": ""
        },
        "GetStringIndex": {
          "signature": "(self, string: str | bytes) -> int",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.mapdata.stringmap"
    },
    "Action": {
      "methods": {
        "CheckArgs": {
          "signature": "(self, i: int) -> None",
          "doc": ""
        },
        "CollectDependency": {
          "signature": "(self, pbuffer: '_PayloadBuffer') -> None",
          "doc": ""
        },
        "Disabled": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> 'RlocInt_C'",
          "doc": ""
        },
        "SetParentTrigger": {
          "signature": "(self, trg: 'RawTrigger', index: int) -> None",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, pbuffer: '_PayloadBuffer') -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib.s"
    },
    "EUDObject": {
      "methods": {
        "CollectDependency": {
          "signature": "(self, pbuffer: eudplib.core.allocator.payload.ObjCollector | eudplib.core.allocator.payload.ObjAllocator | eudplib.core.allocator.pbuffer.PayloadBuffer) -> None",
          "doc": ""
        },
        "DynamicConstructed": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> eudplib.core.allocator.rlocint.RlocInt_C",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, pbuffer: eudplib.core.allocator.payload.ObjCollector | eudplib.core.allocator.payload.ObjAllocator | eudplib.core.allocator.pbuffer.PayloadBuffer) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core"
    },
    "Db": {
      "methods": {
        "CollectDependency": {
          "signature": "(self, pbuffer: eudplib.core.allocator.payload.ObjCollector | eudplib.core.allocator.payload.ObjAllocator | eudplib.core.allocator.pbuffer.PayloadBuffer) -> None",
          "doc": ""
        },
        "DynamicConstructed": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> eudplib.core.allocator.rlocint.RlocInt_C",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, pbuffer: eudplib.core.allocator.payload.ObjCollector | eudplib.core.allocator.payload.ObjAllocator | eudplib.core.allocator.pbuffer.PayloadBuffer) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core"
    },
    "RawTrigger": {
      "methods": {
        "CollectDependency": {
          "signature": "(self, pbuffer: '_PayloadBuffer') -> None",
          "doc": ""
        },
        "DynamicConstructed": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> eudplib.core.allocator.rlocint.RlocInt_C",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, pbuffer: '_PayloadBuffer') -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib.unitgroup"
    },
    "Differ": {
      "methods": {
        "compare": {
          "signature": "(self, a, b)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "difflib"
    },
    "HtmlDiff": {
      "methods": {
        "make_file": {
          "signature": "(self, fromlines, tolines, fromdesc='', todesc='', context=False, numlines=5, *, charset='utf-8')",
          "doc": "Returns HTML file of side by side comparison with change highlights"
        },
        "make_table": {
          "signature": "(self, fromlines, tolines, fromdesc='', todesc='', context=False, numlines=5)",
          "doc": "Returns HTML table of side by side comparison with change highlights"
        }
      },
      "doc": "For producing HTML side by side comparison with change highlights.",
      "module": "difflib"
    },
    "SequenceMatcher": {
      "methods": {
        "find_longest_match": {
          "signature": "(self, alo=0, ahi=None, blo=0, bhi=None)",
          "doc": "Find longest matching block in a[alo:ahi] and b[blo:bhi]."
        },
        "get_grouped_opcodes": {
          "signature": "(self, n=3)",
          "doc": " Isolate change clusters by eliminating ranges with no changes."
        },
        "get_matching_blocks": {
          "signature": "(self)",
          "doc": "Return list of triples describing matching subsequences."
        },
        "get_opcodes": {
          "signature": "(self)",
          "doc": "Return list of 5-tuples describing how to turn a into b."
        },
        "quick_ratio": {
          "signature": "(self)",
          "doc": "Return an upper bound on ratio() relatively quickly."
        },
        "ratio": {
          "signature": "(self)",
          "doc": "Return a measure of the sequences' similarity (float in [0,1])."
        },
        "real_quick_ratio": {
          "signature": "(self)",
          "doc": "Return an upper bound on ratio() very quickly."
        },
        "set_seq1": {
          "signature": "(self, a)",
          "doc": "Set the first sequence to be compared."
        },
        "set_seq2": {
          "signature": "(self, b)",
          "doc": "Set the second sequence to be compared."
        },
        "set_seqs": {
          "signature": "(self, a, b)",
          "doc": "Set the two sequences to be compared."
        }
      },
      "doc": "",
      "module": "difflib"
    },
    "VariableBase": {
      "methods": {
        "AddNumber": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "AddNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "Assign": {
          "signature": "(self, value: 'Dword') -> None",
          "doc": ""
        },
        "AtLeast": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "AtLeastX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "AtMost": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "AtMostX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "Exactly": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "ExactlyX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "SetNumber": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SetNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SubtractNumber": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SubtractNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "getValueAddr": {
          "signature": "(self) -> eudplib.core.allocator.constexpr.ConstExpr",
          "doc": ""
        },
        "iinvert": {
          "signature": "(self: ~Self) -> ~Self",
          "doc": ""
        },
        "ineg": {
          "signature": "(self: ~Self) -> ~Self",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.variable.eudv"
    },
    "EUDLightBool": {
      "methods": {
        "Clear": {
          "signature": "(self)",
          "doc": ""
        },
        "IsCleared": {
          "signature": "(self)",
          "doc": ""
        },
        "IsSet": {
          "signature": "(self)",
          "doc": ""
        },
        "Set": {
          "signature": "(self)",
          "doc": ""
        },
        "Toggle": {
          "signature": "(self)",
          "doc": ""
        },
        "getValueAddr": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.trigger.tpatcher"
    },
    "EUDLightVariable": {
      "methods": {
        "AddNumber": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "AddNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "Assign": {
          "signature": "(self, value: 'Dword') -> None",
          "doc": ""
        },
        "AtLeast": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "AtLeastX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "AtMost": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "AtMostX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "Exactly": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "ExactlyX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "SetNumber": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SetNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SubtractNumber": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SubtractNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "checkNonRValue": {
          "signature": "(self)",
          "doc": ""
        },
        "getValueAddr": {
          "signature": "(self)",
          "doc": ""
        },
        "iinvert": {
          "signature": "(self: ~Self) -> ~Self",
          "doc": ""
        },
        "ineg": {
          "signature": "(self: ~Self) -> ~Self",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.trigger.tpatcher"
    },
    "StopTokenizing": {
      "methods": {},
      "doc": "",
      "module": "tokenize"
    },
    "TokenError": {
      "methods": {},
      "doc": "",
      "module": "tokenize"
    },
    "TokenInfo": {
      "methods": {},
      "doc": "",
      "module": "tokenize"
    },
    "Untokenizer": {
      "methods": {
        "add_whitespace": {
          "signature": "(self, start)",
          "doc": ""
        },
        "compat": {
          "signature": "(self, token, iterable)",
          "doc": ""
        },
        "untokenize": {
          "signature": "(self, iterable)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "tokenize"
    },
    "FrameSummary": {
      "methods": {},
      "doc": "A single frame from a traceback.",
      "module": "traceback"
    },
    "StackSummary": {
      "methods": {
        "format": {
          "signature": "(self)",
          "doc": "Format the stack ready for printing."
        }
      },
      "doc": "A stack of frames.",
      "module": "traceback"
    },
    "TracebackException": {
      "methods": {
        "format": {
          "signature": "(self, *, chain=True)",
          "doc": "Format the exception."
        },
        "format_exception_only": {
          "signature": "(self)",
          "doc": "Format the exception part of the traceback."
        }
      },
      "doc": "An exception ready for rendering.",
      "module": "traceback"
    },
    "EUDCustomVarBuffer": {
      "methods": {
        "CollectDependency": {
          "signature": "(self, emitbuffer)",
          "doc": ""
        },
        "CreateMultipleVarTriggers": {
          "signature": "(self, v, initvals)",
          "doc": ""
        },
        "CreateVarTrigger": {
          "signature": "(self, v, initval)",
          "doc": ""
        },
        "DynamicConstructed": {
          "signature": "(self)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> eudplib.core.allocator.rlocint.RlocInt_C",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self)",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, emitbuffer)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.variable.vbuf"
    },
    "EUDVarBuffer": {
      "methods": {
        "CollectDependency": {
          "signature": "(self, emitbuffer) -> None",
          "doc": ""
        },
        "CreateMultipleVarTriggers": {
          "signature": "(self, v, initvals)",
          "doc": ""
        },
        "CreateVarTrigger": {
          "signature": "(self, v, initval)",
          "doc": ""
        },
        "DynamicConstructed": {
          "signature": "(self) -> Literal[True]",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> eudplib.core.allocator.rlocint.RlocInt_C",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, emitbuffer) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.variable.vbuf"
    },
    "EUDVariable": {
      "methods": {
        "AddDest": {
          "signature": "(self, dest)",
          "doc": ""
        },
        "AddDestX": {
          "signature": "(self, dest: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "AddMask": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "AddMaskX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "AddNumber": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "AddNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "AtLeast": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "AtLeastX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "AtMost": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "AtMostX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "Exactly": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "ExactlyX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "GetVTable": {
          "signature": "(self) -> eudplib.core.allocator.constexpr.ConstExpr",
          "doc": ""
        },
        "MaskAtLeast": {
          "signature": "(self, value)",
          "doc": ""
        },
        "MaskAtLeastX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "MaskAtMost": {
          "signature": "(self, value)",
          "doc": ""
        },
        "MaskAtMostX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "MaskExactly": {
          "signature": "(self, value)",
          "doc": ""
        },
        "MaskExactlyX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "QueueAddTo": {
          "signature": "(self, dest)",
          "doc": ""
        },
        "QueueAssignTo": {
          "signature": "(self, dest)",
          "doc": ""
        },
        "QueueSubtractTo": {
          "signature": "(self, dest)",
          "doc": ""
        },
        "SetDest": {
          "signature": "(self, dest)",
          "doc": ""
        },
        "SetDestX": {
          "signature": "(self, dest: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SetMask": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SetMaskX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SetModifier": {
          "signature": "(self, modifier)",
          "doc": ""
        },
        "SetNumber": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SetNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SubtractDest": {
          "signature": "(self, dest)",
          "doc": ""
        },
        "SubtractDestX": {
          "signature": "(self, dest: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SubtractMask": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SubtractMaskX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SubtractNumber": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SubtractNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "checkNonRValue": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "getDestAddr": {
          "signature": "(self) -> eudplib.core.allocator.constexpr.ConstExpr",
          "doc": ""
        },
        "getMaskAddr": {
          "signature": "(self) -> eudplib.core.allocator.constexpr.ConstExpr",
          "doc": ""
        },
        "getValueAddr": {
          "signature": "(self) -> eudplib.core.allocator.constexpr.ConstExpr",
          "doc": ""
        },
        "iinvert": {
          "signature": "(self: ~Self) -> ~Self",
          "doc": ""
        },
        "ineg": {
          "signature": "(self: ~Self) -> ~Self",
          "doc": ""
        },
        "makeL": {
          "signature": "(self) -> 'EUDVariable'",
          "doc": ""
        },
        "makeR": {
          "signature": "(self) -> 'EUDVariable'",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.utils"
    },
    "VariableTriggerForward": {
      "methods": {
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.variable.eudxv"
    },
    "EUDXVariable": {
      "methods": {
        "AddDest": {
          "signature": "(self, dest)",
          "doc": ""
        },
        "AddDestX": {
          "signature": "(self, dest: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "AddMask": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "AddMaskX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "AddNumber": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "AddNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "Assign": {
          "signature": "(self, other)",
          "doc": ""
        },
        "AtLeast": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "AtLeastX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "AtMost": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "AtMostX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "Exactly": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "ExactlyX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "GetVTable": {
          "signature": "(self) -> eudplib.core.allocator.constexpr.ConstExpr",
          "doc": ""
        },
        "MaskAtLeast": {
          "signature": "(self, value)",
          "doc": ""
        },
        "MaskAtLeastX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "MaskAtMost": {
          "signature": "(self, value)",
          "doc": ""
        },
        "MaskAtMostX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "MaskExactly": {
          "signature": "(self, value)",
          "doc": ""
        },
        "MaskExactlyX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "QueueAddTo": {
          "signature": "(self, dest)",
          "doc": ""
        },
        "QueueAssignTo": {
          "signature": "(self, dest)",
          "doc": ""
        },
        "QueueSubtractTo": {
          "signature": "(self, dest)",
          "doc": ""
        },
        "SetDest": {
          "signature": "(self, dest)",
          "doc": ""
        },
        "SetDestX": {
          "signature": "(self, dest: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SetMask": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SetMaskX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SetModifier": {
          "signature": "(self, modifier)",
          "doc": ""
        },
        "SetNumber": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SetNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SubtractDest": {
          "signature": "(self, dest)",
          "doc": ""
        },
        "SubtractDestX": {
          "signature": "(self, dest: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SubtractMask": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SubtractMaskX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SubtractNumber": {
          "signature": "(self, value: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "SubtractNumberX": {
          "signature": "(self, value: 'Dword', mask: 'Dword') -> eudplib.core.rawtrigger.action.Action",
          "doc": ""
        },
        "checkNonRValue": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "getDestAddr": {
          "signature": "(self) -> eudplib.core.allocator.constexpr.ConstExpr",
          "doc": ""
        },
        "getMaskAddr": {
          "signature": "(self) -> eudplib.core.allocator.constexpr.ConstExpr",
          "doc": ""
        },
        "getValueAddr": {
          "signature": "(self) -> eudplib.core.allocator.constexpr.ConstExpr",
          "doc": ""
        },
        "iinvert": {
          "signature": "(self: ~Self) -> ~Self",
          "doc": ""
        },
        "ineg": {
          "signature": "(self: ~Self) -> ~Self",
          "doc": ""
        },
        "makeL": {
          "signature": "(self) -> 'EUDVariable'",
          "doc": ""
        },
        "makeR": {
          "signature": "(self) -> 'EUDVariable'",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core"
    },
    "createEncoder": {
      "methods": {
        "cast": {
          "signature": "(self, s)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.eudfunc.consttype"
    },
    "AST": {
      "methods": {},
      "doc": "",
      "module": "ast"
    },
    "Add": {
      "methods": {},
      "doc": "Add",
      "module": "ast"
    },
    "And": {
      "methods": {},
      "doc": "And",
      "module": "ast"
    },
    "AnnAssign": {
      "methods": {},
      "doc": "AnnAssign(expr target, expr annotation, expr? value, int simple)",
      "module": "ast"
    },
    "Assert": {
      "methods": {},
      "doc": "Assert(expr test, expr? msg)",
      "module": "ast"
    },
    "Assign": {
      "methods": {},
      "doc": "Assign(expr* targets, expr value, string? type_comment)",
      "module": "ast"
    },
    "AsyncFor": {
      "methods": {},
      "doc": "AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)",
      "module": "ast"
    },
    "AsyncFunctionDef": {
      "methods": {},
      "doc": "AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)",
      "module": "ast"
    },
    "AsyncWith": {
      "methods": {},
      "doc": "AsyncWith(withitem* items, stmt* body, string? type_comment)",
      "module": "ast"
    },
    "Attribute": {
      "methods": {},
      "doc": "Attribute(name, kind, defining_class, object)",
      "module": "inspect"
    },
    "AugAssign": {
      "methods": {},
      "doc": "AugAssign(expr target, operator op, expr value)",
      "module": "ast"
    },
    "AugLoad": {
      "methods": {},
      "doc": "Deprecated AST node class.  Unused in Python 3.",
      "module": "ast"
    },
    "AugStore": {
      "methods": {},
      "doc": "Deprecated AST node class.  Unused in Python 3.",
      "module": "ast"
    },
    "Await": {
      "methods": {},
      "doc": "Await(expr value)",
      "module": "ast"
    },
    "BinOp": {
      "methods": {},
      "doc": "BinOp(expr left, operator op, expr right)",
      "module": "ast"
    },
    "BitAnd": {
      "methods": {},
      "doc": "BitAnd",
      "module": "ast"
    },
    "BitOr": {
      "methods": {},
      "doc": "BitOr",
      "module": "ast"
    },
    "BitXor": {
      "methods": {},
      "doc": "BitXor",
      "module": "ast"
    },
    "BoolOp": {
      "methods": {},
      "doc": "BoolOp(boolop op, expr* values)",
      "module": "ast"
    },
    "Break": {
      "methods": {},
      "doc": "Break",
      "module": "ast"
    },
    "Bytes": {
      "methods": {},
      "doc": "Deprecated AST node class. Use ast.Constant instead",
      "module": "ast"
    },
    "Call": {
      "methods": {},
      "doc": "Call(expr func, expr* args, keyword* keywords)",
      "module": "ast"
    },
    "ClassDef": {
      "methods": {},
      "doc": "ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list)",
      "module": "ast"
    },
    "Compare": {
      "methods": {},
      "doc": "Compare(expr left, cmpop* ops, expr* comparators)",
      "module": "ast"
    },
    "Constant": {
      "methods": {},
      "doc": "Constant(constant value, string? kind)",
      "module": "ast"
    },
    "Continue": {
      "methods": {},
      "doc": "Continue",
      "module": "ast"
    },
    "Del": {
      "methods": {},
      "doc": "Del",
      "module": "ast"
    },
    "Delete": {
      "methods": {},
      "doc": "Delete(expr* targets)",
      "module": "ast"
    },
    "Dict": {
      "methods": {},
      "doc": "Dict(expr* keys, expr* values)",
      "module": "ast"
    },
    "DictComp": {
      "methods": {},
      "doc": "DictComp(expr key, expr value, comprehension* generators)",
      "module": "ast"
    },
    "Div": {
      "methods": {},
      "doc": "Div",
      "module": "ast"
    },
    "Ellipsis": {
      "methods": {},
      "doc": "Deprecated AST node class. Use ast.Constant instead",
      "module": "ast"
    },
    "Eq": {
      "methods": {},
      "doc": "Eq",
      "module": "ast"
    },
    "ExceptHandler": {
      "methods": {},
      "doc": "ExceptHandler(expr? type, identifier? name, stmt* body)",
      "module": "ast"
    },
    "Expr": {
      "methods": {},
      "doc": "Expr(expr value)",
      "module": "ast"
    },
    "Expression": {
      "methods": {},
      "doc": "Expression(expr body)",
      "module": "ast"
    },
    "ExtSlice": {
      "methods": {},
      "doc": "Deprecated AST node class. Use ast.Tuple instead.",
      "module": "ast"
    },
    "FloorDiv": {
      "methods": {},
      "doc": "FloorDiv",
      "module": "ast"
    },
    "For": {
      "methods": {},
      "doc": "For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)",
      "module": "ast"
    },
    "FormattedValue": {
      "methods": {},
      "doc": "FormattedValue(expr value, int conversion, expr? format_spec)",
      "module": "ast"
    },
    "FunctionDef": {
      "methods": {},
      "doc": "FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)",
      "module": "ast"
    },
    "GeneratorExp": {
      "methods": {},
      "doc": "GeneratorExp(expr elt, comprehension* generators)",
      "module": "ast"
    },
    "Global": {
      "methods": {},
      "doc": "Global(identifier* names)",
      "module": "ast"
    },
    "Gt": {
      "methods": {},
      "doc": "Gt",
      "module": "ast"
    },
    "GtE": {
      "methods": {},
      "doc": "GtE",
      "module": "ast"
    },
    "If": {
      "methods": {},
      "doc": "If(expr test, stmt* body, stmt* orelse)",
      "module": "ast"
    },
    "IfExp": {
      "methods": {},
      "doc": "IfExp(expr test, expr body, expr orelse)",
      "module": "ast"
    },
    "Import": {
      "methods": {},
      "doc": "Import(alias* names)",
      "module": "ast"
    },
    "ImportFrom": {
      "methods": {},
      "doc": "ImportFrom(identifier? module, alias* names, int? level)",
      "module": "ast"
    },
    "In": {
      "methods": {},
      "doc": "In",
      "module": "ast"
    },
    "Index": {
      "methods": {},
      "doc": "Deprecated AST node class. Use the index value directly instead.",
      "module": "ast"
    },
    "Interactive": {
      "methods": {},
      "doc": "Interactive(stmt* body)",
      "module": "ast"
    },
    "Invert": {
      "methods": {},
      "doc": "Invert",
      "module": "ast"
    },
    "Is": {
      "methods": {},
      "doc": "Is",
      "module": "ast"
    },
    "IsNot": {
      "methods": {},
      "doc": "IsNot",
      "module": "ast"
    },
    "JoinedStr": {
      "methods": {},
      "doc": "JoinedStr(expr* values)",
      "module": "ast"
    },
    "LShift": {
      "methods": {},
      "doc": "LShift",
      "module": "ast"
    },
    "Lambda": {
      "methods": {},
      "doc": "Lambda(arguments args, expr body)",
      "module": "ast"
    },
    "List": {
      "methods": {},
      "doc": "List(expr* elts, expr_context ctx)",
      "module": "ast"
    },
    "ListComp": {
      "methods": {},
      "doc": "ListComp(expr elt, comprehension* generators)",
      "module": "ast"
    },
    "Load": {
      "methods": {},
      "doc": "Load",
      "module": "ast"
    },
    "Lt": {
      "methods": {},
      "doc": "Lt",
      "module": "ast"
    },
    "LtE": {
      "methods": {},
      "doc": "LtE",
      "module": "ast"
    },
    "MatMult": {
      "methods": {},
      "doc": "MatMult",
      "module": "ast"
    },
    "MatchAs": {
      "methods": {},
      "doc": "MatchAs(pattern? pattern, identifier? name)",
      "module": "ast"
    },
    "MatchClass": {
      "methods": {},
      "doc": "MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, pattern* kwd_patterns)",
      "module": "ast"
    },
    "MatchMapping": {
      "methods": {},
      "doc": "MatchMapping(expr* keys, pattern* patterns, identifier? rest)",
      "module": "ast"
    },
    "MatchOr": {
      "methods": {},
      "doc": "MatchOr(pattern* patterns)",
      "module": "ast"
    },
    "MatchSequence": {
      "methods": {},
      "doc": "MatchSequence(pattern* patterns)",
      "module": "ast"
    },
    "MatchSingleton": {
      "methods": {},
      "doc": "MatchSingleton(constant value)",
      "module": "ast"
    },
    "MatchStar": {
      "methods": {},
      "doc": "MatchStar(identifier? name)",
      "module": "ast"
    },
    "MatchValue": {
      "methods": {},
      "doc": "MatchValue(expr value)",
      "module": "ast"
    },
    "Mod": {
      "methods": {},
      "doc": "Mod",
      "module": "ast"
    },
    "Module": {
      "methods": {},
      "doc": "Module(stmt* body, type_ignore* type_ignores)",
      "module": "ast"
    },
    "Mult": {
      "methods": {},
      "doc": "Mult",
      "module": "ast"
    },
    "Name": {
      "methods": {},
      "doc": "Name(identifier id, expr_context ctx)",
      "module": "ast"
    },
    "NameConstant": {
      "methods": {},
      "doc": "Deprecated AST node class. Use ast.Constant instead",
      "module": "ast"
    },
    "NamedExpr": {
      "methods": {},
      "doc": "NamedExpr(expr target, expr value)",
      "module": "ast"
    },
    "NodeTransformer": {
      "methods": {
        "generic_visit": {
          "signature": "(self, node)",
          "doc": ""
        },
        "visit": {
          "signature": "(self, node)",
          "doc": "Visit a node."
        },
        "visit_Constant": {
          "signature": "(self, node)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "ast"
    },
    "NodeVisitor": {
      "methods": {
        "generic_visit": {
          "signature": "(self, node)",
          "doc": "Called if no explicit visitor function exists for a node."
        },
        "visit": {
          "signature": "(self, node)",
          "doc": "Visit a node."
        },
        "visit_Constant": {
          "signature": "(self, node)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "ast"
    },
    "Nonlocal": {
      "methods": {},
      "doc": "Nonlocal(identifier* names)",
      "module": "ast"
    },
    "Not": {
      "methods": {},
      "doc": "Not",
      "module": "ast"
    },
    "NotEq": {
      "methods": {},
      "doc": "NotEq",
      "module": "ast"
    },
    "NotIn": {
      "methods": {},
      "doc": "NotIn",
      "module": "ast"
    },
    "Num": {
      "methods": {},
      "doc": "Deprecated AST node class. Use ast.Constant instead",
      "module": "ast"
    },
    "Or": {
      "methods": {},
      "doc": "Or",
      "module": "ast"
    },
    "Param": {
      "methods": {},
      "doc": "Deprecated AST node class.  Unused in Python 3.",
      "module": "ast"
    },
    "Pass": {
      "methods": {},
      "doc": "Pass",
      "module": "ast"
    },
    "Pow": {
      "methods": {},
      "doc": "Pow",
      "module": "ast"
    },
    "RShift": {
      "methods": {},
      "doc": "RShift",
      "module": "ast"
    },
    "Raise": {
      "methods": {},
      "doc": "Raise(expr? exc, expr? cause)",
      "module": "ast"
    },
    "Return": {
      "methods": {},
      "doc": "Return(expr? value)",
      "module": "ast"
    },
    "SetComp": {
      "methods": {},
      "doc": "SetComp(expr elt, comprehension* generators)",
      "module": "ast"
    },
    "Slice": {
      "methods": {},
      "doc": "Slice(expr? lower, expr? upper, expr? step)",
      "module": "ast"
    },
    "Starred": {
      "methods": {},
      "doc": "Starred(expr value, expr_context ctx)",
      "module": "ast"
    },
    "Store": {
      "methods": {},
      "doc": "Store",
      "module": "ast"
    },
    "Str": {
      "methods": {},
      "doc": "Deprecated AST node class. Use ast.Constant instead",
      "module": "ast"
    },
    "Sub": {
      "methods": {},
      "doc": "Sub",
      "module": "ast"
    },
    "Subscript": {
      "methods": {},
      "doc": "Subscript(expr value, expr slice, expr_context ctx)",
      "module": "ast"
    },
    "Suite": {
      "methods": {},
      "doc": "Deprecated AST node class.  Unused in Python 3.",
      "module": "ast"
    },
    "Try": {
      "methods": {},
      "doc": "Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)",
      "module": "ast"
    },
    "Tuple": {
      "methods": {},
      "doc": "Tuple(expr* elts, expr_context ctx)",
      "module": "ast"
    },
    "TypeIgnore": {
      "methods": {},
      "doc": "TypeIgnore(int lineno, string tag)",
      "module": "ast"
    },
    "UAdd": {
      "methods": {},
      "doc": "UAdd",
      "module": "ast"
    },
    "USub": {
      "methods": {},
      "doc": "USub",
      "module": "ast"
    },
    "UnaryOp": {
      "methods": {},
      "doc": "UnaryOp(unaryop op, expr operand)",
      "module": "ast"
    },
    "While": {
      "methods": {},
      "doc": "While(expr test, stmt* body, stmt* orelse)",
      "module": "ast"
    },
    "With": {
      "methods": {},
      "doc": "With(withitem* items, stmt* body, string? type_comment)",
      "module": "ast"
    },
    "Yield": {
      "methods": {},
      "doc": "Yield(expr? value)",
      "module": "ast"
    },
    "YieldFrom": {
      "methods": {},
      "doc": "YieldFrom(expr value)",
      "module": "ast"
    },
    "alias": {
      "methods": {},
      "doc": "alias(identifier name, identifier? asname)",
      "module": "ast"
    },
    "arg": {
      "methods": {},
      "doc": "arg(identifier arg, expr? annotation, string? type_comment)",
      "module": "ast"
    },
    "arguments": {
      "methods": {},
      "doc": "arguments(arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs, expr* kw_defaults, arg? kwarg, expr* defaults)",
      "module": "ast"
    },
    "boolop": {
      "methods": {},
      "doc": "boolop = And | Or",
      "module": "ast"
    },
    "cmpop": {
      "methods": {},
      "doc": "cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn",
      "module": "ast"
    },
    "comprehension": {
      "methods": {},
      "doc": "comprehension(expr target, expr iter, expr* ifs, int is_async)",
      "module": "ast"
    },
    "excepthandler": {
      "methods": {},
      "doc": "excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)",
      "module": "ast"
    },
    "expr": {
      "methods": {},
      "doc": "expr = BoolOp(boolop op, expr* values)",
      "module": "ast"
    },
    "expr_context": {
      "methods": {},
      "doc": "expr_context = Load | Store | Del",
      "module": "ast"
    },
    "keyword": {
      "methods": {},
      "doc": "keyword(identifier? arg, expr value)",
      "module": "ast"
    },
    "match_case": {
      "methods": {},
      "doc": "match_case(pattern pattern, expr? guard, stmt* body)",
      "module": "ast"
    },
    "mod": {
      "methods": {},
      "doc": "mod = Module(stmt* body, type_ignore* type_ignores)",
      "module": "ast"
    },
    "operator": {
      "methods": {},
      "doc": "operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift | RShift | BitOr | BitXor | BitAnd | FloorDiv",
      "module": "ast"
    },
    "pattern": {
      "methods": {},
      "doc": "pattern = MatchValue(expr value)",
      "module": "ast"
    },
    "stmt": {
      "methods": {},
      "doc": "stmt = FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)",
      "module": "ast"
    },
    "type_ignore": {
      "methods": {},
      "doc": "type_ignore = TypeIgnore(int lineno, string tag)",
      "module": "ast"
    },
    "unaryop": {
      "methods": {},
      "doc": "unaryop = Invert | Not | UAdd | USub",
      "module": "ast"
    },
    "withitem": {
      "methods": {},
      "doc": "withitem(expr context_expr, expr? optional_vars)",
      "module": "ast"
    },
    "Bytecode": {
      "methods": {
        "dis": {
          "signature": "(self)",
          "doc": "Return a formatted view of the bytecode operations."
        },
        "info": {
          "signature": "(self)",
          "doc": "Return formatted information about the code object."
        }
      },
      "doc": "The bytecode operations of a piece of code",
      "module": "dis"
    },
    "Instruction": {
      "methods": {},
      "doc": "Details for a bytecode operation",
      "module": "dis"
    },
    "ArgInfo": {
      "methods": {},
      "doc": "ArgInfo(args, varargs, keywords, locals)",
      "module": "inspect"
    },
    "ArgSpec": {
      "methods": {},
      "doc": "ArgSpec(args, varargs, keywords, defaults)",
      "module": "inspect"
    },
    "Arguments": {
      "methods": {},
      "doc": "Arguments(args, varargs, varkw)",
      "module": "inspect"
    },
    "BlockFinder": {
      "methods": {
        "tokeneater": {
          "signature": "(self, type, token, srowcol, erowcol, line)",
          "doc": ""
        }
      },
      "doc": "Provide a tokeneater() method to detect the end of a code block.",
      "module": "inspect"
    },
    "BoundArguments": {
      "methods": {
        "apply_defaults": {
          "signature": "(self)",
          "doc": "Set default values for missing arguments."
        }
      },
      "doc": "Result of `Signature.bind` call.  Holds the mapping of arguments",
      "module": "inspect"
    },
    "ClassFoundException": {
      "methods": {},
      "doc": "",
      "module": "inspect"
    },
    "ClosureVars": {
      "methods": {},
      "doc": "ClosureVars(nonlocals, globals, builtins, unbound)",
      "module": "inspect"
    },
    "EndOfBlock": {
      "methods": {},
      "doc": "",
      "module": "inspect"
    },
    "FrameInfo": {
      "methods": {},
      "doc": "FrameInfo(frame, filename, lineno, function, code_context, index)",
      "module": "inspect"
    },
    "FullArgSpec": {
      "methods": {},
      "doc": "FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)",
      "module": "inspect"
    },
    "Parameter": {
      "methods": {
        "replace": {
          "signature": "(self, *, name=<class 'inspect._void'>, kind=<class 'inspect._void'>, annotation=<class 'inspect._void'>, default=<class 'inspect._void'>)",
          "doc": "Creates a customized copy of the Parameter."
        }
      },
      "doc": "Represents a parameter in a function signature.",
      "module": "inspect"
    },
    "Signature": {
      "methods": {
        "bind": {
          "signature": "(self, /, *args, **kwargs)",
          "doc": "Get a BoundArguments object, that maps the passed `args`"
        },
        "bind_partial": {
          "signature": "(self, /, *args, **kwargs)",
          "doc": "Get a BoundArguments object, that partially maps the"
        },
        "replace": {
          "signature": "(self, *, parameters=<class 'inspect._void'>, return_annotation=<class 'inspect._void'>)",
          "doc": "Creates a customized copy of the Signature."
        }
      },
      "doc": "A Signature object represents the overall signature of a function.",
      "module": "inspect"
    },
    "Traceback": {
      "methods": {},
      "doc": "Traceback(filename, lineno, function, code_context, index)",
      "module": "inspect"
    },
    "EUDFuncN": {
      "methods": {
        "size": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "freeze.obfpatch"
    },
    "EUDFullFuncN": {
      "methods": {
        "size": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.eudfunc.eudf"
    },
    "EUDTypedFuncN": {
      "methods": {
        "size": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.eudfunc.eudfmethod"
    },
    "EUDXTypedFuncN": {
      "methods": {
        "size": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.eudfunc.eudf"
    },
    "selftype": {
      "methods": {
        "cast": {
          "signature": "(_from)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core"
    },
    "BitsTrg": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.eudstruct.vararray"
    },
    "EUDStructArray": {
      "methods": {
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "copyTo": {
          "signature": "(self, inst)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core.eudstruct.structarr"
    },
    "EUDStruct": {
      "methods": {
        "asVariable": {
          "signature": "(self)",
          "doc": ""
        },
        "constructor": {
          "signature": "(self)",
          "doc": ""
        },
        "constructor_static": {
          "signature": "(self, *args, **kwargs)",
          "doc": ""
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "copyto": {
          "signature": "(self, inst)",
          "doc": ""
        },
        "destructor": {
          "signature": "(self)",
          "doc": ""
        },
        "eqattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getfield": {
          "signature": "(self, name)",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "setall": {
          "signature": "(self, values)",
          "doc": ""
        },
        "setfield": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.core"
    },
    "CtrlStruOpener": {
      "methods": {},
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDJumpBuffer": {
      "methods": {
        "CollectDependency": {
          "signature": "(self, emitbuffer)",
          "doc": ""
        },
        "CreateJumpTrigger": {
          "signature": "(self, v, nextptr)",
          "doc": ""
        },
        "CreateMultipleJumpTriggers": {
          "signature": "(self, v, nextptrs)",
          "doc": ""
        },
        "DynamicConstructed": {
          "signature": "(self)",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> eudplib.core.allocator.rlocint.RlocInt_C",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self)",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, emitbuffer)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.ctrlstru.jumptable"
    },
    "JumpTriggerForward": {
      "methods": {
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.ctrlstru.swblock"
    },
    "EUDSCAnd": {
      "methods": {
        "Patch": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "EUDSCOr": {
      "methods": {},
      "doc": "",
      "module": "eudplib.ctrlstru"
    },
    "CalledProcessError": {
      "methods": {},
      "doc": "Raised when run() is called with check=True and the process",
      "module": "subprocess"
    },
    "CompletedProcess": {
      "methods": {
        "check_returncode": {
          "signature": "(self)",
          "doc": "Raise CalledProcessError if the exit code is non-zero."
        }
      },
      "doc": "A process that has finished running.",
      "module": "subprocess"
    },
    "Handle": {
      "methods": {
        "Close": {
          "signature": "(self, CloseHandle=<built-in function CloseHandle>)",
          "doc": ""
        },
        "Detach": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "subprocess"
    },
    "Popen": {
      "methods": {
        "communicate": {
          "signature": "(self, input=None, timeout=None)",
          "doc": "Interact with process: Send data to stdin and close it."
        },
        "kill": {
          "signature": "(self)",
          "doc": "Terminates the process."
        },
        "poll": {
          "signature": "(self)",
          "doc": "Check if child process has terminated. Set and return returncode"
        },
        "send_signal": {
          "signature": "(self, sig)",
          "doc": "Send a signal to the process."
        },
        "terminate": {
          "signature": "(self)",
          "doc": "Terminates the process."
        },
        "wait": {
          "signature": "(self, timeout=None)",
          "doc": "Wait for child process to terminate; returns self.returncode."
        }
      },
      "doc": " Execute a child program in a new process.",
      "module": "subprocess"
    },
    "STARTUPINFO": {
      "methods": {
        "copy": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "subprocess"
    },
    "SubprocessError": {
      "methods": {},
      "doc": "",
      "module": "subprocess"
    },
    "TimeoutExpired": {
      "methods": {},
      "doc": "This exception is raised when the timeout expires while waiting for a",
      "module": "subprocess"
    },
    "EPSFinder": {
      "methods": {
        "find_spec": {
          "signature": "(self, fullname, path, target=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.epscript"
    },
    "EPSLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": ""
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Execute the module."
        },
        "get_code": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_code."
        },
        "get_data": {
          "signature": "(self, path)",
          "doc": ""
        },
        "get_filename": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Return the path to the source file as found by the finder."
        },
        "get_resource_reader": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.get_source."
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": "Concrete implementation of InspectLoader.is_package by checking if"
        },
        "load_module": {
          "signature": "(self, name=None, *args, **kwargs)",
          "doc": "Load a module from a file."
        },
        "path_mtime": {
          "signature": "(self, path)",
          "doc": "Optional method that returns the modification time (an int) for the"
        },
        "path_stats": {
          "signature": "(self, path)",
          "doc": "Return the metadata for the path."
        },
        "set_data": {
          "signature": "(self, path, data, *, _mode=438)",
          "doc": "Write bytes data to a file."
        },
        "source_to_code": {
          "signature": "(self, data, path, *, _optimize=-1)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.epscript"
    },
    "EUDByteReader": {
      "methods": {
        "readbyte": {
          "signature": "(self)",
          "doc": ""
        },
        "seekepd": {
          "signature": "(self, epdoffset)",
          "doc": ""
        },
        "seekoffset": {
          "signature": "(self, offset)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDByteStream": {
      "methods": {
        "copyto": {
          "signature": "(self, bytestream)",
          "doc": ""
        },
        "flushdword": {
          "signature": "(self)",
          "doc": ""
        },
        "readbyte": {
          "signature": "(self)",
          "doc": ""
        },
        "seekepd": {
          "signature": "(self, epdoffset)",
          "doc": ""
        },
        "seekoffset": {
          "signature": "(self, offset)",
          "doc": ""
        },
        "writebyte": {
          "signature": "(self, byte)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDByteWriter": {
      "methods": {
        "flushdword": {
          "signature": "(self)",
          "doc": ""
        },
        "seekepd": {
          "signature": "(self, epdoffset)",
          "doc": ""
        },
        "seekoffset": {
          "signature": "(self, offset)",
          "doc": ""
        },
        "writebyte": {
          "signature": "(self, byte)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "CPByteWriter": {
      "methods": {
        "flushdword": {
          "signature": "(self)",
          "doc": ""
        },
        "writebyte": {
          "signature": "(self, byte)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDVArrayReader": {
      "methods": {
        "read": {
          "signature": "(self, acts=[])",
          "doc": ""
        },
        "seek": {
          "signature": "(self, varr_ptr, varr_epd, eudv, acts=[])",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "EUDArray": {
      "methods": {
        "eqitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "geitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "get": {
          "signature": "(self, key)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "gtitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "iadditem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "ianditem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "ifloordivitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "iinvert": {
          "signature": "(self, key)",
          "doc": ""
        },
        "ilshiftitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "imoditem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "imulitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "inot": {
          "signature": "(self, key)",
          "doc": ""
        },
        "ioritem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "ipowitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "irshiftitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "isubitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "isubtractitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "ixoritem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "leitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "ltitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "neitem": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "set": {
          "signature": "(self, key, item)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib.objpool"
    },
    "EUDArrayData": {
      "methods": {
        "CollectDependency": {
          "signature": "(self, pbuffer: eudplib.core.allocator.payload.ObjCollector | eudplib.core.allocator.payload.ObjAllocator | eudplib.core.allocator.pbuffer.PayloadBuffer) -> None",
          "doc": ""
        },
        "DynamicConstructed": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> eudplib.core.allocator.rlocint.RlocInt_C",
          "doc": ""
        },
        "GetArraySize": {
          "signature": "(self)",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self)",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, buf)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib.eudarray"
    },
    "EUDGrp": {
      "methods": {
        "CollectDependency": {
          "signature": "(self, pbuffer: eudplib.core.allocator.payload.ObjCollector | eudplib.core.allocator.payload.ObjAllocator | eudplib.core.allocator.pbuffer.PayloadBuffer) -> None",
          "doc": ""
        },
        "DynamicConstructed": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self)",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, buf)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "OrderType": {
      "methods": {},
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "ScoreType": {
      "methods": {},
      "doc": "",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "CallableProxyType": {
      "methods": {},
      "doc": "",
      "module": "weakref"
    },
    "KeyedRef": {
      "methods": {},
      "doc": "Specialized reference that includes a key corresponding to the value.",
      "module": "weakref"
    },
    "ProxyType": {
      "methods": {},
      "doc": "",
      "module": "weakref"
    },
    "ReferenceType": {
      "methods": {},
      "doc": "",
      "module": "weakref"
    },
    "WeakKeyDictionary": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": "D.clear() -> None.  Remove all items from D."
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "get": {
          "signature": "(self, key, default=None)",
          "doc": ""
        },
        "items": {
          "signature": "(self)",
          "doc": ""
        },
        "keyrefs": {
          "signature": "(self)",
          "doc": "Return a list of weak references to the keys."
        },
        "keys": {
          "signature": "(self)",
          "doc": ""
        },
        "pop": {
          "signature": "(self, key, *args)",
          "doc": ""
        },
        "popitem": {
          "signature": "(self)",
          "doc": ""
        },
        "setdefault": {
          "signature": "(self, key, default=None)",
          "doc": ""
        },
        "update": {
          "signature": "(self, dict=None, /, **kwargs)",
          "doc": ""
        },
        "values": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": " Mapping class that references keys weakly.",
      "module": "weakref"
    },
    "WeakMethod": {
      "methods": {},
      "doc": "",
      "module": "weakref"
    },
    "WeakValueDictionary": {
      "methods": {
        "clear": {
          "signature": "(self)",
          "doc": "D.clear() -> None.  Remove all items from D."
        },
        "copy": {
          "signature": "(self)",
          "doc": ""
        },
        "get": {
          "signature": "(self, key, default=None)",
          "doc": ""
        },
        "items": {
          "signature": "(self)",
          "doc": ""
        },
        "itervaluerefs": {
          "signature": "(self)",
          "doc": "Return an iterator that yields the weak references to the values."
        },
        "keys": {
          "signature": "(self)",
          "doc": ""
        },
        "pop": {
          "signature": "(self, key, *args)",
          "doc": ""
        },
        "popitem": {
          "signature": "(self)",
          "doc": ""
        },
        "setdefault": {
          "signature": "(self, key, default=None)",
          "doc": ""
        },
        "update": {
          "signature": "(self, other=None, /, **kwargs)",
          "doc": ""
        },
        "valuerefs": {
          "signature": "(self)",
          "doc": "Return a list of weak references to the values."
        },
        "values": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "Mapping class that references values weakly.",
      "module": "weakref"
    },
    "finalize": {
      "methods": {
        "detach": {
          "signature": "(self)",
          "doc": "If alive then mark as dead and return (obj, func, args, kwargs);"
        },
        "peek": {
          "signature": "(self)",
          "doc": "If alive then return (obj, func, args, kwargs);"
        }
      },
      "doc": "Class for finalization of weakrefable objects",
      "module": "weakref"
    },
    "ref": {
      "methods": {},
      "doc": "",
      "module": "weakref"
    },
    "Field": {
      "methods": {},
      "doc": "",
      "module": "dataclasses"
    },
    "FrozenInstanceError": {
      "methods": {},
      "doc": "",
      "module": "dataclasses"
    },
    "InitVar": {
      "methods": {},
      "doc": "",
      "module": "dataclasses"
    },
    "BaseMember": {
      "methods": {},
      "doc": "",
      "module": "eudplib.offsetmap.member"
    },
    "CSpriteMember": {
      "methods": {},
      "doc": "",
      "module": "eudplib.offsetmap.csprite"
    },
    "CUnitMember": {
      "methods": {},
      "doc": "",
      "module": "eudplib.offsetmap.member"
    },
    "EnumMember": {
      "methods": {},
      "doc": "",
      "module": "eudplib.offsetmap.csprite"
    },
    "Member": {
      "methods": {},
      "doc": "",
      "module": "eudplib.offsetmap.csprite"
    },
    "MemberKind": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "eudplib.offsetmap.csprite"
    },
    "UnsupportedMember": {
      "methods": {},
      "doc": "",
      "module": "eudplib.offsetmap.member"
    },
    "EPDOffsetMap": {
      "methods": {
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, 'c.EUDVariable | CUnit | CSprite']",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> 'c.EUDVariable | CUnit'",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.offsetmap.csprite"
    },
    "CSprite": {
      "methods": {
        "eqattr": {
          "signature": "(self, name: str, value)",
          "doc": ""
        },
        "geattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "getdwepd": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, 'c.EUDVariable | CUnit | CSprite']",
          "doc": ""
        },
        "getepd": {
          "signature": "(self, name: str) -> 'c.EUDVariable | CUnit'",
          "doc": ""
        },
        "getpos": {
          "signature": "(self, name: str) -> tuple[eudplib.core.variable.eudv.EUDVariable, eudplib.core.variable.eudv.EUDVariable]",
          "doc": ""
        },
        "gtattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iaddattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "iandattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ifloordivattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iinvertattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ilshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imodattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "imulattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "iorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ipowattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "irshiftattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "isubattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "isubtractattr": {
          "signature": "(self, name: str, value) -> None",
          "doc": ""
        },
        "ixorattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "leattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "ltattr": {
          "signature": "(self, name, value)",
          "doc": ""
        },
        "neattr": {
          "signature": "(self, name, value)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.offsetmap.csprite"
    },
    "CSpriteFlags": {
      "methods": {},
      "doc": "",
      "module": "eudplib.offsetmap.csprite"
    },
    "UserPBuffer": {
      "methods": {
        "CollectDependency": {
          "signature": "(self, pbuffer: eudplib.core.allocator.payload.ObjCollector | eudplib.core.allocator.payload.ObjAllocator | eudplib.core.allocator.pbuffer.PayloadBuffer) -> None",
          "doc": ""
        },
        "DynamicConstructed": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> eudplib.core.allocator.rlocint.RlocInt_C",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self)",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, pbuf)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib.utilf.userpl"
    },
    "UserP_FW": {
      "methods": {
        "Evaluate": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib.utilf.userpl"
    },
    "PVariable": {
      "methods": {
        "eqitem": {
          "signature": "(self, i, val) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "fill": {
          "signature": "(self, values, *, assert_expected_values_len=None) -> None",
          "doc": ""
        },
        "geitem": {
          "signature": "(self, i, val) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "get": {
          "signature": "(self, i, **kwargs)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        },
        "gtitem": {
          "signature": "(self, i, val)",
          "doc": ""
        },
        "iadditem": {
          "signature": "(self, i, val) -> None",
          "doc": ""
        },
        "ianditem": {
          "signature": "(self, i, val) -> None",
          "doc": ""
        },
        "ifloordivitem": {
          "signature": "(self, i, val) -> None",
          "doc": ""
        },
        "iinvertitem": {
          "signature": "(self, i) -> None",
          "doc": ""
        },
        "ilshiftitem": {
          "signature": "(self, i, n) -> None",
          "doc": ""
        },
        "imoditem": {
          "signature": "(self, i, val) -> None",
          "doc": ""
        },
        "imulitem": {
          "signature": "(self, i, val) -> None",
          "doc": ""
        },
        "inotitem": {
          "signature": "(self, i) -> NoReturn",
          "doc": ""
        },
        "ioritem": {
          "signature": "(self, i, val) -> None",
          "doc": ""
        },
        "ipowitem": {
          "signature": "(self, i, val) -> None",
          "doc": ""
        },
        "irshiftitem": {
          "signature": "(self, i, n) -> None",
          "doc": ""
        },
        "isubitem": {
          "signature": "(self, i, val) -> None",
          "doc": ""
        },
        "isubtractitem": {
          "signature": "(self, i, val) -> None",
          "doc": ""
        },
        "ixoritem": {
          "signature": "(self, i, val) -> None",
          "doc": ""
        },
        "leitem": {
          "signature": "(self, i, val) -> eudplib.core.rawtrigger.condition.Condition",
          "doc": ""
        },
        "ltitem": {
          "signature": "(self, i, val)",
          "doc": ""
        },
        "neitem": {
          "signature": "(self, i, val)",
          "doc": ""
        },
        "set": {
          "signature": "(self, i, val) -> None",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "CPString": {
      "methods": {
        "Display": {
          "signature": "(self, action=[])",
          "doc": ""
        },
        "GetVTable": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "DBString": {
      "methods": {
        "Display": {
          "signature": "(self)",
          "doc": ""
        },
        "GetStringMemoryAddr": {
          "signature": "(self)",
          "doc": ""
        },
        "Play": {
          "signature": "(self)",
          "doc": ""
        },
        "getValue": {
          "signature": "(self) -> +T_co",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "DBStringData": {
      "methods": {
        "CollectDependency": {
          "signature": "(self, pbuffer: eudplib.core.allocator.payload.ObjCollector | eudplib.core.allocator.payload.ObjAllocator | eudplib.core.allocator.pbuffer.PayloadBuffer) -> None",
          "doc": ""
        },
        "DynamicConstructed": {
          "signature": "(self) -> bool",
          "doc": ""
        },
        "Evaluate": {
          "signature": "(self) -> eudplib.core.allocator.rlocint.RlocInt_C",
          "doc": ""
        },
        "GetDataSize": {
          "signature": "(self)",
          "doc": ""
        },
        "WritePayload": {
          "signature": "(self, pbuf)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib.stringf.dbstr"
    },
    "epd2s": {
      "methods": {},
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "hptr": {
      "methods": {},
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "ptr2s": {
      "methods": {},
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "FixedText": {
      "methods": {},
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "DefragResult": {
      "methods": {
        "encode": {
          "signature": "(self, encoding='ascii', errors='strict')",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.parse"
    },
    "DefragResultBytes": {
      "methods": {
        "decode": {
          "signature": "(self, encoding='ascii', errors='strict')",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.parse"
    },
    "ParseResult": {
      "methods": {
        "encode": {
          "signature": "(self, encoding='ascii', errors='strict')",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.parse"
    },
    "ParseResultBytes": {
      "methods": {
        "decode": {
          "signature": "(self, encoding='ascii', errors='strict')",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.parse"
    },
    "Quoter": {
      "methods": {},
      "doc": "A mapping from bytes (in range(0,256)) to strings.",
      "module": "urllib.parse"
    },
    "ResultBase": {
      "methods": {
        "encode": {
          "signature": "(self, encoding='ascii', errors='strict')",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.parse"
    },
    "SplitResult": {
      "methods": {
        "encode": {
          "signature": "(self, encoding='ascii', errors='strict')",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.parse"
    },
    "SplitResultBytes": {
      "methods": {
        "decode": {
          "signature": "(self, encoding='ascii', errors='strict')",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.parse"
    },
    "BoundaryError": {
      "methods": {},
      "doc": "Couldn't find terminating boundary.",
      "module": "email.errors"
    },
    "CharsetError": {
      "methods": {},
      "doc": "An illegal charset was given.",
      "module": "email.errors"
    },
    "CloseBoundaryNotFoundDefect": {
      "methods": {},
      "doc": "A start boundary was found, but not the corresponding close boundary.",
      "module": "email.errors"
    },
    "FirstHeaderLineIsContinuationDefect": {
      "methods": {},
      "doc": "A message had a continuation line as its first header line.",
      "module": "email.errors"
    },
    "HeaderDefect": {
      "methods": {},
      "doc": "Base class for a header defect.",
      "module": "email.errors"
    },
    "HeaderMissingRequiredValue": {
      "methods": {},
      "doc": "A header that must have a value had none",
      "module": "email.errors"
    },
    "HeaderParseError": {
      "methods": {},
      "doc": "Error while parsing headers.",
      "module": "email.header"
    },
    "InvalidBase64CharactersDefect": {
      "methods": {},
      "doc": "base64 encoded sequence had characters not in base64 alphabet",
      "module": "email.errors"
    },
    "InvalidBase64LengthDefect": {
      "methods": {},
      "doc": "base64 encoded sequence had invalid length (1 mod 4)",
      "module": "email.errors"
    },
    "InvalidBase64PaddingDefect": {
      "methods": {},
      "doc": "base64 encoded sequence had an incorrect length",
      "module": "email.errors"
    },
    "InvalidDateDefect": {
      "methods": {},
      "doc": "Header has unparsable or invalid date",
      "module": "email.errors"
    },
    "InvalidHeaderDefect": {
      "methods": {},
      "doc": "Header is not valid, message gives details.",
      "module": "email.errors"
    },
    "InvalidMultipartContentTransferEncodingDefect": {
      "methods": {},
      "doc": "An invalid content transfer encoding was set on the multipart itself.",
      "module": "email.errors"
    },
    "MalformedHeaderDefect": {
      "methods": {},
      "doc": "Found line with no leading whitespace and no colon before blank line.",
      "module": "email.errors"
    },
    "MessageDefect": {
      "methods": {},
      "doc": "Base class for a message defect.",
      "module": "email.errors"
    },
    "MessageError": {
      "methods": {},
      "doc": "Base class for errors in the email package.",
      "module": "email.errors"
    },
    "MessageParseError": {
      "methods": {},
      "doc": "Base class for message parsing errors.",
      "module": "email.errors"
    },
    "MisplacedEnvelopeHeaderDefect": {
      "methods": {},
      "doc": "A 'Unix-from' header was found in the middle of a header block.",
      "module": "email.errors"
    },
    "MissingHeaderBodySeparatorDefect": {
      "methods": {},
      "doc": "Found line with no leading whitespace and no colon before blank line.",
      "module": "email.errors"
    },
    "MultipartConversionError": {
      "methods": {},
      "doc": "Conversion to a multipart is prohibited.",
      "module": "email.errors"
    },
    "MultipartInvariantViolationDefect": {
      "methods": {},
      "doc": "A message claimed to be a multipart but no subparts were found.",
      "module": "email.errors"
    },
    "NoBoundaryInMultipartDefect": {
      "methods": {},
      "doc": "A message claimed to be a multipart but had no boundary parameter.",
      "module": "email.errors"
    },
    "NonASCIILocalPartDefect": {
      "methods": {},
      "doc": "local_part contains non-ASCII characters",
      "module": "email.errors"
    },
    "NonPrintableDefect": {
      "methods": {},
      "doc": "ASCII characters outside the ascii-printable range found",
      "module": "email.errors"
    },
    "ObsoleteHeaderDefect": {
      "methods": {},
      "doc": "Header uses syntax declared obsolete by RFC 5322",
      "module": "email.errors"
    },
    "StartBoundaryNotFoundDefect": {
      "methods": {},
      "doc": "The claimed start boundary was never found.",
      "module": "email.errors"
    },
    "UndecodableBytesDefect": {
      "methods": {},
      "doc": "Header contained bytes that could not be decoded",
      "module": "email.errors"
    },
    "Incomplete": {
      "methods": {},
      "doc": "",
      "module": "binascii"
    },
    "Charset": {
      "methods": {
        "body_encode": {
          "signature": "(self, string)",
          "doc": "Body-encode a string by converting it first to bytes."
        },
        "get_body_encoding": {
          "signature": "(self)",
          "doc": "Return the content-transfer-encoding used for body encoding."
        },
        "get_output_charset": {
          "signature": "(self)",
          "doc": "Return the output character set."
        },
        "header_encode": {
          "signature": "(self, string)",
          "doc": "Header-encode a string by converting it first to bytes."
        },
        "header_encode_lines": {
          "signature": "(self, string, maxlengths)",
          "doc": "Header-encode a string by converting it first to bytes."
        }
      },
      "doc": "Map character sets to their email properties.",
      "module": "email.message"
    },
    "Header": {
      "methods": {
        "append": {
          "signature": "(self, s, charset=None, errors='strict')",
          "doc": "Append a string to the MIME header."
        },
        "encode": {
          "signature": "(self, splitchars=';, \\t', maxlinelen=None, linesep='\\n')",
          "doc": "Encode a message header into an RFC-compliant format."
        }
      },
      "doc": "",
      "module": "email.header"
    },
    "date": {
      "methods": {},
      "doc": "date(year, month, day) --> date object",
      "module": "datetime"
    },
    "datetime": {
      "methods": {},
      "doc": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "module": "datetime"
    },
    "time": {
      "methods": {},
      "doc": "time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) --> a time object",
      "module": "datetime"
    },
    "timedelta": {
      "methods": {},
      "doc": "Difference between two datetime values.",
      "module": "datetime"
    },
    "timezone": {
      "methods": {},
      "doc": "Fixed offset from UTC implementation of tzinfo.",
      "module": "datetime"
    },
    "tzinfo": {
      "methods": {},
      "doc": "Abstract base class for time zone info objects.",
      "module": "datetime"
    },
    "Calendar": {
      "methods": {
        "getfirstweekday": {
          "signature": "(self)",
          "doc": ""
        },
        "itermonthdates": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays2": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays3": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays4": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "iterweekdays": {
          "signature": "(self)",
          "doc": ""
        },
        "monthdatescalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdays2calendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdayscalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "setfirstweekday": {
          "signature": "(self, firstweekday)",
          "doc": ""
        },
        "yeardatescalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardays2calendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardayscalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "calendar"
    },
    "HTMLCalendar": {
      "methods": {
        "formatday": {
          "signature": "(self, day, weekday)",
          "doc": ""
        },
        "formatmonth": {
          "signature": "(self, theyear, themonth, withyear=True)",
          "doc": ""
        },
        "formatmonthname": {
          "signature": "(self, theyear, themonth, withyear=True)",
          "doc": ""
        },
        "formatweek": {
          "signature": "(self, theweek)",
          "doc": ""
        },
        "formatweekday": {
          "signature": "(self, day)",
          "doc": ""
        },
        "formatweekheader": {
          "signature": "(self)",
          "doc": ""
        },
        "formatyear": {
          "signature": "(self, theyear, width=3)",
          "doc": ""
        },
        "formatyearpage": {
          "signature": "(self, theyear, width=3, css='calendar.css', encoding=None)",
          "doc": ""
        },
        "getfirstweekday": {
          "signature": "(self)",
          "doc": ""
        },
        "itermonthdates": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays2": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays3": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays4": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "iterweekdays": {
          "signature": "(self)",
          "doc": ""
        },
        "monthdatescalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdays2calendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdayscalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "setfirstweekday": {
          "signature": "(self, firstweekday)",
          "doc": ""
        },
        "yeardatescalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardays2calendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardayscalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "calendar"
    },
    "IllegalMonthError": {
      "methods": {},
      "doc": "",
      "module": "calendar"
    },
    "IllegalWeekdayError": {
      "methods": {},
      "doc": "",
      "module": "calendar"
    },
    "LocaleHTMLCalendar": {
      "methods": {
        "formatday": {
          "signature": "(self, day, weekday)",
          "doc": ""
        },
        "formatmonth": {
          "signature": "(self, theyear, themonth, withyear=True)",
          "doc": ""
        },
        "formatmonthname": {
          "signature": "(self, theyear, themonth, withyear=True)",
          "doc": ""
        },
        "formatweek": {
          "signature": "(self, theweek)",
          "doc": ""
        },
        "formatweekday": {
          "signature": "(self, day)",
          "doc": ""
        },
        "formatweekheader": {
          "signature": "(self)",
          "doc": ""
        },
        "formatyear": {
          "signature": "(self, theyear, width=3)",
          "doc": ""
        },
        "formatyearpage": {
          "signature": "(self, theyear, width=3, css='calendar.css', encoding=None)",
          "doc": ""
        },
        "getfirstweekday": {
          "signature": "(self)",
          "doc": ""
        },
        "itermonthdates": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays2": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays3": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays4": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "iterweekdays": {
          "signature": "(self)",
          "doc": ""
        },
        "monthdatescalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdays2calendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdayscalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "setfirstweekday": {
          "signature": "(self, firstweekday)",
          "doc": ""
        },
        "yeardatescalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardays2calendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardayscalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "calendar"
    },
    "LocaleTextCalendar": {
      "methods": {
        "formatday": {
          "signature": "(self, day, weekday, width)",
          "doc": ""
        },
        "formatmonth": {
          "signature": "(self, theyear, themonth, w=0, l=0)",
          "doc": ""
        },
        "formatmonthname": {
          "signature": "(self, theyear, themonth, width, withyear=True)",
          "doc": ""
        },
        "formatweek": {
          "signature": "(self, theweek, width)",
          "doc": ""
        },
        "formatweekday": {
          "signature": "(self, day, width)",
          "doc": ""
        },
        "formatweekheader": {
          "signature": "(self, width)",
          "doc": ""
        },
        "formatyear": {
          "signature": "(self, theyear, w=2, l=1, c=6, m=3)",
          "doc": ""
        },
        "getfirstweekday": {
          "signature": "(self)",
          "doc": ""
        },
        "itermonthdates": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays2": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays3": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays4": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "iterweekdays": {
          "signature": "(self)",
          "doc": ""
        },
        "monthdatescalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdays2calendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdayscalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "prmonth": {
          "signature": "(self, theyear, themonth, w=0, l=0)",
          "doc": ""
        },
        "prweek": {
          "signature": "(self, theweek, width)",
          "doc": ""
        },
        "pryear": {
          "signature": "(self, theyear, w=0, l=0, c=6, m=3)",
          "doc": "Print a year's calendar."
        },
        "setfirstweekday": {
          "signature": "(self, firstweekday)",
          "doc": ""
        },
        "yeardatescalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardays2calendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardayscalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "calendar"
    },
    "TextCalendar": {
      "methods": {
        "formatday": {
          "signature": "(self, day, weekday, width)",
          "doc": ""
        },
        "formatmonth": {
          "signature": "(self, theyear, themonth, w=0, l=0)",
          "doc": ""
        },
        "formatmonthname": {
          "signature": "(self, theyear, themonth, width, withyear=True)",
          "doc": ""
        },
        "formatweek": {
          "signature": "(self, theweek, width)",
          "doc": ""
        },
        "formatweekday": {
          "signature": "(self, day, width)",
          "doc": ""
        },
        "formatweekheader": {
          "signature": "(self, width)",
          "doc": ""
        },
        "formatyear": {
          "signature": "(self, theyear, w=2, l=1, c=6, m=3)",
          "doc": ""
        },
        "getfirstweekday": {
          "signature": "(self)",
          "doc": ""
        },
        "itermonthdates": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays2": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays3": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "itermonthdays4": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "iterweekdays": {
          "signature": "(self)",
          "doc": ""
        },
        "monthdatescalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdays2calendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "monthdayscalendar": {
          "signature": "(self, year, month)",
          "doc": ""
        },
        "prmonth": {
          "signature": "(self, theyear, themonth, w=0, l=0)",
          "doc": ""
        },
        "prweek": {
          "signature": "(self, theweek, width)",
          "doc": ""
        },
        "pryear": {
          "signature": "(self, theyear, w=0, l=0, c=6, m=3)",
          "doc": "Print a year's calendar."
        },
        "setfirstweekday": {
          "signature": "(self, firstweekday)",
          "doc": ""
        },
        "yeardatescalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardays2calendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        },
        "yeardayscalendar": {
          "signature": "(self, year, width=3)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "calendar"
    },
    "different_locale": {
      "methods": {},
      "doc": "",
      "module": "calendar"
    },
    "AddressList": {
      "methods": {
        "getaddress": {
          "signature": "(self)",
          "doc": "Parse the next address."
        },
        "getaddrlist": {
          "signature": "(self)",
          "doc": "Parse all addresses."
        },
        "getaddrspec": {
          "signature": "(self)",
          "doc": "Parse an RFC 2822 addr-spec."
        },
        "getatom": {
          "signature": "(self, atomends=None)",
          "doc": "Parse an RFC 2822 atom."
        },
        "getcomment": {
          "signature": "(self)",
          "doc": "Get a parenthesis-delimited fragment from self's field."
        },
        "getdelimited": {
          "signature": "(self, beginchar, endchars, allowcomments=True)",
          "doc": "Parse a header fragment delimited by special characters."
        },
        "getdomain": {
          "signature": "(self)",
          "doc": "Get the complete domain name from an address."
        },
        "getdomainliteral": {
          "signature": "(self)",
          "doc": "Parse an RFC 2822 domain-literal."
        },
        "getphraselist": {
          "signature": "(self)",
          "doc": "Parse a sequence of RFC 2822 phrases."
        },
        "getquote": {
          "signature": "(self)",
          "doc": "Get a quote-delimited fragment from self's field."
        },
        "getrouteaddr": {
          "signature": "(self)",
          "doc": "Parse a route address (Return-path value)."
        },
        "gotonext": {
          "signature": "(self)",
          "doc": "Skip white space and extract comments."
        }
      },
      "doc": "An AddressList encapsulates a list of parsed RFC 2822 addresses.",
      "module": "email._parseaddr"
    },
    "AddrlistClass": {
      "methods": {
        "getaddress": {
          "signature": "(self)",
          "doc": "Parse the next address."
        },
        "getaddrlist": {
          "signature": "(self)",
          "doc": "Parse all addresses."
        },
        "getaddrspec": {
          "signature": "(self)",
          "doc": "Parse an RFC 2822 addr-spec."
        },
        "getatom": {
          "signature": "(self, atomends=None)",
          "doc": "Parse an RFC 2822 atom."
        },
        "getcomment": {
          "signature": "(self)",
          "doc": "Get a parenthesis-delimited fragment from self's field."
        },
        "getdelimited": {
          "signature": "(self, beginchar, endchars, allowcomments=True)",
          "doc": "Parse a header fragment delimited by special characters."
        },
        "getdomain": {
          "signature": "(self)",
          "doc": "Get the complete domain name from an address."
        },
        "getdomainliteral": {
          "signature": "(self)",
          "doc": "Parse an RFC 2822 domain-literal."
        },
        "getphraselist": {
          "signature": "(self)",
          "doc": "Parse a sequence of RFC 2822 phrases."
        },
        "getquote": {
          "signature": "(self)",
          "doc": "Get a quote-delimited fragment from self's field."
        },
        "getrouteaddr": {
          "signature": "(self)",
          "doc": "Parse a route address (Return-path value)."
        },
        "gotonext": {
          "signature": "(self)",
          "doc": "Skip white space and extract comments."
        }
      },
      "doc": "Address parser class by Ben Escoto.",
      "module": "email._parseaddr"
    },
    "Compat32": {
      "methods": {
        "clone": {
          "signature": "(self, **kw)",
          "doc": "Return a new instance with specified attributes changed."
        },
        "fold": {
          "signature": "(self, name, value)",
          "doc": "Given the header name and the value from the model, return a string"
        },
        "fold_binary": {
          "signature": "(self, name, value)",
          "doc": "Given the header name and the value from the model, return binary"
        },
        "handle_defect": {
          "signature": "(self, obj, defect)",
          "doc": "Based on policy, either raise defect or call register_defect."
        },
        "header_fetch_parse": {
          "signature": "(self, name, value)",
          "doc": "Given the header name and the value from the model, return the value"
        },
        "header_max_count": {
          "signature": "(self, name)",
          "doc": "Return the maximum allowed number of headers named 'name'."
        },
        "header_source_parse": {
          "signature": "(self, sourcelines)",
          "doc": "Given a list of linesep terminated strings constituting the lines of"
        },
        "header_store_parse": {
          "signature": "(self, name, value)",
          "doc": "Given the header name and the value provided by the application"
        },
        "register_defect": {
          "signature": "(self, obj, defect)",
          "doc": "Record 'defect' on 'obj'."
        }
      },
      "doc": "Controls for how messages are interpreted and formatted.",
      "module": "email._policybase"
    },
    "Policy": {
      "methods": {
        "clone": {
          "signature": "(self, **kw)",
          "doc": "Return a new instance with specified attributes changed."
        },
        "fold": {
          "signature": "(self, name, value)",
          "doc": "Given the header name and the value from the model, return a string"
        },
        "fold_binary": {
          "signature": "(self, name, value)",
          "doc": "Given the header name and the value from the model, return binary"
        },
        "handle_defect": {
          "signature": "(self, obj, defect)",
          "doc": "Based on policy, either raise defect or call register_defect."
        },
        "header_fetch_parse": {
          "signature": "(self, name, value)",
          "doc": "Given the header name and the value from the model, return the value"
        },
        "header_max_count": {
          "signature": "(self, name)",
          "doc": "Return the maximum allowed number of headers named 'name'."
        },
        "header_source_parse": {
          "signature": "(self, sourcelines)",
          "doc": "Given a list of linesep terminated strings constituting the lines of"
        },
        "header_store_parse": {
          "signature": "(self, name, value)",
          "doc": "Given the header name and the value provided by the application"
        },
        "register_defect": {
          "signature": "(self, obj, defect)",
          "doc": "Record 'defect' on 'obj'."
        }
      },
      "doc": "Controls for how messages are interpreted and formatted.",
      "module": "email.message"
    },
    "BufferedSubFile": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "pop_eof_matcher": {
          "signature": "(self)",
          "doc": ""
        },
        "push": {
          "signature": "(self, data)",
          "doc": "Push some new data into this object."
        },
        "push_eof_matcher": {
          "signature": "(self, pred)",
          "doc": ""
        },
        "pushlines": {
          "signature": "(self, lines)",
          "doc": ""
        },
        "readline": {
          "signature": "(self)",
          "doc": ""
        },
        "unreadline": {
          "signature": "(self, line)",
          "doc": ""
        }
      },
      "doc": "A file-ish object that can have new data loaded into it.",
      "module": "email.feedparser"
    },
    "BytesFeedParser": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Parse all remaining data and return the root message object."
        },
        "feed": {
          "signature": "(self, data)",
          "doc": ""
        }
      },
      "doc": "Like FeedParser, but feed accepts bytes.",
      "module": "email.parser"
    },
    "FeedParser": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Parse all remaining data and return the root message object."
        },
        "feed": {
          "signature": "(self, data)",
          "doc": "Push more data into the parser."
        }
      },
      "doc": "A feed-style parser of email.",
      "module": "cgi"
    },
    "BytesHeaderParser": {
      "methods": {
        "parse": {
          "signature": "(self, fp, headersonly=True)",
          "doc": ""
        },
        "parsebytes": {
          "signature": "(self, text, headersonly=True)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.parser"
    },
    "BytesParser": {
      "methods": {
        "parse": {
          "signature": "(self, fp, headersonly=False)",
          "doc": "Create a message structure from the data in a binary file."
        },
        "parsebytes": {
          "signature": "(self, text, headersonly=False)",
          "doc": "Create a message structure from a byte string."
        }
      },
      "doc": "",
      "module": "email.parser"
    },
    "HeaderParser": {
      "methods": {
        "parse": {
          "signature": "(self, fp, headersonly=True)",
          "doc": ""
        },
        "parsestr": {
          "signature": "(self, text, headersonly=True)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "email.parser"
    },
    "Parser": {
      "methods": {
        "parse": {
          "signature": "(self, fp, headersonly=False)",
          "doc": "Create a message structure from the data in a file."
        },
        "parsestr": {
          "signature": "(self, text, headersonly=False)",
          "doc": "Create a message structure from a string."
        }
      },
      "doc": "",
      "module": "email.parser"
    },
    "EmailMessage": {
      "methods": {
        "add_alternative": {
          "signature": "(self, *args, **kw)",
          "doc": ""
        },
        "add_attachment": {
          "signature": "(self, *args, **kw)",
          "doc": ""
        },
        "add_header": {
          "signature": "(self, _name, _value, **_params)",
          "doc": "Extended header setting."
        },
        "add_related": {
          "signature": "(self, *args, **kw)",
          "doc": ""
        },
        "as_bytes": {
          "signature": "(self, unixfrom=False, policy=None)",
          "doc": "Return the entire formatted message as a bytes object."
        },
        "as_string": {
          "signature": "(self, unixfrom=False, maxheaderlen=None, policy=None)",
          "doc": "Return the entire formatted message as a string."
        },
        "attach": {
          "signature": "(self, payload)",
          "doc": "Add the given payload to the current payload."
        },
        "clear": {
          "signature": "(self)",
          "doc": ""
        },
        "clear_content": {
          "signature": "(self)",
          "doc": ""
        },
        "del_param": {
          "signature": "(self, param, header='content-type', requote=True)",
          "doc": "Remove the given parameter completely from the Content-Type header."
        },
        "get": {
          "signature": "(self, name, failobj=None)",
          "doc": "Get a header value."
        },
        "get_all": {
          "signature": "(self, name, failobj=None)",
          "doc": "Return a list of all the values for the named field."
        },
        "get_body": {
          "signature": "(self, preferencelist=('related', 'html', 'plain'))",
          "doc": "Return best candidate mime part for display as 'body' of message."
        },
        "get_boundary": {
          "signature": "(self, failobj=None)",
          "doc": "Return the boundary associated with the payload if present."
        },
        "get_charset": {
          "signature": "(self)",
          "doc": "Return the Charset instance associated with the message's payload."
        },
        "get_charsets": {
          "signature": "(self, failobj=None)",
          "doc": "Return a list containing the charset(s) used in this message."
        },
        "get_content": {
          "signature": "(self, *args, content_manager=None, **kw)",
          "doc": ""
        },
        "get_content_charset": {
          "signature": "(self, failobj=None)",
          "doc": "Return the charset parameter of the Content-Type header."
        },
        "get_content_disposition": {
          "signature": "(self)",
          "doc": "Return the message's content-disposition if it exists, or None."
        },
        "get_content_maintype": {
          "signature": "(self)",
          "doc": "Return the message's main content type."
        },
        "get_content_subtype": {
          "signature": "(self)",
          "doc": "Returns the message's sub-content type."
        },
        "get_content_type": {
          "signature": "(self)",
          "doc": "Return the message's content type."
        },
        "get_default_type": {
          "signature": "(self)",
          "doc": "Return the `default' content type."
        },
        "get_filename": {
          "signature": "(self, failobj=None)",
          "doc": "Return the filename associated with the payload if present."
        },
        "get_param": {
          "signature": "(self, param, failobj=None, header='content-type', unquote=True)",
          "doc": "Return the parameter value if found in the Content-Type header."
        },
        "get_params": {
          "signature": "(self, failobj=None, header='content-type', unquote=True)",
          "doc": "Return the message's Content-Type parameters, as a list."
        },
        "get_payload": {
          "signature": "(self, i=None, decode=False)",
          "doc": "Return a reference to the payload."
        },
        "get_unixfrom": {
          "signature": "(self)",
          "doc": ""
        },
        "is_attachment": {
          "signature": "(self)",
          "doc": ""
        },
        "is_multipart": {
          "signature": "(self)",
          "doc": "Return True if the message consists of multiple parts."
        },
        "items": {
          "signature": "(self)",
          "doc": "Get all the message's header fields and values."
        },
        "iter_attachments": {
          "signature": "(self)",
          "doc": "Return an iterator over the non-main parts of a multipart."
        },
        "iter_parts": {
          "signature": "(self)",
          "doc": "Return an iterator over all immediate subparts of a multipart."
        },
        "keys": {
          "signature": "(self)",
          "doc": "Return a list of all the message's header field names."
        },
        "make_alternative": {
          "signature": "(self, boundary=None)",
          "doc": ""
        },
        "make_mixed": {
          "signature": "(self, boundary=None)",
          "doc": ""
        },
        "make_related": {
          "signature": "(self, boundary=None)",
          "doc": ""
        },
        "raw_items": {
          "signature": "(self)",
          "doc": "Return the (name, value) header pairs without modification."
        },
        "replace_header": {
          "signature": "(self, _name, _value)",
          "doc": "Replace a header."
        },
        "set_boundary": {
          "signature": "(self, boundary)",
          "doc": "Set the boundary parameter in Content-Type to 'boundary'."
        },
        "set_charset": {
          "signature": "(self, charset)",
          "doc": "Set the charset of the payload to a given character set."
        },
        "set_content": {
          "signature": "(self, *args, **kw)",
          "doc": ""
        },
        "set_default_type": {
          "signature": "(self, ctype)",
          "doc": "Set the `default' content type."
        },
        "set_param": {
          "signature": "(self, param, value, header='Content-Type', requote=True, charset=None, language='', replace=False)",
          "doc": "Set a parameter in the Content-Type header."
        },
        "set_payload": {
          "signature": "(self, payload, charset=None)",
          "doc": "Set the payload to the given value."
        },
        "set_raw": {
          "signature": "(self, name, value)",
          "doc": "Store name and value in the model without modification."
        },
        "set_type": {
          "signature": "(self, type, header='Content-Type', requote=True)",
          "doc": "Set the main type and subtype for the Content-Type header."
        },
        "set_unixfrom": {
          "signature": "(self, unixfrom)",
          "doc": ""
        },
        "values": {
          "signature": "(self)",
          "doc": "Return a list of all the message's header values."
        },
        "walk": {
          "signature": "(self)",
          "doc": "Walk over the message tree, yielding each subpart."
        }
      },
      "doc": "",
      "module": "email.message"
    },
    "MIMEPart": {
      "methods": {
        "add_alternative": {
          "signature": "(self, *args, **kw)",
          "doc": ""
        },
        "add_attachment": {
          "signature": "(self, *args, **kw)",
          "doc": ""
        },
        "add_header": {
          "signature": "(self, _name, _value, **_params)",
          "doc": "Extended header setting."
        },
        "add_related": {
          "signature": "(self, *args, **kw)",
          "doc": ""
        },
        "as_bytes": {
          "signature": "(self, unixfrom=False, policy=None)",
          "doc": "Return the entire formatted message as a bytes object."
        },
        "as_string": {
          "signature": "(self, unixfrom=False, maxheaderlen=None, policy=None)",
          "doc": "Return the entire formatted message as a string."
        },
        "attach": {
          "signature": "(self, payload)",
          "doc": "Add the given payload to the current payload."
        },
        "clear": {
          "signature": "(self)",
          "doc": ""
        },
        "clear_content": {
          "signature": "(self)",
          "doc": ""
        },
        "del_param": {
          "signature": "(self, param, header='content-type', requote=True)",
          "doc": "Remove the given parameter completely from the Content-Type header."
        },
        "get": {
          "signature": "(self, name, failobj=None)",
          "doc": "Get a header value."
        },
        "get_all": {
          "signature": "(self, name, failobj=None)",
          "doc": "Return a list of all the values for the named field."
        },
        "get_body": {
          "signature": "(self, preferencelist=('related', 'html', 'plain'))",
          "doc": "Return best candidate mime part for display as 'body' of message."
        },
        "get_boundary": {
          "signature": "(self, failobj=None)",
          "doc": "Return the boundary associated with the payload if present."
        },
        "get_charset": {
          "signature": "(self)",
          "doc": "Return the Charset instance associated with the message's payload."
        },
        "get_charsets": {
          "signature": "(self, failobj=None)",
          "doc": "Return a list containing the charset(s) used in this message."
        },
        "get_content": {
          "signature": "(self, *args, content_manager=None, **kw)",
          "doc": ""
        },
        "get_content_charset": {
          "signature": "(self, failobj=None)",
          "doc": "Return the charset parameter of the Content-Type header."
        },
        "get_content_disposition": {
          "signature": "(self)",
          "doc": "Return the message's content-disposition if it exists, or None."
        },
        "get_content_maintype": {
          "signature": "(self)",
          "doc": "Return the message's main content type."
        },
        "get_content_subtype": {
          "signature": "(self)",
          "doc": "Returns the message's sub-content type."
        },
        "get_content_type": {
          "signature": "(self)",
          "doc": "Return the message's content type."
        },
        "get_default_type": {
          "signature": "(self)",
          "doc": "Return the `default' content type."
        },
        "get_filename": {
          "signature": "(self, failobj=None)",
          "doc": "Return the filename associated with the payload if present."
        },
        "get_param": {
          "signature": "(self, param, failobj=None, header='content-type', unquote=True)",
          "doc": "Return the parameter value if found in the Content-Type header."
        },
        "get_params": {
          "signature": "(self, failobj=None, header='content-type', unquote=True)",
          "doc": "Return the message's Content-Type parameters, as a list."
        },
        "get_payload": {
          "signature": "(self, i=None, decode=False)",
          "doc": "Return a reference to the payload."
        },
        "get_unixfrom": {
          "signature": "(self)",
          "doc": ""
        },
        "is_attachment": {
          "signature": "(self)",
          "doc": ""
        },
        "is_multipart": {
          "signature": "(self)",
          "doc": "Return True if the message consists of multiple parts."
        },
        "items": {
          "signature": "(self)",
          "doc": "Get all the message's header fields and values."
        },
        "iter_attachments": {
          "signature": "(self)",
          "doc": "Return an iterator over the non-main parts of a multipart."
        },
        "iter_parts": {
          "signature": "(self)",
          "doc": "Return an iterator over all immediate subparts of a multipart."
        },
        "keys": {
          "signature": "(self)",
          "doc": "Return a list of all the message's header field names."
        },
        "make_alternative": {
          "signature": "(self, boundary=None)",
          "doc": ""
        },
        "make_mixed": {
          "signature": "(self, boundary=None)",
          "doc": ""
        },
        "make_related": {
          "signature": "(self, boundary=None)",
          "doc": ""
        },
        "raw_items": {
          "signature": "(self)",
          "doc": "Return the (name, value) header pairs without modification."
        },
        "replace_header": {
          "signature": "(self, _name, _value)",
          "doc": "Replace a header."
        },
        "set_boundary": {
          "signature": "(self, boundary)",
          "doc": "Set the boundary parameter in Content-Type to 'boundary'."
        },
        "set_charset": {
          "signature": "(self, charset)",
          "doc": "Set the charset of the payload to a given character set."
        },
        "set_content": {
          "signature": "(self, *args, content_manager=None, **kw)",
          "doc": ""
        },
        "set_default_type": {
          "signature": "(self, ctype)",
          "doc": "Set the `default' content type."
        },
        "set_param": {
          "signature": "(self, param, value, header='Content-Type', requote=True, charset=None, language='', replace=False)",
          "doc": "Set a parameter in the Content-Type header."
        },
        "set_payload": {
          "signature": "(self, payload, charset=None)",
          "doc": "Set the payload to the given value."
        },
        "set_raw": {
          "signature": "(self, name, value)",
          "doc": "Store name and value in the model without modification."
        },
        "set_type": {
          "signature": "(self, type, header='Content-Type', requote=True)",
          "doc": "Set the main type and subtype for the Content-Type header."
        },
        "set_unixfrom": {
          "signature": "(self, unixfrom)",
          "doc": ""
        },
        "values": {
          "signature": "(self)",
          "doc": "Return a list of all the message's header values."
        },
        "walk": {
          "signature": "(self)",
          "doc": "Walk over the message tree, yielding each subpart."
        }
      },
      "doc": "",
      "module": "email.message"
    },
    "Message": {
      "methods": {
        "add_header": {
          "signature": "(self, _name, _value, **_params)",
          "doc": "Extended header setting."
        },
        "as_bytes": {
          "signature": "(self, unixfrom=False, policy=None)",
          "doc": "Return the entire formatted message as a bytes object."
        },
        "as_string": {
          "signature": "(self, unixfrom=False, maxheaderlen=0, policy=None)",
          "doc": "Return the entire formatted message as a string."
        },
        "attach": {
          "signature": "(self, payload)",
          "doc": "Add the given payload to the current payload."
        },
        "del_param": {
          "signature": "(self, param, header='content-type', requote=True)",
          "doc": "Remove the given parameter completely from the Content-Type header."
        },
        "get": {
          "signature": "(self, name, failobj=None)",
          "doc": "Get a header value."
        },
        "get_all": {
          "signature": "(self, name, failobj=None)",
          "doc": "Return a list of all the values for the named field."
        },
        "get_boundary": {
          "signature": "(self, failobj=None)",
          "doc": "Return the boundary associated with the payload if present."
        },
        "get_charset": {
          "signature": "(self)",
          "doc": "Return the Charset instance associated with the message's payload."
        },
        "get_charsets": {
          "signature": "(self, failobj=None)",
          "doc": "Return a list containing the charset(s) used in this message."
        },
        "get_content_charset": {
          "signature": "(self, failobj=None)",
          "doc": "Return the charset parameter of the Content-Type header."
        },
        "get_content_disposition": {
          "signature": "(self)",
          "doc": "Return the message's content-disposition if it exists, or None."
        },
        "get_content_maintype": {
          "signature": "(self)",
          "doc": "Return the message's main content type."
        },
        "get_content_subtype": {
          "signature": "(self)",
          "doc": "Returns the message's sub-content type."
        },
        "get_content_type": {
          "signature": "(self)",
          "doc": "Return the message's content type."
        },
        "get_default_type": {
          "signature": "(self)",
          "doc": "Return the `default' content type."
        },
        "get_filename": {
          "signature": "(self, failobj=None)",
          "doc": "Return the filename associated with the payload if present."
        },
        "get_param": {
          "signature": "(self, param, failobj=None, header='content-type', unquote=True)",
          "doc": "Return the parameter value if found in the Content-Type header."
        },
        "get_params": {
          "signature": "(self, failobj=None, header='content-type', unquote=True)",
          "doc": "Return the message's Content-Type parameters, as a list."
        },
        "get_payload": {
          "signature": "(self, i=None, decode=False)",
          "doc": "Return a reference to the payload."
        },
        "get_unixfrom": {
          "signature": "(self)",
          "doc": ""
        },
        "is_multipart": {
          "signature": "(self)",
          "doc": "Return True if the message consists of multiple parts."
        },
        "items": {
          "signature": "(self)",
          "doc": "Get all the message's header fields and values."
        },
        "keys": {
          "signature": "(self)",
          "doc": "Return a list of all the message's header field names."
        },
        "raw_items": {
          "signature": "(self)",
          "doc": "Return the (name, value) header pairs without modification."
        },
        "replace_header": {
          "signature": "(self, _name, _value)",
          "doc": "Replace a header."
        },
        "set_boundary": {
          "signature": "(self, boundary)",
          "doc": "Set the boundary parameter in Content-Type to 'boundary'."
        },
        "set_charset": {
          "signature": "(self, charset)",
          "doc": "Set the charset of the payload to a given character set."
        },
        "set_default_type": {
          "signature": "(self, ctype)",
          "doc": "Set the `default' content type."
        },
        "set_param": {
          "signature": "(self, param, value, header='Content-Type', requote=True, charset=None, language='', replace=False)",
          "doc": "Set a parameter in the Content-Type header."
        },
        "set_payload": {
          "signature": "(self, payload, charset=None)",
          "doc": "Set the payload to the given value."
        },
        "set_raw": {
          "signature": "(self, name, value)",
          "doc": "Store name and value in the model without modification."
        },
        "set_type": {
          "signature": "(self, type, header='Content-Type', requote=True)",
          "doc": "Set the main type and subtype for the Content-Type header."
        },
        "set_unixfrom": {
          "signature": "(self, unixfrom)",
          "doc": ""
        },
        "values": {
          "signature": "(self)",
          "doc": "Return a list of all the message's header values."
        },
        "walk": {
          "signature": "(self)",
          "doc": "Walk over the message tree, yielding each subpart."
        }
      },
      "doc": "Basic message object.",
      "module": "cgi"
    },
    "BZ2Compressor": {
      "methods": {},
      "doc": "Create a compressor object for compressing data incrementally.",
      "module": "bz2"
    },
    "BZ2Decompressor": {
      "methods": {},
      "doc": "Create a decompressor object for decompressing data incrementally.",
      "module": "bz2"
    },
    "BZ2File": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Flush and close the file."
        },
        "fileno": {
          "signature": "(self)",
          "doc": "Return the file descriptor for the underlying file."
        },
        "peek": {
          "signature": "(self, n=0)",
          "doc": "Return buffered data without advancing the file position."
        },
        "read": {
          "signature": "(self, size=-1)",
          "doc": "Read up to size uncompressed bytes from the file."
        },
        "read1": {
          "signature": "(self, size=-1)",
          "doc": "Read up to size uncompressed bytes, while trying to avoid"
        },
        "readable": {
          "signature": "(self)",
          "doc": "Return whether the file was opened for reading."
        },
        "readinto": {
          "signature": "(self, b)",
          "doc": "Read bytes into b."
        },
        "readline": {
          "signature": "(self, size=-1)",
          "doc": "Read a line of uncompressed bytes from the file."
        },
        "readlines": {
          "signature": "(self, size=-1)",
          "doc": "Read a list of lines of uncompressed bytes from the file."
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": "Change the file position."
        },
        "seekable": {
          "signature": "(self)",
          "doc": "Return whether the file supports seeking."
        },
        "tell": {
          "signature": "(self)",
          "doc": "Return the current file position."
        },
        "writable": {
          "signature": "(self)",
          "doc": "Return whether the file was opened for writing."
        },
        "write": {
          "signature": "(self, data)",
          "doc": "Write a byte string to the file."
        },
        "writelines": {
          "signature": "(self, seq)",
          "doc": "Write a sequence of byte strings to the file."
        }
      },
      "doc": "A file object providing transparent bzip2 (de)compression.",
      "module": "bz2"
    },
    "LZMACompressor": {
      "methods": {
        "compress": {
          "signature": "(self, data)",
          "doc": ""
        },
        "flush": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "zipfile"
    },
    "LZMADecompressor": {
      "methods": {
        "decompress": {
          "signature": "(self, data)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "zipfile"
    },
    "LZMAError": {
      "methods": {},
      "doc": "Call to liblzma failed.",
      "module": "lzma"
    },
    "LZMAFile": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Flush and close the file."
        },
        "fileno": {
          "signature": "(self)",
          "doc": "Return the file descriptor for the underlying file."
        },
        "peek": {
          "signature": "(self, size=-1)",
          "doc": "Return buffered data without advancing the file position."
        },
        "read": {
          "signature": "(self, size=-1)",
          "doc": "Read up to size uncompressed bytes from the file."
        },
        "read1": {
          "signature": "(self, size=-1)",
          "doc": "Read up to size uncompressed bytes, while trying to avoid"
        },
        "readable": {
          "signature": "(self)",
          "doc": "Return whether the file was opened for reading."
        },
        "readline": {
          "signature": "(self, size=-1)",
          "doc": "Read a line of uncompressed bytes from the file."
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": "Change the file position."
        },
        "seekable": {
          "signature": "(self)",
          "doc": "Return whether the file supports seeking."
        },
        "tell": {
          "signature": "(self)",
          "doc": "Return the current file position."
        },
        "writable": {
          "signature": "(self)",
          "doc": "Return whether the file was opened for writing."
        },
        "write": {
          "signature": "(self, data)",
          "doc": "Write a bytes object to the file."
        }
      },
      "doc": "A file object providing transparent LZMA (de)compression.",
      "module": "lzma"
    },
    "ExecError": {
      "methods": {},
      "doc": "Raised when a command could not be executed",
      "module": "shutil"
    },
    "ReadError": {
      "methods": {},
      "doc": "Raised when an archive cannot be read",
      "module": "shutil"
    },
    "RegistryError": {
      "methods": {},
      "doc": "Raised when a registry operation with the archiving",
      "module": "shutil"
    },
    "SameFileError": {
      "methods": {},
      "doc": "Raised when source and destination are the same file.",
      "module": "shutil"
    },
    "SpecialFileError": {
      "methods": {},
      "doc": "Raised when trying to do a kind of operation (e.g. copying) which is",
      "module": "shutil"
    },
    "SpooledTemporaryFile": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "fileno": {
          "signature": "(self)",
          "doc": ""
        },
        "flush": {
          "signature": "(self)",
          "doc": ""
        },
        "isatty": {
          "signature": "(self)",
          "doc": ""
        },
        "read": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "readline": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "readlines": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "rollover": {
          "signature": "(self)",
          "doc": ""
        },
        "seek": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "tell": {
          "signature": "(self)",
          "doc": ""
        },
        "truncate": {
          "signature": "(self, size=None)",
          "doc": ""
        },
        "write": {
          "signature": "(self, s)",
          "doc": ""
        },
        "writelines": {
          "signature": "(self, iterable)",
          "doc": ""
        }
      },
      "doc": "Temporary file wrapper, specialized to switch from BytesIO",
      "module": "tempfile"
    },
    "TemporaryDirectory": {
      "methods": {
        "cleanup": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "Create and return a temporary directory.  This has the same",
      "module": "tempfile"
    },
    "FieldStorage": {
      "methods": {
        "getfirst": {
          "signature": "(self, key, default=None)",
          "doc": ""
        },
        "getlist": {
          "signature": "(self, key)",
          "doc": ""
        },
        "getvalue": {
          "signature": "(self, key, default=None)",
          "doc": ""
        },
        "keys": {
          "signature": "(self)",
          "doc": ""
        },
        "make_file": {
          "signature": "(self)",
          "doc": ""
        },
        "read_binary": {
          "signature": "(self)",
          "doc": ""
        },
        "read_lines": {
          "signature": "(self)",
          "doc": ""
        },
        "read_lines_to_eof": {
          "signature": "(self)",
          "doc": ""
        },
        "read_lines_to_outerboundary": {
          "signature": "(self)",
          "doc": ""
        },
        "read_multi": {
          "signature": "(self, environ, keep_blank_values, strict_parsing)",
          "doc": ""
        },
        "read_single": {
          "signature": "(self)",
          "doc": ""
        },
        "read_urlencoded": {
          "signature": "(self)",
          "doc": ""
        },
        "skip_lines": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "cgi"
    },
    "MiniFieldStorage": {
      "methods": {},
      "doc": "",
      "module": "cgi"
    },
    "tStartEnd": {
      "methods": {},
      "doc": "Built-in immutable sequence.",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "CreateInfo": {
      "methods": {},
      "doc": "",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "DLL": {
      "methods": {},
      "doc": "This class represents a dll exporting functions using the",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "MPQ": {
      "methods": {
        "Close": {
          "signature": "(self) -> None",
          "doc": ""
        },
        "Compact": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "Create": {
          "signature": "(self, fname: str, *, sectorSize: int = 3, fileCount: int = 1024) -> bool",
          "doc": ""
        },
        "EnumFiles": {
          "signature": "(self) -> list[str]",
          "doc": ""
        },
        "Extract": {
          "signature": "(self, fname: str) -> bytes | None",
          "doc": ""
        },
        "GetMaxFileCount": {
          "signature": "(self) -> int",
          "doc": ""
        },
        "Open": {
          "signature": "(self, fname: str) -> bool",
          "doc": ""
        },
        "PutFile": {
          "signature": "(self, fname: str, buffer: bytes, *, cmp1: int = 2, cmp2: int = 2)",
          "doc": ""
        },
        "PutWave": {
          "signature": "(self, fname: str, buffer: bytes, *, cmp1: int = 2, cmp2: int = 2) -> int | None",
          "doc": ""
        },
        "SetMaxFileCount": {
          "signature": "(self, count: int) -> int",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.maprw.mpqadd"
    },
    "StringBuffer": {
      "methods": {
        "Display": {
          "signature": "(self)",
          "doc": ""
        },
        "DisplayAt": {
          "signature": "(self, line, _f={})",
          "doc": ""
        },
        "Play": {
          "signature": "(self)",
          "doc": ""
        },
        "append": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "appendf": {
          "signature": "(self, format_string, *args)",
          "doc": ""
        },
        "delete": {
          "signature": "(self, start, length=1)",
          "doc": ""
        },
        "fadeIn": {
          "signature": "(self, *args, color=None, wait=1, reset=True, line=-1, tag=None)",
          "doc": ""
        },
        "fadeInf": {
          "signature": "(self, format_string, *args, color=None, wait=1, reset=True, line=-1, tag=None)",
          "doc": ""
        },
        "fadeOut": {
          "signature": "(self, *args, color=None, wait=1, reset=True, line=-1, tag=None)",
          "doc": ""
        },
        "fadeOutf": {
          "signature": "(self, format_string, *args, color=None, wait=1, reset=True, line=-1, tag=None)",
          "doc": ""
        },
        "insert": {
          "signature": "(self, index, *args)",
          "doc": ""
        },
        "insertf": {
          "signature": "(self, index, format_string, *args)",
          "doc": ""
        },
        "length": {
          "signature": "(self)",
          "doc": ""
        },
        "print": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "printAt": {
          "signature": "(self, line, *args)",
          "doc": ""
        },
        "printf": {
          "signature": "(self, format_string, *args)",
          "doc": ""
        },
        "printfAt": {
          "signature": "(self, line, format_string, *args)",
          "doc": ""
        },
        "tagprint": {
          "signature": "(self, format_string, *args, line=-1, tag=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "UnitGroup": {
      "methods": {
        "add": {
          "signature": "(self, unit_epd)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "InitialWireframe": {
      "methods": {},
      "doc": "",
      "module": "eudplib.eudlib"
    },
    "Loader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": "Return a module to initialize and into which to load."
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": "Return the loaded module."
        },
        "module_repr": {
          "signature": "(self, module)",
          "doc": "Return a module's repr."
        }
      },
      "doc": "Abstract base class for import loaders.",
      "module": "importlib.util"
    },
    "LazyLoader": {
      "methods": {
        "create_module": {
          "signature": "(self, spec)",
          "doc": ""
        },
        "exec_module": {
          "signature": "(self, module)",
          "doc": "Make the module load lazily."
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": "Return the loaded module."
        },
        "module_repr": {
          "signature": "(self, module)",
          "doc": "Return a module's repr."
        }
      },
      "doc": "A loader that creates a module which defers loading until attribute access.",
      "module": "importlib.util"
    },
    "Path": {
      "methods": {
        "absolute": {
          "signature": "(self)",
          "doc": "Return an absolute version of this path.  This function works"
        },
        "as_posix": {
          "signature": "(self)",
          "doc": "Return the string representation of the path with forward (/)"
        },
        "as_uri": {
          "signature": "(self)",
          "doc": "Return the path as a 'file' URI."
        },
        "chmod": {
          "signature": "(self, mode, *, follow_symlinks=True)",
          "doc": ""
        },
        "exists": {
          "signature": "(self)",
          "doc": ""
        },
        "expanduser": {
          "signature": "(self)",
          "doc": " Return a new path with expanded ~ and ~user constructs"
        },
        "glob": {
          "signature": "(self, pattern)",
          "doc": "Iterate over this subtree and yield all existing files (of any"
        },
        "group": {
          "signature": "(self)",
          "doc": ""
        },
        "hardlink_to": {
          "signature": "(self, target)",
          "doc": ""
        },
        "is_absolute": {
          "signature": "(self)",
          "doc": "True if the path is absolute (has both a root and, if applicable,"
        },
        "is_block_device": {
          "signature": "(self)",
          "doc": ""
        },
        "is_char_device": {
          "signature": "(self)",
          "doc": ""
        },
        "is_dir": {
          "signature": "(self)",
          "doc": ""
        },
        "is_fifo": {
          "signature": "(self)",
          "doc": ""
        },
        "is_file": {
          "signature": "(self)",
          "doc": ""
        },
        "is_mount": {
          "signature": "(self)",
          "doc": ""
        },
        "is_relative_to": {
          "signature": "(self, *other)",
          "doc": "Return True if the path is relative to another path or False."
        },
        "is_reserved": {
          "signature": "(self)",
          "doc": "Return True if the path contains one of the special names reserved"
        },
        "is_socket": {
          "signature": "(self)",
          "doc": ""
        },
        "is_symlink": {
          "signature": "(self)",
          "doc": ""
        },
        "iterdir": {
          "signature": "(self)",
          "doc": "Iterate over the files in this directory.  Does not yield any"
        },
        "joinpath": {
          "signature": "(self, *args)",
          "doc": "Combine this path with one or several arguments, and return a"
        },
        "lchmod": {
          "signature": "(self, mode)",
          "doc": ""
        },
        "link_to": {
          "signature": "(self, target)",
          "doc": ""
        },
        "lstat": {
          "signature": "(self)",
          "doc": ""
        },
        "match": {
          "signature": "(self, path_pattern)",
          "doc": ""
        },
        "mkdir": {
          "signature": "(self, mode=511, parents=False, exist_ok=False)",
          "doc": ""
        },
        "open": {
          "signature": "(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)",
          "doc": ""
        },
        "owner": {
          "signature": "(self)",
          "doc": ""
        },
        "read_bytes": {
          "signature": "(self)",
          "doc": ""
        },
        "read_text": {
          "signature": "(self, encoding=None, errors=None)",
          "doc": ""
        },
        "readlink": {
          "signature": "(self)",
          "doc": ""
        },
        "relative_to": {
          "signature": "(self, *other)",
          "doc": "Return the relative path to another path identified by the passed"
        },
        "rename": {
          "signature": "(self, target)",
          "doc": ""
        },
        "replace": {
          "signature": "(self, target)",
          "doc": ""
        },
        "resolve": {
          "signature": "(self, strict=False)",
          "doc": ""
        },
        "rglob": {
          "signature": "(self, pattern)",
          "doc": "Recursively yield all existing files (of any kind, including"
        },
        "rmdir": {
          "signature": "(self)",
          "doc": ""
        },
        "samefile": {
          "signature": "(self, other_path)",
          "doc": "Return whether other_path is the same or not as this file"
        },
        "stat": {
          "signature": "(self, *, follow_symlinks=True)",
          "doc": ""
        },
        "symlink_to": {
          "signature": "(self, target, target_is_directory=False)",
          "doc": ""
        },
        "touch": {
          "signature": "(self, mode=438, exist_ok=True)",
          "doc": ""
        },
        "unlink": {
          "signature": "(self, missing_ok=False)",
          "doc": ""
        },
        "with_name": {
          "signature": "(self, name)",
          "doc": "Return a new path with the file name changed."
        },
        "with_stem": {
          "signature": "(self, stem)",
          "doc": "Return a new path with the stem changed."
        },
        "with_suffix": {
          "signature": "(self, suffix)",
          "doc": "Return a new path with the file suffix changed.  If the path"
        },
        "write_bytes": {
          "signature": "(self, data)",
          "doc": ""
        },
        "write_text": {
          "signature": "(self, data, encoding=None, errors=None, newline=None)",
          "doc": ""
        }
      },
      "doc": "PurePath subclass that can make system calls.",
      "module": "main"
    },
    "PosixPath": {
      "methods": {
        "absolute": {
          "signature": "(self)",
          "doc": "Return an absolute version of this path.  This function works"
        },
        "as_posix": {
          "signature": "(self)",
          "doc": "Return the string representation of the path with forward (/)"
        },
        "as_uri": {
          "signature": "(self)",
          "doc": "Return the path as a 'file' URI."
        },
        "chmod": {
          "signature": "(self, mode, *, follow_symlinks=True)",
          "doc": ""
        },
        "exists": {
          "signature": "(self)",
          "doc": ""
        },
        "expanduser": {
          "signature": "(self)",
          "doc": " Return a new path with expanded ~ and ~user constructs"
        },
        "glob": {
          "signature": "(self, pattern)",
          "doc": "Iterate over this subtree and yield all existing files (of any"
        },
        "group": {
          "signature": "(self)",
          "doc": ""
        },
        "hardlink_to": {
          "signature": "(self, target)",
          "doc": ""
        },
        "is_absolute": {
          "signature": "(self)",
          "doc": "True if the path is absolute (has both a root and, if applicable,"
        },
        "is_block_device": {
          "signature": "(self)",
          "doc": ""
        },
        "is_char_device": {
          "signature": "(self)",
          "doc": ""
        },
        "is_dir": {
          "signature": "(self)",
          "doc": ""
        },
        "is_fifo": {
          "signature": "(self)",
          "doc": ""
        },
        "is_file": {
          "signature": "(self)",
          "doc": ""
        },
        "is_mount": {
          "signature": "(self)",
          "doc": ""
        },
        "is_relative_to": {
          "signature": "(self, *other)",
          "doc": "Return True if the path is relative to another path or False."
        },
        "is_reserved": {
          "signature": "(self)",
          "doc": "Return True if the path contains one of the special names reserved"
        },
        "is_socket": {
          "signature": "(self)",
          "doc": ""
        },
        "is_symlink": {
          "signature": "(self)",
          "doc": ""
        },
        "iterdir": {
          "signature": "(self)",
          "doc": "Iterate over the files in this directory.  Does not yield any"
        },
        "joinpath": {
          "signature": "(self, *args)",
          "doc": "Combine this path with one or several arguments, and return a"
        },
        "lchmod": {
          "signature": "(self, mode)",
          "doc": ""
        },
        "link_to": {
          "signature": "(self, target)",
          "doc": ""
        },
        "lstat": {
          "signature": "(self)",
          "doc": ""
        },
        "match": {
          "signature": "(self, path_pattern)",
          "doc": ""
        },
        "mkdir": {
          "signature": "(self, mode=511, parents=False, exist_ok=False)",
          "doc": ""
        },
        "open": {
          "signature": "(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)",
          "doc": ""
        },
        "owner": {
          "signature": "(self)",
          "doc": ""
        },
        "read_bytes": {
          "signature": "(self)",
          "doc": ""
        },
        "read_text": {
          "signature": "(self, encoding=None, errors=None)",
          "doc": ""
        },
        "readlink": {
          "signature": "(self)",
          "doc": ""
        },
        "relative_to": {
          "signature": "(self, *other)",
          "doc": "Return the relative path to another path identified by the passed"
        },
        "rename": {
          "signature": "(self, target)",
          "doc": ""
        },
        "replace": {
          "signature": "(self, target)",
          "doc": ""
        },
        "resolve": {
          "signature": "(self, strict=False)",
          "doc": ""
        },
        "rglob": {
          "signature": "(self, pattern)",
          "doc": "Recursively yield all existing files (of any kind, including"
        },
        "rmdir": {
          "signature": "(self)",
          "doc": ""
        },
        "samefile": {
          "signature": "(self, other_path)",
          "doc": "Return whether other_path is the same or not as this file"
        },
        "stat": {
          "signature": "(self, *, follow_symlinks=True)",
          "doc": ""
        },
        "symlink_to": {
          "signature": "(self, target, target_is_directory=False)",
          "doc": ""
        },
        "touch": {
          "signature": "(self, mode=438, exist_ok=True)",
          "doc": ""
        },
        "unlink": {
          "signature": "(self, missing_ok=False)",
          "doc": ""
        },
        "with_name": {
          "signature": "(self, name)",
          "doc": "Return a new path with the file name changed."
        },
        "with_stem": {
          "signature": "(self, stem)",
          "doc": "Return a new path with the stem changed."
        },
        "with_suffix": {
          "signature": "(self, suffix)",
          "doc": "Return a new path with the file suffix changed.  If the path"
        },
        "write_bytes": {
          "signature": "(self, data)",
          "doc": ""
        },
        "write_text": {
          "signature": "(self, data, encoding=None, errors=None, newline=None)",
          "doc": ""
        }
      },
      "doc": "Path subclass for non-Windows systems.",
      "module": "pathlib"
    },
    "PurePath": {
      "methods": {
        "as_posix": {
          "signature": "(self)",
          "doc": "Return the string representation of the path with forward (/)"
        },
        "as_uri": {
          "signature": "(self)",
          "doc": "Return the path as a 'file' URI."
        },
        "is_absolute": {
          "signature": "(self)",
          "doc": "True if the path is absolute (has both a root and, if applicable,"
        },
        "is_relative_to": {
          "signature": "(self, *other)",
          "doc": "Return True if the path is relative to another path or False."
        },
        "is_reserved": {
          "signature": "(self)",
          "doc": "Return True if the path contains one of the special names reserved"
        },
        "joinpath": {
          "signature": "(self, *args)",
          "doc": "Combine this path with one or several arguments, and return a"
        },
        "match": {
          "signature": "(self, path_pattern)",
          "doc": ""
        },
        "relative_to": {
          "signature": "(self, *other)",
          "doc": "Return the relative path to another path identified by the passed"
        },
        "with_name": {
          "signature": "(self, name)",
          "doc": "Return a new path with the file name changed."
        },
        "with_stem": {
          "signature": "(self, stem)",
          "doc": "Return a new path with the stem changed."
        },
        "with_suffix": {
          "signature": "(self, suffix)",
          "doc": "Return a new path with the file suffix changed.  If the path"
        }
      },
      "doc": "Base class for manipulating paths without I/O.",
      "module": "pathlib"
    },
    "PurePosixPath": {
      "methods": {
        "as_posix": {
          "signature": "(self)",
          "doc": "Return the string representation of the path with forward (/)"
        },
        "as_uri": {
          "signature": "(self)",
          "doc": "Return the path as a 'file' URI."
        },
        "is_absolute": {
          "signature": "(self)",
          "doc": "True if the path is absolute (has both a root and, if applicable,"
        },
        "is_relative_to": {
          "signature": "(self, *other)",
          "doc": "Return True if the path is relative to another path or False."
        },
        "is_reserved": {
          "signature": "(self)",
          "doc": "Return True if the path contains one of the special names reserved"
        },
        "joinpath": {
          "signature": "(self, *args)",
          "doc": "Combine this path with one or several arguments, and return a"
        },
        "match": {
          "signature": "(self, path_pattern)",
          "doc": ""
        },
        "relative_to": {
          "signature": "(self, *other)",
          "doc": "Return the relative path to another path identified by the passed"
        },
        "with_name": {
          "signature": "(self, name)",
          "doc": "Return a new path with the file name changed."
        },
        "with_stem": {
          "signature": "(self, stem)",
          "doc": "Return a new path with the stem changed."
        },
        "with_suffix": {
          "signature": "(self, suffix)",
          "doc": "Return a new path with the file suffix changed.  If the path"
        }
      },
      "doc": "PurePath subclass for non-Windows systems.",
      "module": "pathlib"
    },
    "PureWindowsPath": {
      "methods": {
        "as_posix": {
          "signature": "(self)",
          "doc": "Return the string representation of the path with forward (/)"
        },
        "as_uri": {
          "signature": "(self)",
          "doc": "Return the path as a 'file' URI."
        },
        "is_absolute": {
          "signature": "(self)",
          "doc": "True if the path is absolute (has both a root and, if applicable,"
        },
        "is_relative_to": {
          "signature": "(self, *other)",
          "doc": "Return True if the path is relative to another path or False."
        },
        "is_reserved": {
          "signature": "(self)",
          "doc": "Return True if the path contains one of the special names reserved"
        },
        "joinpath": {
          "signature": "(self, *args)",
          "doc": "Combine this path with one or several arguments, and return a"
        },
        "match": {
          "signature": "(self, path_pattern)",
          "doc": ""
        },
        "relative_to": {
          "signature": "(self, *other)",
          "doc": "Return the relative path to another path identified by the passed"
        },
        "with_name": {
          "signature": "(self, name)",
          "doc": "Return a new path with the file name changed."
        },
        "with_stem": {
          "signature": "(self, stem)",
          "doc": "Return a new path with the stem changed."
        },
        "with_suffix": {
          "signature": "(self, suffix)",
          "doc": "Return a new path with the file suffix changed.  If the path"
        }
      },
      "doc": "PurePath subclass for Windows systems.",
      "module": "pathlib"
    },
    "WindowsPath": {
      "methods": {
        "absolute": {
          "signature": "(self)",
          "doc": "Return an absolute version of this path.  This function works"
        },
        "as_posix": {
          "signature": "(self)",
          "doc": "Return the string representation of the path with forward (/)"
        },
        "as_uri": {
          "signature": "(self)",
          "doc": "Return the path as a 'file' URI."
        },
        "chmod": {
          "signature": "(self, mode, *, follow_symlinks=True)",
          "doc": ""
        },
        "exists": {
          "signature": "(self)",
          "doc": ""
        },
        "expanduser": {
          "signature": "(self)",
          "doc": " Return a new path with expanded ~ and ~user constructs"
        },
        "glob": {
          "signature": "(self, pattern)",
          "doc": "Iterate over this subtree and yield all existing files (of any"
        },
        "group": {
          "signature": "(self)",
          "doc": ""
        },
        "hardlink_to": {
          "signature": "(self, target)",
          "doc": ""
        },
        "is_absolute": {
          "signature": "(self)",
          "doc": "True if the path is absolute (has both a root and, if applicable,"
        },
        "is_block_device": {
          "signature": "(self)",
          "doc": ""
        },
        "is_char_device": {
          "signature": "(self)",
          "doc": ""
        },
        "is_dir": {
          "signature": "(self)",
          "doc": ""
        },
        "is_fifo": {
          "signature": "(self)",
          "doc": ""
        },
        "is_file": {
          "signature": "(self)",
          "doc": ""
        },
        "is_mount": {
          "signature": "(self)",
          "doc": ""
        },
        "is_relative_to": {
          "signature": "(self, *other)",
          "doc": "Return True if the path is relative to another path or False."
        },
        "is_reserved": {
          "signature": "(self)",
          "doc": "Return True if the path contains one of the special names reserved"
        },
        "is_socket": {
          "signature": "(self)",
          "doc": ""
        },
        "is_symlink": {
          "signature": "(self)",
          "doc": ""
        },
        "iterdir": {
          "signature": "(self)",
          "doc": "Iterate over the files in this directory.  Does not yield any"
        },
        "joinpath": {
          "signature": "(self, *args)",
          "doc": "Combine this path with one or several arguments, and return a"
        },
        "lchmod": {
          "signature": "(self, mode)",
          "doc": ""
        },
        "link_to": {
          "signature": "(self, target)",
          "doc": ""
        },
        "lstat": {
          "signature": "(self)",
          "doc": ""
        },
        "match": {
          "signature": "(self, path_pattern)",
          "doc": ""
        },
        "mkdir": {
          "signature": "(self, mode=511, parents=False, exist_ok=False)",
          "doc": ""
        },
        "open": {
          "signature": "(self, mode='r', buffering=-1, encoding=None, errors=None, newline=None)",
          "doc": ""
        },
        "owner": {
          "signature": "(self)",
          "doc": ""
        },
        "read_bytes": {
          "signature": "(self)",
          "doc": ""
        },
        "read_text": {
          "signature": "(self, encoding=None, errors=None)",
          "doc": ""
        },
        "readlink": {
          "signature": "(self)",
          "doc": ""
        },
        "relative_to": {
          "signature": "(self, *other)",
          "doc": "Return the relative path to another path identified by the passed"
        },
        "rename": {
          "signature": "(self, target)",
          "doc": ""
        },
        "replace": {
          "signature": "(self, target)",
          "doc": ""
        },
        "resolve": {
          "signature": "(self, strict=False)",
          "doc": ""
        },
        "rglob": {
          "signature": "(self, pattern)",
          "doc": "Recursively yield all existing files (of any kind, including"
        },
        "rmdir": {
          "signature": "(self)",
          "doc": ""
        },
        "samefile": {
          "signature": "(self, other_path)",
          "doc": "Return whether other_path is the same or not as this file"
        },
        "stat": {
          "signature": "(self, *, follow_symlinks=True)",
          "doc": ""
        },
        "symlink_to": {
          "signature": "(self, target, target_is_directory=False)",
          "doc": ""
        },
        "touch": {
          "signature": "(self, mode=438, exist_ok=True)",
          "doc": ""
        },
        "unlink": {
          "signature": "(self, missing_ok=False)",
          "doc": ""
        },
        "with_name": {
          "signature": "(self, name)",
          "doc": "Return a new path with the file name changed."
        },
        "with_stem": {
          "signature": "(self, stem)",
          "doc": "Return a new path with the stem changed."
        },
        "with_suffix": {
          "signature": "(self, suffix)",
          "doc": "Return a new path with the file suffix changed.  If the path"
        },
        "write_bytes": {
          "signature": "(self, data)",
          "doc": ""
        },
        "write_text": {
          "signature": "(self, data, encoding=None, errors=None, newline=None)",
          "doc": ""
        }
      },
      "doc": "Path subclass for Windows systems.",
      "module": "pathlib"
    },
    "BadZipFile": {
      "methods": {},
      "doc": "",
      "module": "zipfile"
    },
    "BadZipfile": {
      "methods": {},
      "doc": "",
      "module": "zipfile"
    },
    "CompleteDirs": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Close the file, and for mode 'w', 'x' and 'a' write the ending"
        },
        "extract": {
          "signature": "(self, member, path=None, pwd=None)",
          "doc": "Extract a member from the archive to the current working directory,"
        },
        "extractall": {
          "signature": "(self, path=None, members=None, pwd=None)",
          "doc": "Extract all members from the archive to the current working"
        },
        "getinfo": {
          "signature": "(self, name)",
          "doc": "Return the instance of ZipInfo given 'name'."
        },
        "infolist": {
          "signature": "(self)",
          "doc": "Return a list of class ZipInfo instances for files in the"
        },
        "namelist": {
          "signature": "(self)",
          "doc": ""
        },
        "open": {
          "signature": "(self, name, mode='r', pwd=None, *, force_zip64=False)",
          "doc": "Return file-like object for 'name'."
        },
        "printdir": {
          "signature": "(self, file=None)",
          "doc": "Print a table of contents for the zip file."
        },
        "read": {
          "signature": "(self, name, pwd=None)",
          "doc": "Return file bytes for name."
        },
        "resolve_dir": {
          "signature": "(self, name)",
          "doc": ""
        },
        "setpassword": {
          "signature": "(self, pwd)",
          "doc": "Set default password for encrypted files."
        },
        "testzip": {
          "signature": "(self)",
          "doc": "Read all the files and check the CRC."
        },
        "write": {
          "signature": "(self, filename, arcname=None, compress_type=None, compresslevel=None)",
          "doc": "Put the bytes from filename into the archive under the name"
        },
        "writestr": {
          "signature": "(self, zinfo_or_arcname, data, compress_type=None, compresslevel=None)",
          "doc": "Write a file into the archive.  The contents is 'data', which"
        }
      },
      "doc": "",
      "module": "zipfile"
    },
    "FastLookup": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Close the file, and for mode 'w', 'x' and 'a' write the ending"
        },
        "extract": {
          "signature": "(self, member, path=None, pwd=None)",
          "doc": "Extract a member from the archive to the current working directory,"
        },
        "extractall": {
          "signature": "(self, path=None, members=None, pwd=None)",
          "doc": "Extract all members from the archive to the current working"
        },
        "getinfo": {
          "signature": "(self, name)",
          "doc": "Return the instance of ZipInfo given 'name'."
        },
        "infolist": {
          "signature": "(self)",
          "doc": "Return a list of class ZipInfo instances for files in the"
        },
        "namelist": {
          "signature": "(self)",
          "doc": ""
        },
        "open": {
          "signature": "(self, name, mode='r', pwd=None, *, force_zip64=False)",
          "doc": "Return file-like object for 'name'."
        },
        "printdir": {
          "signature": "(self, file=None)",
          "doc": "Print a table of contents for the zip file."
        },
        "read": {
          "signature": "(self, name, pwd=None)",
          "doc": "Return file bytes for name."
        },
        "resolve_dir": {
          "signature": "(self, name)",
          "doc": ""
        },
        "setpassword": {
          "signature": "(self, pwd)",
          "doc": "Set default password for encrypted files."
        },
        "testzip": {
          "signature": "(self)",
          "doc": "Read all the files and check the CRC."
        },
        "write": {
          "signature": "(self, filename, arcname=None, compress_type=None, compresslevel=None)",
          "doc": "Put the bytes from filename into the archive under the name"
        },
        "writestr": {
          "signature": "(self, zinfo_or_arcname, data, compress_type=None, compresslevel=None)",
          "doc": "Write a file into the archive.  The contents is 'data', which"
        }
      },
      "doc": "",
      "module": "zipfile"
    },
    "LargeZipFile": {
      "methods": {},
      "doc": "",
      "module": "zipfile"
    },
    "PyZipFile": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Close the file, and for mode 'w', 'x' and 'a' write the ending"
        },
        "extract": {
          "signature": "(self, member, path=None, pwd=None)",
          "doc": "Extract a member from the archive to the current working directory,"
        },
        "extractall": {
          "signature": "(self, path=None, members=None, pwd=None)",
          "doc": "Extract all members from the archive to the current working"
        },
        "getinfo": {
          "signature": "(self, name)",
          "doc": "Return the instance of ZipInfo given 'name'."
        },
        "infolist": {
          "signature": "(self)",
          "doc": "Return a list of class ZipInfo instances for files in the"
        },
        "namelist": {
          "signature": "(self)",
          "doc": "Return a list of file names in the archive."
        },
        "open": {
          "signature": "(self, name, mode='r', pwd=None, *, force_zip64=False)",
          "doc": "Return file-like object for 'name'."
        },
        "printdir": {
          "signature": "(self, file=None)",
          "doc": "Print a table of contents for the zip file."
        },
        "read": {
          "signature": "(self, name, pwd=None)",
          "doc": "Return file bytes for name."
        },
        "setpassword": {
          "signature": "(self, pwd)",
          "doc": "Set default password for encrypted files."
        },
        "testzip": {
          "signature": "(self)",
          "doc": "Read all the files and check the CRC."
        },
        "write": {
          "signature": "(self, filename, arcname=None, compress_type=None, compresslevel=None)",
          "doc": "Put the bytes from filename into the archive under the name"
        },
        "writepy": {
          "signature": "(self, pathname, basename='', filterfunc=None)",
          "doc": "Add all files from \"pathname\" to the ZIP archive."
        },
        "writestr": {
          "signature": "(self, zinfo_or_arcname, data, compress_type=None, compresslevel=None)",
          "doc": "Write a file into the archive.  The contents is 'data', which"
        }
      },
      "doc": "Class to create ZIP archives with Python library files and packages.",
      "module": "zipfile"
    },
    "ZipExtFile": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "peek": {
          "signature": "(self, n=1)",
          "doc": "Returns buffered bytes without advancing the position."
        },
        "read": {
          "signature": "(self, n=-1)",
          "doc": "Read and return up to n bytes."
        },
        "read1": {
          "signature": "(self, n)",
          "doc": "Read up to n bytes with at most one read() system call."
        },
        "readable": {
          "signature": "(self)",
          "doc": ""
        },
        "readline": {
          "signature": "(self, limit=-1)",
          "doc": "Read and return a line from the stream."
        },
        "seek": {
          "signature": "(self, offset, whence=0)",
          "doc": ""
        },
        "seekable": {
          "signature": "(self)",
          "doc": ""
        },
        "tell": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "File-like object for reading an archive member.",
      "module": "zipfile"
    },
    "ZipFile": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Close the file, and for mode 'w', 'x' and 'a' write the ending"
        },
        "extract": {
          "signature": "(self, member, path=None, pwd=None)",
          "doc": "Extract a member from the archive to the current working directory,"
        },
        "extractall": {
          "signature": "(self, path=None, members=None, pwd=None)",
          "doc": "Extract all members from the archive to the current working"
        },
        "getinfo": {
          "signature": "(self, name)",
          "doc": "Return the instance of ZipInfo given 'name'."
        },
        "infolist": {
          "signature": "(self)",
          "doc": "Return a list of class ZipInfo instances for files in the"
        },
        "namelist": {
          "signature": "(self)",
          "doc": "Return a list of file names in the archive."
        },
        "open": {
          "signature": "(self, name, mode='r', pwd=None, *, force_zip64=False)",
          "doc": "Return file-like object for 'name'."
        },
        "printdir": {
          "signature": "(self, file=None)",
          "doc": "Print a table of contents for the zip file."
        },
        "read": {
          "signature": "(self, name, pwd=None)",
          "doc": "Return file bytes for name."
        },
        "setpassword": {
          "signature": "(self, pwd)",
          "doc": "Set default password for encrypted files."
        },
        "testzip": {
          "signature": "(self)",
          "doc": "Read all the files and check the CRC."
        },
        "write": {
          "signature": "(self, filename, arcname=None, compress_type=None, compresslevel=None)",
          "doc": "Put the bytes from filename into the archive under the name"
        },
        "writestr": {
          "signature": "(self, zinfo_or_arcname, data, compress_type=None, compresslevel=None)",
          "doc": "Write a file into the archive.  The contents is 'data', which"
        }
      },
      "doc": " Class with methods to open, read, write, close, list zip files.",
      "module": "zipfile"
    },
    "ZipInfo": {
      "methods": {
        "FileHeader": {
          "signature": "(self, zip64=None)",
          "doc": "Return the per-file header as a bytes object."
        },
        "is_dir": {
          "signature": "(self)",
          "doc": "Return True if this archive member is a directory."
        }
      },
      "doc": "Class with attributes describing each file in the ZIP archive.",
      "module": "zipfile"
    },
    "addbase": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.response"
    },
    "addclosehook": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "addinfo": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "info": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.response"
    },
    "addinfourl": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "getcode": {
          "signature": "(self)",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        },
        "info": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "ContentTooShortError": {
      "methods": {},
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPError": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "getcode": {
          "signature": "(self)",
          "doc": ""
        },
        "geturl": {
          "signature": "(self)",
          "doc": ""
        },
        "info": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "URLError": {
      "methods": {},
      "doc": "",
      "module": "autoupdate"
    },
    "blake2b": {
      "methods": {},
      "doc": "Return a new BLAKE2b hash object.",
      "module": "hashlib"
    },
    "blake2s": {
      "methods": {},
      "doc": "Return a new BLAKE2s hash object.",
      "module": "hashlib"
    },
    "HTTPStatus": {
      "methods": {},
      "doc": "HTTP status codes and reason phrases",
      "module": "http"
    },
    "AlertDescription": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "ssl"
    },
    "CertificateError": {
      "methods": {},
      "doc": "A certificate could not be verified.",
      "module": "ssl"
    },
    "DefaultVerifyPaths": {
      "methods": {},
      "doc": "DefaultVerifyPaths(cafile, capath, openssl_cafile_env, openssl_cafile, openssl_capath_env, openssl_capath)",
      "module": "ssl"
    },
    "MemoryBIO": {
      "methods": {},
      "doc": "",
      "module": "ssl"
    },
    "Options": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "ssl"
    },
    "Purpose": {
      "methods": {},
      "doc": "SSLContext purpose flags with X509v3 Extended Key Usage objects",
      "module": "ssl"
    },
    "SSLCertVerificationError": {
      "methods": {},
      "doc": "A certificate could not be verified.",
      "module": "ssl"
    },
    "SSLContext": {
      "methods": {
        "load_default_certs": {
          "signature": "(self, purpose=<Purpose.SERVER_AUTH: _ASN1Object(nid=129, shortname='serverAuth', longname='TLS Web Server Authentication', oid='1.3.6.1.5.5.7.3.1')>)",
          "doc": ""
        },
        "set_alpn_protocols": {
          "signature": "(self, alpn_protocols)",
          "doc": ""
        },
        "set_npn_protocols": {
          "signature": "(self, npn_protocols)",
          "doc": ""
        },
        "set_servername_callback": {
          "signature": "(self, server_name_callback)",
          "doc": ""
        },
        "wrap_bio": {
          "signature": "(self, incoming, outgoing, server_side=False, server_hostname=None, session=None)",
          "doc": ""
        },
        "wrap_socket": {
          "signature": "(self, sock, server_side=False, do_handshake_on_connect=True, suppress_ragged_eofs=True, server_hostname=None, session=None)",
          "doc": ""
        }
      },
      "doc": "An SSLContext holds various SSL-related configuration options and",
      "module": "ssl"
    },
    "SSLEOFError": {
      "methods": {},
      "doc": "SSL/TLS connection terminated abruptly.",
      "module": "ssl"
    },
    "SSLError": {
      "methods": {},
      "doc": "An error occurred in the SSL implementation.",
      "module": "ssl"
    },
    "SSLErrorNumber": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "ssl"
    },
    "SSLObject": {
      "methods": {
        "cipher": {
          "signature": "(self)",
          "doc": "Return the currently selected cipher as a 3-tuple ``(name,"
        },
        "compression": {
          "signature": "(self)",
          "doc": "Return the current compression algorithm in use, or ``None`` if"
        },
        "do_handshake": {
          "signature": "(self)",
          "doc": "Start the SSL/TLS handshake."
        },
        "get_channel_binding": {
          "signature": "(self, cb_type='tls-unique')",
          "doc": "Get channel binding data for current connection.  Raise ValueError"
        },
        "getpeercert": {
          "signature": "(self, binary_form=False)",
          "doc": "Returns a formatted version of the data in the certificate provided"
        },
        "pending": {
          "signature": "(self)",
          "doc": "Return the number of bytes that can be read immediately."
        },
        "read": {
          "signature": "(self, len=1024, buffer=None)",
          "doc": "Read up to 'len' bytes from the SSL object and return them."
        },
        "selected_alpn_protocol": {
          "signature": "(self)",
          "doc": "Return the currently selected ALPN protocol as a string, or ``None``"
        },
        "selected_npn_protocol": {
          "signature": "(self)",
          "doc": "Return the currently selected NPN protocol as a string, or ``None``"
        },
        "shared_ciphers": {
          "signature": "(self)",
          "doc": "Return a list of ciphers shared by the client during the handshake or"
        },
        "unwrap": {
          "signature": "(self)",
          "doc": "Start the SSL shutdown handshake."
        },
        "verify_client_post_handshake": {
          "signature": "(self)",
          "doc": ""
        },
        "version": {
          "signature": "(self)",
          "doc": "Return a string identifying the protocol version used by the"
        },
        "write": {
          "signature": "(self, data)",
          "doc": "Write 'data' to the SSL object and return the number of bytes"
        }
      },
      "doc": "This class implements an interface on top of a low-level SSL object as",
      "module": "ssl"
    },
    "SSLSession": {
      "methods": {},
      "doc": "",
      "module": "ssl"
    },
    "SSLSocket": {
      "methods": {
        "accept": {
          "signature": "(self)",
          "doc": "Accepts a new connection from a remote client, and returns"
        },
        "cipher": {
          "signature": "(self)",
          "doc": "Return the currently selected cipher as a 3-tuple ``(name,"
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "compression": {
          "signature": "(self)",
          "doc": "Return the current compression algorithm in use, or ``None`` if"
        },
        "connect": {
          "signature": "(self, addr)",
          "doc": "Connects to remote ADDR, and then wraps the connection in"
        },
        "connect_ex": {
          "signature": "(self, addr)",
          "doc": "Connects to remote ADDR, and then wraps the connection in"
        },
        "detach": {
          "signature": "(self)",
          "doc": "detach() -> file descriptor"
        },
        "do_handshake": {
          "signature": "(self, block=False)",
          "doc": "Start the SSL/TLS handshake."
        },
        "dup": {
          "signature": "(self)",
          "doc": ""
        },
        "get_channel_binding": {
          "signature": "(self, cb_type='tls-unique')",
          "doc": "Get channel binding data for current connection.  Raise ValueError"
        },
        "get_inheritable": {
          "signature": "(self)",
          "doc": "Get the inheritable flag of the socket"
        },
        "getpeercert": {
          "signature": "(self, binary_form=False)",
          "doc": "Returns a formatted version of the data in the certificate provided"
        },
        "makefile": {
          "signature": "(self, mode='r', buffering=None, *, encoding=None, errors=None, newline=None)",
          "doc": "makefile(...) -> an I/O stream connected to the socket"
        },
        "pending": {
          "signature": "(self)",
          "doc": "Return the number of bytes that can be read immediately."
        },
        "read": {
          "signature": "(self, len=1024, buffer=None)",
          "doc": "Read up to LEN bytes and return them."
        },
        "recv": {
          "signature": "(self, buflen=1024, flags=0)",
          "doc": ""
        },
        "recv_into": {
          "signature": "(self, buffer, nbytes=None, flags=0)",
          "doc": ""
        },
        "recvfrom": {
          "signature": "(self, buflen=1024, flags=0)",
          "doc": ""
        },
        "recvfrom_into": {
          "signature": "(self, buffer, nbytes=None, flags=0)",
          "doc": ""
        },
        "recvmsg": {
          "signature": "(self, *args, **kwargs)",
          "doc": ""
        },
        "recvmsg_into": {
          "signature": "(self, *args, **kwargs)",
          "doc": ""
        },
        "selected_alpn_protocol": {
          "signature": "(self)",
          "doc": "Return the currently selected ALPN protocol as a string, or ``None``"
        },
        "selected_npn_protocol": {
          "signature": "(self)",
          "doc": "Return the currently selected NPN protocol as a string, or ``None``"
        },
        "send": {
          "signature": "(self, data, flags=0)",
          "doc": ""
        },
        "sendall": {
          "signature": "(self, data, flags=0)",
          "doc": ""
        },
        "sendfile": {
          "signature": "(self, file, offset=0, count=None)",
          "doc": "Send a file, possibly by using os.sendfile() if this is a"
        },
        "sendmsg": {
          "signature": "(self, *args, **kwargs)",
          "doc": ""
        },
        "sendto": {
          "signature": "(self, data, flags_or_addr, addr=None)",
          "doc": ""
        },
        "set_inheritable": {
          "signature": "(self, inheritable)",
          "doc": "Set the inheritable flag of the socket"
        },
        "shared_ciphers": {
          "signature": "(self)",
          "doc": "Return a list of ciphers shared by the client during the handshake or"
        },
        "shutdown": {
          "signature": "(self, how)",
          "doc": ""
        },
        "unwrap": {
          "signature": "(self)",
          "doc": "Start the SSL shutdown handshake."
        },
        "verify_client_post_handshake": {
          "signature": "(self)",
          "doc": ""
        },
        "version": {
          "signature": "(self)",
          "doc": "Return a string identifying the protocol version used by the"
        },
        "write": {
          "signature": "(self, data)",
          "doc": "Write DATA to the underlying SSL channel.  Returns"
        }
      },
      "doc": "This class implements a subtype of socket.socket that wraps",
      "module": "ssl"
    },
    "SSLSyscallError": {
      "methods": {},
      "doc": "System error when attempting SSL operation.",
      "module": "ssl"
    },
    "SSLWantReadError": {
      "methods": {},
      "doc": "Non-blocking SSL socket needs to read more data",
      "module": "ssl"
    },
    "SSLWantWriteError": {
      "methods": {},
      "doc": "Non-blocking SSL socket needs to write more data",
      "module": "ssl"
    },
    "SSLZeroReturnError": {
      "methods": {},
      "doc": "SSL/TLS session closed cleanly.",
      "module": "ssl"
    },
    "TLSVersion": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "ssl"
    },
    "VerifyFlags": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "ssl"
    },
    "VerifyMode": {
      "methods": {},
      "doc": "An enumeration.",
      "module": "ssl"
    },
    "socket_error": {
      "methods": {},
      "doc": "Base class for I/O related errors.",
      "module": "ssl"
    },
    "BadStatusLine": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "CannotSendHeader": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "CannotSendRequest": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "HTTPConnection": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Close the connection to the HTTP server."
        },
        "connect": {
          "signature": "(self)",
          "doc": "Connect to the host and port specified in __init__."
        },
        "endheaders": {
          "signature": "(self, message_body=None, *, encode_chunked=False)",
          "doc": "Indicate that the last header line has been sent to the server."
        },
        "getresponse": {
          "signature": "(self)",
          "doc": "Get the response from the server."
        },
        "putheader": {
          "signature": "(self, header, *values)",
          "doc": "Send a request header line to the server."
        },
        "putrequest": {
          "signature": "(self, method, url, skip_host=False, skip_accept_encoding=False)",
          "doc": "Send a request to the server."
        },
        "request": {
          "signature": "(self, method, url, body=None, headers={}, *, encode_chunked=False)",
          "doc": "Send a complete request to the server."
        },
        "send": {
          "signature": "(self, data)",
          "doc": "Send `data' to the server."
        },
        "set_debuglevel": {
          "signature": "(self, level)",
          "doc": ""
        },
        "set_tunnel": {
          "signature": "(self, host, port=None, headers=None)",
          "doc": "Set up host and port for HTTP CONNECT tunnelling."
        }
      },
      "doc": "",
      "module": "http.client"
    },
    "HTTPException": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "HTTPMessage": {
      "methods": {
        "add_header": {
          "signature": "(self, _name, _value, **_params)",
          "doc": "Extended header setting."
        },
        "as_bytes": {
          "signature": "(self, unixfrom=False, policy=None)",
          "doc": "Return the entire formatted message as a bytes object."
        },
        "as_string": {
          "signature": "(self, unixfrom=False, maxheaderlen=0, policy=None)",
          "doc": "Return the entire formatted message as a string."
        },
        "attach": {
          "signature": "(self, payload)",
          "doc": "Add the given payload to the current payload."
        },
        "del_param": {
          "signature": "(self, param, header='content-type', requote=True)",
          "doc": "Remove the given parameter completely from the Content-Type header."
        },
        "get": {
          "signature": "(self, name, failobj=None)",
          "doc": "Get a header value."
        },
        "get_all": {
          "signature": "(self, name, failobj=None)",
          "doc": "Return a list of all the values for the named field."
        },
        "get_boundary": {
          "signature": "(self, failobj=None)",
          "doc": "Return the boundary associated with the payload if present."
        },
        "get_charset": {
          "signature": "(self)",
          "doc": "Return the Charset instance associated with the message's payload."
        },
        "get_charsets": {
          "signature": "(self, failobj=None)",
          "doc": "Return a list containing the charset(s) used in this message."
        },
        "get_content_charset": {
          "signature": "(self, failobj=None)",
          "doc": "Return the charset parameter of the Content-Type header."
        },
        "get_content_disposition": {
          "signature": "(self)",
          "doc": "Return the message's content-disposition if it exists, or None."
        },
        "get_content_maintype": {
          "signature": "(self)",
          "doc": "Return the message's main content type."
        },
        "get_content_subtype": {
          "signature": "(self)",
          "doc": "Returns the message's sub-content type."
        },
        "get_content_type": {
          "signature": "(self)",
          "doc": "Return the message's content type."
        },
        "get_default_type": {
          "signature": "(self)",
          "doc": "Return the `default' content type."
        },
        "get_filename": {
          "signature": "(self, failobj=None)",
          "doc": "Return the filename associated with the payload if present."
        },
        "get_param": {
          "signature": "(self, param, failobj=None, header='content-type', unquote=True)",
          "doc": "Return the parameter value if found in the Content-Type header."
        },
        "get_params": {
          "signature": "(self, failobj=None, header='content-type', unquote=True)",
          "doc": "Return the message's Content-Type parameters, as a list."
        },
        "get_payload": {
          "signature": "(self, i=None, decode=False)",
          "doc": "Return a reference to the payload."
        },
        "get_unixfrom": {
          "signature": "(self)",
          "doc": ""
        },
        "getallmatchingheaders": {
          "signature": "(self, name)",
          "doc": "Find all header lines matching a given header name."
        },
        "is_multipart": {
          "signature": "(self)",
          "doc": "Return True if the message consists of multiple parts."
        },
        "items": {
          "signature": "(self)",
          "doc": "Get all the message's header fields and values."
        },
        "keys": {
          "signature": "(self)",
          "doc": "Return a list of all the message's header field names."
        },
        "raw_items": {
          "signature": "(self)",
          "doc": "Return the (name, value) header pairs without modification."
        },
        "replace_header": {
          "signature": "(self, _name, _value)",
          "doc": "Replace a header."
        },
        "set_boundary": {
          "signature": "(self, boundary)",
          "doc": "Set the boundary parameter in Content-Type to 'boundary'."
        },
        "set_charset": {
          "signature": "(self, charset)",
          "doc": "Set the charset of the payload to a given character set."
        },
        "set_default_type": {
          "signature": "(self, ctype)",
          "doc": "Set the `default' content type."
        },
        "set_param": {
          "signature": "(self, param, value, header='Content-Type', requote=True, charset=None, language='', replace=False)",
          "doc": "Set a parameter in the Content-Type header."
        },
        "set_payload": {
          "signature": "(self, payload, charset=None)",
          "doc": "Set the payload to the given value."
        },
        "set_raw": {
          "signature": "(self, name, value)",
          "doc": "Store name and value in the model without modification."
        },
        "set_type": {
          "signature": "(self, type, header='Content-Type', requote=True)",
          "doc": "Set the main type and subtype for the Content-Type header."
        },
        "set_unixfrom": {
          "signature": "(self, unixfrom)",
          "doc": ""
        },
        "values": {
          "signature": "(self)",
          "doc": "Return a list of all the message's header values."
        },
        "walk": {
          "signature": "(self)",
          "doc": "Walk over the message tree, yielding each subpart."
        }
      },
      "doc": "",
      "module": "http.client"
    },
    "HTTPResponse": {
      "methods": {
        "begin": {
          "signature": "(self)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "fileno": {
          "signature": "(self)",
          "doc": ""
        },
        "flush": {
          "signature": "(self)",
          "doc": ""
        },
        "getcode": {
          "signature": "(self)",
          "doc": "Return the HTTP status code that was sent with the response,"
        },
        "getheader": {
          "signature": "(self, name, default=None)",
          "doc": "Returns the value of the header matching *name*."
        },
        "getheaders": {
          "signature": "(self)",
          "doc": "Return list of (header, value) tuples."
        },
        "geturl": {
          "signature": "(self)",
          "doc": "Return the real URL of the page."
        },
        "info": {
          "signature": "(self)",
          "doc": "Returns an instance of the class mimetools.Message containing"
        },
        "isclosed": {
          "signature": "(self)",
          "doc": "True if the connection is closed."
        },
        "peek": {
          "signature": "(self, n=-1)",
          "doc": ""
        },
        "read": {
          "signature": "(self, amt=None)",
          "doc": ""
        },
        "read1": {
          "signature": "(self, n=-1)",
          "doc": "Read with at most one underlying system call.  If at least one"
        },
        "readable": {
          "signature": "(self)",
          "doc": "Always returns True"
        },
        "readinto": {
          "signature": "(self, b)",
          "doc": "Read up to len(b) bytes into bytearray b and return the number"
        },
        "readline": {
          "signature": "(self, limit=-1)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "http.client"
    },
    "HTTPSConnection": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": "Close the connection to the HTTP server."
        },
        "connect": {
          "signature": "(self)",
          "doc": "Connect to a host on a given (SSL) port."
        },
        "endheaders": {
          "signature": "(self, message_body=None, *, encode_chunked=False)",
          "doc": "Indicate that the last header line has been sent to the server."
        },
        "getresponse": {
          "signature": "(self)",
          "doc": "Get the response from the server."
        },
        "putheader": {
          "signature": "(self, header, *values)",
          "doc": "Send a request header line to the server."
        },
        "putrequest": {
          "signature": "(self, method, url, skip_host=False, skip_accept_encoding=False)",
          "doc": "Send a request to the server."
        },
        "request": {
          "signature": "(self, method, url, body=None, headers={}, *, encode_chunked=False)",
          "doc": "Send a complete request to the server."
        },
        "send": {
          "signature": "(self, data)",
          "doc": "Send `data' to the server."
        },
        "set_debuglevel": {
          "signature": "(self, level)",
          "doc": ""
        },
        "set_tunnel": {
          "signature": "(self, host, port=None, headers=None)",
          "doc": "Set up host and port for HTTP CONNECT tunnelling."
        }
      },
      "doc": "This class allows communication via SSL.",
      "module": "http.client"
    },
    "ImproperConnectionState": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "IncompleteRead": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "InvalidURL": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "LineTooLong": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "NotConnected": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "RemoteDisconnected": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "ResponseNotReady": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "UnimplementedFileMode": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "UnknownProtocol": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "UnknownTransferEncoding": {
      "methods": {},
      "doc": "",
      "module": "http.client"
    },
    "AbstractBasicAuthHandler": {
      "methods": {
        "http_error_auth_reqed": {
          "signature": "(self, authreq, host, req, headers)",
          "doc": ""
        },
        "http_request": {
          "signature": "(self, req)",
          "doc": ""
        },
        "http_response": {
          "signature": "(self, req, response)",
          "doc": ""
        },
        "https_request": {
          "signature": "(self, req)",
          "doc": ""
        },
        "https_response": {
          "signature": "(self, req, response)",
          "doc": ""
        },
        "retry_http_basic_auth": {
          "signature": "(self, host, req, realm)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "AbstractDigestAuthHandler": {
      "methods": {
        "get_algorithm_impls": {
          "signature": "(self, algorithm)",
          "doc": ""
        },
        "get_authorization": {
          "signature": "(self, req, chal)",
          "doc": ""
        },
        "get_cnonce": {
          "signature": "(self, nonce)",
          "doc": ""
        },
        "get_entity_digest": {
          "signature": "(self, data, chal)",
          "doc": ""
        },
        "http_error_auth_reqed": {
          "signature": "(self, auth_header, host, req, headers)",
          "doc": ""
        },
        "reset_retry_count": {
          "signature": "(self)",
          "doc": ""
        },
        "retry_http_digest_auth": {
          "signature": "(self, req, auth)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "AbstractHTTPHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "do_open": {
          "signature": "(self, http_class, req, **http_conn_args)",
          "doc": ""
        },
        "do_request_": {
          "signature": "(self, request)",
          "doc": ""
        },
        "set_http_debuglevel": {
          "signature": "(self, level)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "BaseHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "CacheFTPHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "check_cache": {
          "signature": "(self)",
          "doc": ""
        },
        "clear_cache": {
          "signature": "(self)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "connect_ftp": {
          "signature": "(self, user, passwd, host, port, dirs, timeout)",
          "doc": ""
        },
        "ftp_open": {
          "signature": "(self, req)",
          "doc": ""
        },
        "setMaxConns": {
          "signature": "(self, m)",
          "doc": ""
        },
        "setTimeout": {
          "signature": "(self, t)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "DataHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "data_open": {
          "signature": "(self, req)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "FTPHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "connect_ftp": {
          "signature": "(self, user, passwd, host, port, dirs, timeout)",
          "doc": ""
        },
        "ftp_open": {
          "signature": "(self, req)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "FancyURLopener": {
      "methods": {
        "addheader": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "cleanup": {
          "signature": "(self)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "get_user_passwd": {
          "signature": "(self, host, realm, clear_cache=0)",
          "doc": ""
        },
        "http_error": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None)",
          "doc": ""
        },
        "http_error_301": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None)",
          "doc": ""
        },
        "http_error_302": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None)",
          "doc": ""
        },
        "http_error_303": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None)",
          "doc": ""
        },
        "http_error_307": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None)",
          "doc": ""
        },
        "http_error_401": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None, retry=False)",
          "doc": ""
        },
        "http_error_407": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None, retry=False)",
          "doc": ""
        },
        "http_error_default": {
          "signature": "(self, url, fp, errcode, errmsg, headers)",
          "doc": ""
        },
        "open": {
          "signature": "(self, fullurl, data=None)",
          "doc": ""
        },
        "open_data": {
          "signature": "(self, url, data=None)",
          "doc": ""
        },
        "open_file": {
          "signature": "(self, url)",
          "doc": ""
        },
        "open_ftp": {
          "signature": "(self, url)",
          "doc": ""
        },
        "open_http": {
          "signature": "(self, url, data=None)",
          "doc": ""
        },
        "open_https": {
          "signature": "(self, url, data=None)",
          "doc": ""
        },
        "open_local_file": {
          "signature": "(self, url)",
          "doc": ""
        },
        "open_unknown": {
          "signature": "(self, fullurl, data=None)",
          "doc": ""
        },
        "open_unknown_proxy": {
          "signature": "(self, proxy, fullurl, data=None)",
          "doc": ""
        },
        "prompt_user_passwd": {
          "signature": "(self, host, realm)",
          "doc": ""
        },
        "redirect_internal": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data)",
          "doc": ""
        },
        "retrieve": {
          "signature": "(self, url, filename=None, reporthook=None, data=None)",
          "doc": ""
        },
        "retry_http_basic_auth": {
          "signature": "(self, url, realm, data=None)",
          "doc": ""
        },
        "retry_https_basic_auth": {
          "signature": "(self, url, realm, data=None)",
          "doc": ""
        },
        "retry_proxy_http_basic_auth": {
          "signature": "(self, url, realm, data=None)",
          "doc": ""
        },
        "retry_proxy_https_basic_auth": {
          "signature": "(self, url, realm, data=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "FileHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "file_open": {
          "signature": "(self, req)",
          "doc": ""
        },
        "get_names": {
          "signature": "(self)",
          "doc": ""
        },
        "open_local_file": {
          "signature": "(self, req)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPBasicAuthHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "http_error_401": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_auth_reqed": {
          "signature": "(self, authreq, host, req, headers)",
          "doc": ""
        },
        "http_request": {
          "signature": "(self, req)",
          "doc": ""
        },
        "http_response": {
          "signature": "(self, req, response)",
          "doc": ""
        },
        "https_request": {
          "signature": "(self, req)",
          "doc": ""
        },
        "https_response": {
          "signature": "(self, req, response)",
          "doc": ""
        },
        "retry_http_basic_auth": {
          "signature": "(self, host, req, realm)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPCookieProcessor": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "http_request": {
          "signature": "(self, request)",
          "doc": ""
        },
        "http_response": {
          "signature": "(self, request, response)",
          "doc": ""
        },
        "https_request": {
          "signature": "(self, request)",
          "doc": ""
        },
        "https_response": {
          "signature": "(self, request, response)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPDefaultErrorHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "http_error_default": {
          "signature": "(self, req, fp, code, msg, hdrs)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPDigestAuthHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "get_algorithm_impls": {
          "signature": "(self, algorithm)",
          "doc": ""
        },
        "get_authorization": {
          "signature": "(self, req, chal)",
          "doc": ""
        },
        "get_cnonce": {
          "signature": "(self, nonce)",
          "doc": ""
        },
        "get_entity_digest": {
          "signature": "(self, data, chal)",
          "doc": ""
        },
        "http_error_401": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_auth_reqed": {
          "signature": "(self, auth_header, host, req, headers)",
          "doc": ""
        },
        "reset_retry_count": {
          "signature": "(self)",
          "doc": ""
        },
        "retry_http_digest_auth": {
          "signature": "(self, req, auth)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPErrorProcessor": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "http_response": {
          "signature": "(self, request, response)",
          "doc": ""
        },
        "https_response": {
          "signature": "(self, request, response)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "do_open": {
          "signature": "(self, http_class, req, **http_conn_args)",
          "doc": ""
        },
        "do_request_": {
          "signature": "(self, request)",
          "doc": ""
        },
        "http_open": {
          "signature": "(self, req)",
          "doc": ""
        },
        "http_request": {
          "signature": "(self, request)",
          "doc": ""
        },
        "set_http_debuglevel": {
          "signature": "(self, level)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPPasswordMgr": {
      "methods": {
        "add_password": {
          "signature": "(self, realm, uri, user, passwd)",
          "doc": ""
        },
        "find_user_password": {
          "signature": "(self, realm, authuri)",
          "doc": ""
        },
        "is_suburi": {
          "signature": "(self, base, test)",
          "doc": ""
        },
        "reduce_uri": {
          "signature": "(self, uri, default_port=True)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPPasswordMgrWithDefaultRealm": {
      "methods": {
        "add_password": {
          "signature": "(self, realm, uri, user, passwd)",
          "doc": ""
        },
        "find_user_password": {
          "signature": "(self, realm, authuri)",
          "doc": ""
        },
        "is_suburi": {
          "signature": "(self, base, test)",
          "doc": ""
        },
        "reduce_uri": {
          "signature": "(self, uri, default_port=True)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPPasswordMgrWithPriorAuth": {
      "methods": {
        "add_password": {
          "signature": "(self, realm, uri, user, passwd, is_authenticated=False)",
          "doc": ""
        },
        "find_user_password": {
          "signature": "(self, realm, authuri)",
          "doc": ""
        },
        "is_authenticated": {
          "signature": "(self, authuri)",
          "doc": ""
        },
        "is_suburi": {
          "signature": "(self, base, test)",
          "doc": ""
        },
        "reduce_uri": {
          "signature": "(self, uri, default_port=True)",
          "doc": ""
        },
        "update_authenticated": {
          "signature": "(self, uri, is_authenticated=False)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPRedirectHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "http_error_301": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_302": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_303": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_307": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "redirect_request": {
          "signature": "(self, req, fp, code, msg, headers, newurl)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "HTTPSHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "do_open": {
          "signature": "(self, http_class, req, **http_conn_args)",
          "doc": ""
        },
        "do_request_": {
          "signature": "(self, request)",
          "doc": ""
        },
        "https_open": {
          "signature": "(self, req)",
          "doc": ""
        },
        "https_request": {
          "signature": "(self, request)",
          "doc": ""
        },
        "set_http_debuglevel": {
          "signature": "(self, level)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "OpenerDirector": {
      "methods": {
        "add_handler": {
          "signature": "(self, handler)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "error": {
          "signature": "(self, proto, *args)",
          "doc": ""
        },
        "open": {
          "signature": "(self, fullurl, data=None, timeout=<object object at 0x0000014FB25B8650>)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "ProxyBasicAuthHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "http_error_407": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_auth_reqed": {
          "signature": "(self, authreq, host, req, headers)",
          "doc": ""
        },
        "http_request": {
          "signature": "(self, req)",
          "doc": ""
        },
        "http_response": {
          "signature": "(self, req, response)",
          "doc": ""
        },
        "https_request": {
          "signature": "(self, req)",
          "doc": ""
        },
        "https_response": {
          "signature": "(self, req, response)",
          "doc": ""
        },
        "retry_http_basic_auth": {
          "signature": "(self, host, req, realm)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "ProxyDigestAuthHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "get_algorithm_impls": {
          "signature": "(self, algorithm)",
          "doc": ""
        },
        "get_authorization": {
          "signature": "(self, req, chal)",
          "doc": ""
        },
        "get_cnonce": {
          "signature": "(self, nonce)",
          "doc": ""
        },
        "get_entity_digest": {
          "signature": "(self, data, chal)",
          "doc": ""
        },
        "http_error_407": {
          "signature": "(self, req, fp, code, msg, headers)",
          "doc": ""
        },
        "http_error_auth_reqed": {
          "signature": "(self, auth_header, host, req, headers)",
          "doc": ""
        },
        "reset_retry_count": {
          "signature": "(self)",
          "doc": ""
        },
        "retry_http_digest_auth": {
          "signature": "(self, req, auth)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "ProxyHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "proxy_open": {
          "signature": "(self, req, proxy, type)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "Request": {
      "methods": {
        "add_header": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "add_unredirected_header": {
          "signature": "(self, key, val)",
          "doc": ""
        },
        "get_full_url": {
          "signature": "(self)",
          "doc": ""
        },
        "get_header": {
          "signature": "(self, header_name, default=None)",
          "doc": ""
        },
        "get_method": {
          "signature": "(self)",
          "doc": ""
        },
        "has_header": {
          "signature": "(self, header_name)",
          "doc": ""
        },
        "has_proxy": {
          "signature": "(self)",
          "doc": ""
        },
        "header_items": {
          "signature": "(self)",
          "doc": ""
        },
        "remove_header": {
          "signature": "(self, header_name)",
          "doc": ""
        },
        "set_proxy": {
          "signature": "(self, host, type)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "URLopener": {
      "methods": {
        "addheader": {
          "signature": "(self, *args)",
          "doc": ""
        },
        "cleanup": {
          "signature": "(self)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "http_error": {
          "signature": "(self, url, fp, errcode, errmsg, headers, data=None)",
          "doc": ""
        },
        "http_error_default": {
          "signature": "(self, url, fp, errcode, errmsg, headers)",
          "doc": ""
        },
        "open": {
          "signature": "(self, fullurl, data=None)",
          "doc": ""
        },
        "open_data": {
          "signature": "(self, url, data=None)",
          "doc": ""
        },
        "open_file": {
          "signature": "(self, url)",
          "doc": ""
        },
        "open_ftp": {
          "signature": "(self, url)",
          "doc": ""
        },
        "open_http": {
          "signature": "(self, url, data=None)",
          "doc": ""
        },
        "open_https": {
          "signature": "(self, url, data=None)",
          "doc": ""
        },
        "open_local_file": {
          "signature": "(self, url)",
          "doc": ""
        },
        "open_unknown": {
          "signature": "(self, fullurl, data=None)",
          "doc": ""
        },
        "open_unknown_proxy": {
          "signature": "(self, proxy, fullurl, data=None)",
          "doc": ""
        },
        "retrieve": {
          "signature": "(self, url, filename=None, reporthook=None, data=None)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "UnknownHandler": {
      "methods": {
        "add_parent": {
          "signature": "(self, parent)",
          "doc": ""
        },
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "unknown_open": {
          "signature": "(self, req)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "ftpwrapper": {
      "methods": {
        "close": {
          "signature": "(self)",
          "doc": ""
        },
        "endtransfer": {
          "signature": "(self)",
          "doc": ""
        },
        "file_close": {
          "signature": "(self)",
          "doc": ""
        },
        "init": {
          "signature": "(self)",
          "doc": ""
        },
        "real_close": {
          "signature": "(self)",
          "doc": ""
        },
        "retrfile": {
          "signature": "(self, file, type)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "urllib.request"
    },
    "ATOM": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "BOOL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "BOOLEAN": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "BYTE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "CHAR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "COLORREF": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "DOUBLE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "DWORD": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "FILETIME": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "FLOAT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HACCEL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HANDLE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HBITMAP": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HBRUSH": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HCOLORSPACE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HDC": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HDESK": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HDWP": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HENHMETAFILE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HFONT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HGDIOBJ": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HGLOBAL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HHOOK": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HICON": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HINSTANCE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HKEY": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HKL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HLOCAL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HMENU": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HMETAFILE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HMODULE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HMONITOR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HPALETTE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HPEN": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HRGN": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HRSRC": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HSTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HTASK": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HWINSTA": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "HWND": {
      "methods": {},
      "doc": "",
      "module": "msgbox"
    },
    "INT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LANGID": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LARGE_INTEGER": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LCID": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LCTYPE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LGRPID": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LONG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPARAM": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPBOOL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPBYTE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPCOLESTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPCOLORREF": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPCSTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPCVOID": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPCWSTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPDWORD": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPFILETIME": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPHANDLE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPHKL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPLONG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPMSG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPOLESTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPPOINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPRECT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPRECTL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPSC_HANDLE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPSIZE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPSIZEL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPSTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPUINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPVOID": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPWIN32_FIND_DATAA": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPWIN32_FIND_DATAW": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPWORD": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "LPWSTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "MSG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "OLESTR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PBOOL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PBOOLEAN": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PBYTE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PCHAR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PDWORD": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PFILETIME": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PFLOAT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PHANDLE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PHKEY": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PLARGE_INTEGER": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PLCID": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PLONG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PMSG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "POINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "POINTL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PPOINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PPOINTL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PRECT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PRECTL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PSHORT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PSIZE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PSIZEL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PSMALL_RECT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PUINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PULARGE_INTEGER": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PULONG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PUSHORT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PWCHAR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PWIN32_FIND_DATAA": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PWIN32_FIND_DATAW": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "PWORD": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "RECT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "RECTL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "SC_HANDLE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "SERVICE_STATUS_HANDLE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "SHORT": {
      "methods": {},
      "doc": "",
      "module": "msgbox"
    },
    "SIZE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "SIZEL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "SMALL_RECT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "UINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "ULARGE_INTEGER": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "ULONG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "USHORT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "VARIANT_BOOL": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "WCHAR": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "WIN32_FIND_DATAA": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "WIN32_FIND_DATAW": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "WORD": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "WPARAM": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "tagMSG": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "tagPOINT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "tagRECT": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "tagSIZE": {
      "methods": {},
      "doc": "",
      "module": "ctypes.wintypes"
    },
    "prototype": {
      "methods": {},
      "doc": "",
      "module": "msgbox"
    },
    "TextWrapper": {
      "methods": {
        "fill": {
          "signature": "(self, text)",
          "doc": "fill(text : string) -> string"
        },
        "wrap": {
          "signature": "(self, text)",
          "doc": "wrap(text : string) -> [string]"
        }
      },
      "doc": "",
      "module": "textwrap"
    },
    "AnsiBack": {
      "methods": {},
      "doc": "",
      "module": "colorama.ansitowin32"
    },
    "AnsiCodes": {
      "methods": {},
      "doc": "",
      "module": "colorama.ansi"
    },
    "AnsiCursor": {
      "methods": {
        "BACK": {
          "signature": "(self, n=1)",
          "doc": ""
        },
        "DOWN": {
          "signature": "(self, n=1)",
          "doc": ""
        },
        "FORWARD": {
          "signature": "(self, n=1)",
          "doc": ""
        },
        "POS": {
          "signature": "(self, x=1, y=1)",
          "doc": ""
        },
        "UP": {
          "signature": "(self, n=1)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "colorama.ansi"
    },
    "AnsiFore": {
      "methods": {},
      "doc": "",
      "module": "colorama.ansitowin32"
    },
    "AnsiStyle": {
      "methods": {},
      "doc": "",
      "module": "colorama.ansitowin32"
    },
    "CONSOLE_SCREEN_BUFFER_INFO": {
      "methods": {},
      "doc": "",
      "module": "colorama.win32"
    },
    "COORD": {
      "methods": {},
      "doc": "",
      "module": "colorama.win32"
    },
    "WinColor": {
      "methods": {},
      "doc": "",
      "module": "colorama.ansitowin32"
    },
    "WinStyle": {
      "methods": {},
      "doc": "",
      "module": "colorama.ansitowin32"
    },
    "WinTerm": {
      "methods": {
        "back": {
          "signature": "(self, back=None, light=False, on_stderr=False)",
          "doc": ""
        },
        "cursor_adjust": {
          "signature": "(self, x, y, on_stderr=False)",
          "doc": ""
        },
        "erase_line": {
          "signature": "(self, mode=0, on_stderr=False)",
          "doc": ""
        },
        "erase_screen": {
          "signature": "(self, mode=0, on_stderr=False)",
          "doc": ""
        },
        "fore": {
          "signature": "(self, fore=None, light=False, on_stderr=False)",
          "doc": ""
        },
        "get_attrs": {
          "signature": "(self)",
          "doc": ""
        },
        "get_position": {
          "signature": "(self, handle)",
          "doc": ""
        },
        "reset_all": {
          "signature": "(self, on_stderr=None)",
          "doc": ""
        },
        "set_attrs": {
          "signature": "(self, value)",
          "doc": ""
        },
        "set_console": {
          "signature": "(self, attrs=None, on_stderr=False)",
          "doc": ""
        },
        "set_cursor_position": {
          "signature": "(self, position=None, on_stderr=False)",
          "doc": ""
        },
        "set_title": {
          "signature": "(self, title)",
          "doc": ""
        },
        "style": {
          "signature": "(self, style=None, on_stderr=False)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "colorama.ansitowin32"
    },
    "AnsiToWin32": {
      "methods": {
        "call_win32": {
          "signature": "(self, command, params)",
          "doc": ""
        },
        "convert_ansi": {
          "signature": "(self, paramstring, command)",
          "doc": ""
        },
        "convert_osc": {
          "signature": "(self, text)",
          "doc": ""
        },
        "extract_params": {
          "signature": "(self, command, paramstring)",
          "doc": ""
        },
        "flush": {
          "signature": "(self)",
          "doc": ""
        },
        "get_win32_calls": {
          "signature": "(self)",
          "doc": ""
        },
        "reset_all": {
          "signature": "(self)",
          "doc": ""
        },
        "should_wrap": {
          "signature": "(self)",
          "doc": ""
        },
        "write": {
          "signature": "(self, text)",
          "doc": ""
        },
        "write_and_convert": {
          "signature": "(self, text)",
          "doc": ""
        },
        "write_plain_text": {
          "signature": "(self, text, start, end)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "colorama"
    },
    "StreamWrapper": {
      "methods": {
        "isatty": {
          "signature": "(self)",
          "doc": ""
        },
        "write": {
          "signature": "(self, text)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "colorama.ansitowin32"
    },
    "Finalize": {
      "methods": {
        "cancel": {
          "signature": "(self)",
          "doc": ""
        },
        "still_active": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "multiprocessing.util"
    },
    "ForkAwareLocal": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing.util"
    },
    "ForkAwareThreadLock": {
      "methods": {},
      "doc": "",
      "module": "multiprocessing.util"
    },
    "L": {
      "methods": {},
      "doc": "",
      "module": "freeze.utils"
    },
    "ObjPool": {
      "methods": {
        "alloc": {
          "signature": "(self, basetype, *args, **kwargs)",
          "doc": ""
        },
        "free": {
          "signature": "(self, basetype, data)",
          "doc": ""
        },
        "full": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "eudplib.eudlib.objpool"
    },
    "CompletionGenerator": {
      "methods": {
        "analyze_module": {
          "signature": "(self, module_name, module_obj)",
          "doc": "모듈 분석해서 함수와 클래스 정보 추출"
        },
        "save_completions": {
          "signature": "(self)",
          "doc": "결과를 JSON 파일로 저장"
        },
        "scan_libraries": {
          "signature": "(self)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "main"
    },
    "c_make_scanner": {
      "methods": {},
      "doc": "JSON scanner object",
      "module": "json.scanner"
    },
    "make_scanner": {
      "methods": {},
      "doc": "JSON scanner object",
      "module": "json.scanner"
    },
    "JSONDecodeError": {
      "methods": {},
      "doc": "",
      "module": "json"
    },
    "JSONDecoder": {
      "methods": {
        "decode": {
          "signature": "(self, s, _w=<built-in method match of re.Pattern object at 0x0000014FB54F41E0>)",
          "doc": ""
        },
        "raw_decode": {
          "signature": "(self, s, idx=0)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "json"
    },
    "JSONEncoder": {
      "methods": {
        "default": {
          "signature": "(self, o)",
          "doc": ""
        },
        "encode": {
          "signature": "(self, o)",
          "doc": ""
        },
        "iterencode": {
          "signature": "(self, o, _one_shot=False)",
          "doc": ""
        }
      },
      "doc": "",
      "module": "json"
    },
    "c_make_encoder": {
      "methods": {},
      "doc": "_iterencode(obj, _current_indent_level) -> iterable",
      "module": "json.encoder"
    },
    "ImpImporter": {
      "methods": {
        "find_module": {
          "signature": "(self, fullname, path=None)",
          "doc": ""
        },
        "iter_modules": {
          "signature": "(self, prefix='')",
          "doc": ""
        }
      },
      "doc": "PEP 302 Finder that wraps Python's \"classic\" import algorithm",
      "module": "pkgutil"
    },
    "ImpLoader": {
      "methods": {
        "get_code": {
          "signature": "(self, fullname=None)",
          "doc": ""
        },
        "get_data": {
          "signature": "(self, pathname)",
          "doc": ""
        },
        "get_filename": {
          "signature": "(self, fullname=None)",
          "doc": ""
        },
        "get_source": {
          "signature": "(self, fullname=None)",
          "doc": ""
        },
        "is_package": {
          "signature": "(self, fullname)",
          "doc": ""
        },
        "load_module": {
          "signature": "(self, fullname)",
          "doc": ""
        }
      },
      "doc": "PEP 302 Loader that wraps Python's \"classic\" import algorithm",
      "module": "pkgutil"
    },
    "ModuleInfo": {
      "methods": {},
      "doc": "A namedtuple with minimal info about a module.",
      "module": "pkgutil"
    }
  },
  "vars": {
    "api_version": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sys"
    },
    "argv": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sys"
    },
    "base_exec_prefix": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "base_prefix": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "builtin_module_names": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "sys"
    },
    "byteorder": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "copyright": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "dllhandle": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sys"
    },
    "dont_write_bytecode": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "sys"
    },
    "exec_prefix": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "executable": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "flags": {
      "doc": "sys.flags",
      "type": "flags",
      "module": "sys"
    },
    "float_info": {
      "doc": "sys.float_info",
      "type": "float_info",
      "module": "sys"
    },
    "float_repr_style": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "frozen": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "sys"
    },
    "frozen_dir": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "hash_info": {
      "doc": "hash_info",
      "type": "hash_info",
      "module": "sys"
    },
    "hexversion": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sys"
    },
    "implementation": {
      "doc": "A simple attribute-based namespace.",
      "type": "SimpleNamespace",
      "module": "sys"
    },
    "int_info": {
      "doc": "sys.int_info",
      "type": "int_info",
      "module": "sys"
    },
    "maxsize": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pickle"
    },
    "maxunicode": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sys"
    },
    "meta_path": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sys"
    },
    "modules": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sys"
    },
    "orig_argv": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sys"
    },
    "path": {
      "doc": "Common pathname manipulations, WindowsNT/95 version.",
      "type": "module",
      "module": "os"
    },
    "path_hooks": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sys"
    },
    "path_importer_cache": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sys"
    },
    "platform": {
      "doc": " This module tries to retrieve as much platform-identifying data as",
      "type": "module",
      "module": "eudplib.epscript.epscompile"
    },
    "platlibdir": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "prefix": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "pycache_prefix": {
      "doc": "",
      "type": "NoneType",
      "module": "sys"
    },
    "stderr": {
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "type": "TextIOWrapper",
      "module": "sys"
    },
    "stdin": {
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "type": "TextIOWrapper",
      "module": "sys"
    },
    "stdlib_module_names": {
      "doc": "frozenset() -> empty frozenset object",
      "type": "frozenset",
      "module": "sys"
    },
    "stdout": {
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "type": "TextIOWrapper",
      "module": "sys"
    },
    "thread_info": {
      "doc": "sys.thread_info",
      "type": "thread_info",
      "module": "sys"
    },
    "version": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "euddraft"
    },
    "version_info": {
      "doc": "sys.version_info",
      "type": "version_info",
      "module": "sys"
    },
    "warnoptions": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sys"
    },
    "winver": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sys"
    },
    "Ellipsis": {
      "doc": "",
      "type": "ellipsis",
      "module": "builtins"
    },
    "False": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "builtins"
    },
    "None": {
      "doc": "",
      "type": "NoneType",
      "module": "builtins"
    },
    "NotImplemented": {
      "doc": "",
      "type": "NotImplementedType",
      "module": "builtins"
    },
    "True": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "builtins"
    },
    "F_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_APPEND": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_BINARY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_CREAT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_EXCL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_NOINHERIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_RANDOM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_RDONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_RDWR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_SEQUENTIAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_SHORT_LIVED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_TEMPORARY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_TEXT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_TRUNC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "O_WRONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_DETACH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_NOWAIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_NOWAITO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_OVERLAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "P_WAIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "R_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "TMP_MAX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tempfile"
    },
    "W_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "X_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "environ": {
      "doc": "",
      "type": "_Environ",
      "module": "os"
    },
    "HKEY_CLASSES_ROOT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_CURRENT_CONFIG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_CURRENT_USER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_DYN_DATA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_LOCAL_MACHINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_PERFORMANCE_DATA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "HKEY_USERS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_ALL_ACCESS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_CREATE_LINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_CREATE_SUB_KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_ENUMERATE_SUB_KEYS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_EXECUTE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_NOTIFY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_QUERY_VALUE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_READ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_SET_VALUE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_WOW64_32KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_WOW64_64KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "KEY_WRITE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_BINARY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_CREATED_NEW_KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_DWORD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_DWORD_BIG_ENDIAN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_DWORD_LITTLE_ENDIAN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_EXPAND_SZ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_FULL_RESOURCE_DESCRIPTOR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_LEGAL_CHANGE_FILTER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_LEGAL_OPTION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_LINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_MULTI_SZ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NONE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NOTIFY_CHANGE_ATTRIBUTES": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NOTIFY_CHANGE_LAST_SET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NOTIFY_CHANGE_NAME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NOTIFY_CHANGE_SECURITY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_NO_LAZY_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPENED_EXISTING_KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_BACKUP_RESTORE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_CREATE_LINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_NON_VOLATILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_OPEN_LINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_RESERVED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_OPTION_VOLATILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_QWORD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_QWORD_LITTLE_ENDIAN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_REFRESH_HIVE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_RESOURCE_LIST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_RESOURCE_REQUIREMENTS_LIST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_SZ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "REG_WHOLE_HIVE_VOLATILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winreg"
    },
    "altzone": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "time"
    },
    "daylight": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "time"
    },
    "timezone": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "time"
    },
    "tzname": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "time"
    },
    "END_CENTRAL_DIR_SIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipimport"
    },
    "MAX_COMMENT_LEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipimport"
    },
    "STRING_END_ARCHIVE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipimport"
    },
    "alt_path_sep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zipimport"
    },
    "cp437_table": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zipimport"
    },
    "marshal": {
      "doc": "This module contains functions that can read and write Python values in",
      "type": "module",
      "module": "importlib._bootstrap_external"
    },
    "path_sep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "importlib._bootstrap_external"
    },
    "sys": {
      "doc": "This module provides access to some objects used or maintained by the",
      "type": "module",
      "module": "pkgutil"
    },
    "time": {
      "doc": "This module provides various functions to manipulate time values.",
      "type": "module",
      "module": "euddraft"
    },
    "DEFLATED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "DEF_BUF_SIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "DEF_MEM_LEVEL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "MAX_WBITS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "ZLIB_RUNTIME_VERSION": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zlib"
    },
    "ZLIB_VERSION": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zlib"
    },
    "Z_BEST_COMPRESSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_BEST_SPEED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_BLOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_DEFAULT_COMPRESSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_DEFAULT_STRATEGY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_FILTERED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_FINISH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_FIXED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_FULL_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_HUFFMAN_ONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_NO_COMPRESSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_NO_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_PARTIAL_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_RLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_SYNC_FLUSH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "Z_TREES": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zlib"
    },
    "BOM": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM32_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM32_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM64_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM64_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF16": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF16_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF16_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF32": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF32_BE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF32_LE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "codecs"
    },
    "BOM_UTF8": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "tokenize"
    },
    "builtins": {
      "doc": "Built-in functions, exceptions, and other objects.",
      "type": "module",
      "module": "lzma"
    },
    "aliases": {
      "doc": " Encoding Aliases Support",
      "type": "module",
      "module": "encodings"
    },
    "codecs": {
      "doc": " codecs -- Python Codec Registry, API and helpers.",
      "type": "module",
      "module": "json"
    },
    "cp1252": {
      "doc": " Python Character Mapping Codec cp1252 generated from 'MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1252.TXT' with gencodec.py.",
      "type": "module",
      "module": "encodings"
    },
    "cp949": {
      "doc": "",
      "type": "module",
      "module": "encodings"
    },
    "utf_8": {
      "doc": " Python 'utf-8' Codec",
      "type": "module",
      "module": "encodings"
    },
    "decoding_table": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "encodings.cp1252"
    },
    "encoding_table": {
      "doc": "",
      "type": "EncodingMap",
      "module": "encodings.cp1252"
    },
    "DEFAULT_BUFFER_SIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "io"
    },
    "SEEK_CUR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "SEEK_END": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "SEEK_SET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "os"
    },
    "abc": {
      "doc": "Abstract Base Classes (ABCs) according to PEP 3119.",
      "type": "module",
      "module": "importlib._abc"
    },
    "FILE_ATTRIBUTE_ARCHIVE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_COMPRESSED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_DEVICE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_DIRECTORY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_ENCRYPTED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_HIDDEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_INTEGRITY_STREAM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_NORMAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_NOT_CONTENT_INDEXED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_NO_SCRUB_DATA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_OFFLINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_READONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_REPARSE_POINT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_SPARSE_FILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_SYSTEM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_TEMPORARY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "FILE_ATTRIBUTE_VIRTUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "IO_REPARSE_TAG_APPEXECLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "IO_REPARSE_TAG_MOUNT_POINT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "IO_REPARSE_TAG_SYMLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_APPEND": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_ARCHIVED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_IMMUTABLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_NOUNLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "SF_SNAPSHOT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_ATIME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_CTIME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_DEV": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_GID": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_INO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_MODE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_MTIME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_NLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_SIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "ST_UID": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_ENFMT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IEXEC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFBLK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFCHR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFDIR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFDOOR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFIFO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFLNK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFREG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFSOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IFWHT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IREAD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRGRP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IROTH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRUSR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRWXG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRWXO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IRWXU": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_ISGID": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_ISUID": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_ISVTX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IWGRP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IWOTH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IWRITE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IWUSR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IXGRP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IXOTH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "S_IXUSR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_APPEND": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_COMPRESSED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_HIDDEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_IMMUTABLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_NODUMP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_NOUNLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "UF_OPAQUE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "stat"
    },
    "os": {
      "doc": "OS routines for NT or Posix depending on what system we're on.",
      "type": "module",
      "module": "pkgutil"
    },
    "stat": {
      "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().",
      "type": "module",
      "module": "zipfile"
    },
    "altsep": {
      "doc": "",
      "type": "NoneType",
      "module": "posixpath"
    },
    "curdir": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "posixpath"
    },
    "defpath": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "posixpath"
    },
    "devnull": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "posixpath"
    },
    "extsep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "posixpath"
    },
    "genericpath": {
      "doc": "",
      "type": "module",
      "module": "posixpath"
    },
    "pardir": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "posixpath"
    },
    "pathsep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "posixpath"
    },
    "sep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "posixpath"
    },
    "supports_unicode_filenames": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "posixpath"
    },
    "linesep": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "os"
    },
    "name": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "multiprocessing.process"
    },
    "st": {
      "doc": "Constants/functions for interpreting results of os.stat() and os.lstat().",
      "type": "module",
      "module": "os"
    },
    "supports_bytes_environ": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "os"
    },
    "supports_dir_fd": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "os"
    },
    "supports_effective_ids": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "os"
    },
    "supports_fd": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "os"
    },
    "supports_follow_symlinks": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "os"
    },
    "ANY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "ANY_ALL": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "ASSERT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "ASSERT_NOT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "AT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "ATCODES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sre_compile"
    },
    "AT_BEGINNING": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "AT_BEGINNING_LINE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "AT_BEGINNING_STRING": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "AT_BOUNDARY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "AT_END": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "AT_END_LINE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "AT_END_STRING": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "AT_LOCALE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sre_compile"
    },
    "AT_LOC_BOUNDARY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "AT_LOC_NON_BOUNDARY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "AT_MULTILINE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sre_compile"
    },
    "AT_NON_BOUNDARY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "AT_UNICODE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sre_compile"
    },
    "AT_UNI_BOUNDARY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "AT_UNI_NON_BOUNDARY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "BIGCHARSET": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "BRANCH": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CALL": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_DIGIT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_LINEBREAK": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_LOC_NOT_WORD": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_LOC_WORD": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_NOT_DIGIT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_NOT_LINEBREAK": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_NOT_SPACE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_NOT_WORD": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_SPACE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_UNI_DIGIT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_UNI_LINEBREAK": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_UNI_NOT_DIGIT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_UNI_NOT_LINEBREAK": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_UNI_NOT_SPACE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_UNI_NOT_WORD": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_UNI_SPACE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_UNI_WORD": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CATEGORY_WORD": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CHARSET": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "CHCODES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sre_compile"
    },
    "CH_LOCALE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sre_compile"
    },
    "CH_UNICODE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sre_compile"
    },
    "FAILURE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "GROUPREF": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "GROUPREF_EXISTS": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "GROUPREF_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "GROUPREF_LOC_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "GROUPREF_UNI_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "IN": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "INFO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "multiprocessing.util"
    },
    "IN_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "IN_LOC_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "IN_UNI_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "JUMP": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "LITERAL": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "LITERAL_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "LITERAL_LOC_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "LITERAL_UNI_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "MAGIC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "MARK": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "MAXGROUPS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "MAXREPEAT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "MAX_REPEAT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "MAX_UNTIL": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "MIN_REPEAT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "MIN_REPEAT_ONE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "MIN_UNTIL": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "NEGATE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "NOT_LITERAL": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "NOT_LITERAL_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "NOT_LITERAL_LOC_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "NOT_LITERAL_UNI_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "OPCODES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "sre_compile"
    },
    "OP_IGNORE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sre_compile"
    },
    "OP_LOCALE_IGNORE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sre_compile"
    },
    "OP_UNICODE_IGNORE": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sre_compile"
    },
    "RANGE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "RANGE_UNI_IGNORE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "REPEAT": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "REPEAT_ONE": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "SRE_FLAG_ASCII": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "SRE_FLAG_DEBUG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "SRE_FLAG_DOTALL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "SRE_FLAG_IGNORECASE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "SRE_FLAG_LOCALE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "SRE_FLAG_MULTILINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "SRE_FLAG_TEMPLATE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "SRE_FLAG_UNICODE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "SRE_FLAG_VERBOSE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "SRE_INFO_CHARSET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "SRE_INFO_LITERAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "SRE_INFO_PREFIX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "SUBPATTERN": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "SUCCESS": {
      "doc": "",
      "type": "_NamedIntConstant",
      "module": "sre_compile"
    },
    "ASCIILETTERS": {
      "doc": "frozenset() -> empty frozenset object",
      "type": "frozenset",
      "module": "sre_parse"
    },
    "CATEGORIES": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sre_parse"
    },
    "DIGITS": {
      "doc": "frozenset() -> empty frozenset object",
      "type": "frozenset",
      "module": "sre_parse"
    },
    "ESCAPES": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "sre_parse"
    },
    "FLAGS": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "json.decoder"
    },
    "GLOBAL_FLAGS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_parse"
    },
    "HEXDIGITS": {
      "doc": "frozenset() -> empty frozenset object",
      "type": "frozenset",
      "module": "sre_parse"
    },
    "OCTDIGITS": {
      "doc": "frozenset() -> empty frozenset object",
      "type": "frozenset",
      "module": "sre_parse"
    },
    "REPEAT_CHARS": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sre_parse"
    },
    "SPECIAL_CHARS": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "sre_parse"
    },
    "TYPE_FLAGS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_parse"
    },
    "WHITESPACE": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "json.decoder"
    },
    "MAXCODE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "sre_compile"
    },
    "sre_parse": {
      "doc": "Internal support module for sre",
      "type": "module",
      "module": "re"
    },
    "kwlist": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "keyword"
    },
    "softkwlist": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "keyword"
    },
    "aRepr": {
      "doc": "",
      "type": "Repr",
      "module": "reprlib"
    },
    "repr": {
      "doc": "",
      "type": "method",
      "module": "reprlib"
    },
    "WRAPPER_ASSIGNMENTS": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "functools"
    },
    "WRAPPER_UPDATES": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "functools"
    },
    "dispatch_table": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "copy"
    },
    "A": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "ASCII": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "DEBUG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "multiprocessing.util"
    },
    "DOTALL": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "I": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "IGNORECASE": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "L": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "LOCALE": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "M": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "MULTILINE": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "S": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "T": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.crypt"
    },
    "TEMPLATE": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "U": {
      "doc": "Type variable.",
      "type": "TypeVar",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "UNICODE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "VERBOSE": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "X": {
      "doc": "An enumeration.",
      "type": "RegexFlag",
      "module": "re"
    },
    "copyreg": {
      "doc": "Helper to provide extensibility for pickle.",
      "type": "module",
      "module": "multiprocessing.reduction"
    },
    "enum": {
      "doc": "",
      "type": "module",
      "module": "eudplib.offsetmap.member"
    },
    "functools": {
      "doc": "functools.py - Tools for working with functions and callable objects",
      "type": "module",
      "module": "pathlib"
    },
    "sre_compile": {
      "doc": "Internal support module for sre",
      "type": "module",
      "module": "re"
    },
    "ascii_letters": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email._encoded_words"
    },
    "ascii_lowercase": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "string"
    },
    "ascii_uppercase": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "string"
    },
    "digits": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email._encoded_words"
    },
    "hexdigits": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.quoprimime"
    },
    "octdigits": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "string"
    },
    "printable": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "string"
    },
    "punctuation": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "string"
    },
    "whitespace": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "string"
    },
    "BYTECODE_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "DEBUG_BYTECODE_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "EXTENSION_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "MAGIC_NUMBER": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "importlib.util"
    },
    "OPTIMIZED_BYTECODE_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "SOURCE_SUFFIXES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "importlib.machinery"
    },
    "path_sep_tuple": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "importlib._bootstrap_external"
    },
    "path_separators": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "importlib._bootstrap_external"
    },
    "winreg": {
      "doc": "This module provides access to the Windows registry API.",
      "type": "module",
      "module": "importlib._bootstrap_external"
    },
    "defaultaction": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "warnings"
    },
    "filters": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "warnings"
    },
    "onceregistry": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "warnings"
    },
    "machinery": {
      "doc": "The machinery of importlib: finders, loaders, hooks, etc.",
      "type": "module",
      "module": "importlib"
    },
    "util": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing.spawn"
    },
    "warnings": {
      "doc": "Python part of the warnings subsystem.",
      "type": "module",
      "module": "pkgutil"
    },
    "Match": {
      "doc": "A generic version of re.Match.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Pattern": {
      "doc": "A generic version of re.Pattern.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "AbstractSet": {
      "doc": "A generic version of collections.abc.Set.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Any": {
      "doc": "Special type indicating an unconstrained type.",
      "type": "_SpecialForm",
      "module": "eudplib.maprw.inlinecode.ilccompile"
    },
    "AnyStr": {
      "doc": "Type variable.",
      "type": "TypeVar",
      "module": "typing"
    },
    "AsyncContextManager": {
      "doc": "A generic version of contextlib.AbstractAsyncContextManager.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "AsyncGenerator": {
      "doc": "A generic version of collections.abc.AsyncGenerator.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "AsyncIterable": {
      "doc": "A generic version of collections.abc.AsyncIterable.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "AsyncIterator": {
      "doc": "A generic version of collections.abc.AsyncIterator.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Awaitable": {
      "doc": "A generic version of collections.abc.Awaitable.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "ByteString": {
      "doc": "A generic version of collections.abc.ByteString.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "CT_co": {
      "doc": "Type variable.",
      "type": "TypeVar",
      "module": "typing"
    },
    "Callable": {
      "doc": "Callable type; Callable[[int], str] is a function of (int) -> str.",
      "type": "_CallableType",
      "module": "typing"
    },
    "ChainMap": {
      "doc": "A generic version of collections.ChainMap.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "ClassVar": {
      "doc": "Special type construct to mark class variables.",
      "type": "_SpecialForm",
      "module": "typing"
    },
    "Collection": {
      "doc": "A generic version of collections.abc.Collection.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Concatenate": {
      "doc": "Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a",
      "type": "_SpecialForm",
      "module": "typing"
    },
    "Container": {
      "doc": "A generic version of collections.abc.Container.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "ContextManager": {
      "doc": "A generic version of contextlib.AbstractContextManager.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Coroutine": {
      "doc": "A generic version of collections.abc.Coroutine.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Counter": {
      "doc": "A generic version of collections.Counter.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "DefaultDict": {
      "doc": "A generic version of collections.defaultdict.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Deque": {
      "doc": "A generic version of collections.deque.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Dict": {
      "doc": "A generic version of dict.",
      "type": "_SpecialGenericAlias",
      "module": "readconfig"
    },
    "EXCLUDED_ATTRIBUTES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "typing"
    },
    "Final": {
      "doc": "Special typing construct to indicate final names to type checkers.",
      "type": "_SpecialForm",
      "module": "eudplib.offsetmap.member"
    },
    "FrozenSet": {
      "doc": "A generic version of frozenset.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Generator": {
      "doc": "A generic version of collections.abc.Generator.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Hashable": {
      "doc": "A generic version of collections.abc.Hashable.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "ItemsView": {
      "doc": "A generic version of collections.abc.ItemsView.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Iterable": {
      "doc": "A generic version of collections.abc.Iterable.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Iterator": {
      "doc": "A generic version of collections.abc.Iterator.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "KT": {
      "doc": "Type variable.",
      "type": "TypeVar",
      "module": "typing"
    },
    "KeysView": {
      "doc": "A generic version of collections.abc.KeysView.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "List": {
      "doc": "A generic version of list.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Literal": {
      "doc": "Special typing form to define literal types (a.k.a. value types).",
      "type": "_LiteralSpecialForm",
      "module": "eudplib.offsetmap.member"
    },
    "Mapping": {
      "doc": "A generic version of collections.abc.Mapping.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "MappingView": {
      "doc": "A generic version of collections.abc.MappingView.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "MutableMapping": {
      "doc": "A generic version of collections.abc.MutableMapping.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "MutableSequence": {
      "doc": "A generic version of collections.abc.MutableSequence.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "MutableSet": {
      "doc": "A generic version of collections.abc.MutableSet.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "NoReturn": {
      "doc": "Special type indicating functions that never return.",
      "type": "_SpecialForm",
      "module": "eudplib.offsetmap.member"
    },
    "Optional": {
      "doc": "Optional type.",
      "type": "_SpecialForm",
      "module": "typing"
    },
    "OrderedDict": {
      "doc": "A generic version of collections.OrderedDict.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Reversible": {
      "doc": "A generic version of collections.abc.Reversible.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Sequence": {
      "doc": "A generic version of collections.abc.Sequence.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "Set": {
      "doc": "",
      "type": "_SwitchStateOrAction",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Sized": {
      "doc": "A generic version of collections.abc.Sized.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "TYPE_CHECKING": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "eudplib.offsetmap.epdoffsetmap"
    },
    "T_co": {
      "doc": "Type variable.",
      "type": "TypeVar",
      "module": "eudplib.utils.exprproxy"
    },
    "T_contra": {
      "doc": "Type variable.",
      "type": "TypeVar",
      "module": "typing"
    },
    "Tuple": {
      "doc": "Tuple type; Tuple[X, Y] is the cross-product type of X and Y.",
      "type": "_TupleType",
      "module": "typing"
    },
    "Type": {
      "doc": "A special construct usable to annotate class objects.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "TypeAlias": {
      "doc": "Special marker indicating that an assignment should",
      "type": "_SpecialForm",
      "module": "eudplib.maprw.inlinecode.btInliner"
    },
    "TypeGuard": {
      "doc": "Special typing form used to annotate the return type of a user-defined",
      "type": "_SpecialForm",
      "module": "typing"
    },
    "Union": {
      "doc": "Union type; Union[X, Y] means either X or Y.",
      "type": "_SpecialForm",
      "module": "typing"
    },
    "VT": {
      "doc": "Type variable.",
      "type": "TypeVar",
      "module": "typing"
    },
    "VT_co": {
      "doc": "Type variable.",
      "type": "TypeVar",
      "module": "typing"
    },
    "V_co": {
      "doc": "Type variable.",
      "type": "TypeVar",
      "module": "typing"
    },
    "ValuesView": {
      "doc": "A generic version of collections.abc.ValuesView.",
      "type": "_SpecialGenericAlias",
      "module": "typing"
    },
    "collections": {
      "doc": "This module implements specialized container datatypes providing",
      "type": "module",
      "module": "http.client"
    },
    "contextlib": {
      "doc": "Utilities for with-statement contexts.  See PEP 343.",
      "type": "module",
      "module": "colorama.initialise"
    },
    "operator": {
      "doc": "Operator interface.",
      "type": "module",
      "module": "typing"
    },
    "stdlib_re": {
      "doc": "Support for regular expressions (RE).",
      "type": "module",
      "module": "typing"
    },
    "types": {
      "doc": "",
      "type": "module",
      "module": "main"
    },
    "BUILD_COPYRIGHT": {
      "doc": "",
      "type": "NoneType",
      "module": "BUILD_CONSTANTS"
    },
    "BUILD_HOST": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "BUILD_CONSTANTS"
    },
    "BUILD_RELEASE_STRING": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "BUILD_CONSTANTS"
    },
    "BUILD_TIMESTAMP": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "BUILD_CONSTANTS"
    },
    "SOURCE_TIMESTAMP": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "BUILD_CONSTANTS"
    },
    "TIMEOUT_MAX": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "threading"
    },
    "CTRL_BREAK_EVENT": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "CTRL_C_EVENT": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "NSIG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "signal"
    },
    "SIGABRT": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "SIGBREAK": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "SIGFPE": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "SIGILL": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "SIGINT": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "SIGSEGV": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "SIGTERM": {
      "doc": "An enumeration.",
      "type": "Signals",
      "module": "signal"
    },
    "SIG_DFL": {
      "doc": "An enumeration.",
      "type": "Handlers",
      "module": "signal"
    },
    "SIG_IGN": {
      "doc": "An enumeration.",
      "type": "Handlers",
      "module": "signal"
    },
    "ORIGINAL_DIR": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "multiprocessing.process"
    },
    "itertools": {
      "doc": "Functional tools for creating and using iterators.",
      "type": "module",
      "module": "multiprocessing.util"
    },
    "signal": {
      "doc": "",
      "type": "module",
      "module": "subprocess"
    },
    "threading": {
      "doc": "Thread module emulating a subset of Java's threading model.",
      "type": "module",
      "module": "multiprocessing.util"
    },
    "ADDITEMS": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "APPEND": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "APPENDS": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINBYTES": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINBYTES8": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINFLOAT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINGET": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BININT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BININT1": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BININT2": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINPERSID": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINPUT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINSTRING": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINUNICODE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BINUNICODE8": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BUILD": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "BYTEARRAY8": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "DEFAULT_PROTOCOL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pickle"
    },
    "DICT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "DUP": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "EMPTY_DICT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "EMPTY_LIST": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "EMPTY_SET": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "EMPTY_TUPLE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "EXT1": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "EXT2": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "EXT4": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "FALSE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "FLOAT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "FRAME": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "FROZENSET": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "GET": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "GLOBAL": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "HIGHEST_PROTOCOL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pickle"
    },
    "INST": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "INT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "LIST": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "LONG": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "LONG1": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "LONG4": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "LONG_BINGET": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "LONG_BINPUT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "MEMOIZE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "NEWFALSE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "NEWOBJ": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "NEWOBJ_EX": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "NEWTRUE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "NEXT_BUFFER": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "NONE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "OBJ": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "PERSID": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "POP": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "POP_MARK": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "PROTO": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "PUT": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "PyStringMap": {
      "doc": "",
      "type": "NoneType",
      "module": "pickle"
    },
    "READONLY_BUFFER": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "REDUCE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "SETITEM": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "SETITEMS": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "SHORT_BINBYTES": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "SHORT_BINSTRING": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "SHORT_BINUNICODE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "STACK_GLOBAL": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "STOP": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "STRING": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "TRUE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "TUPLE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "TUPLE1": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "TUPLE2": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "TUPLE3": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "pickle"
    },
    "bytes_types": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "base64"
    },
    "compatible_formats": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "pickle"
    },
    "format_version": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "pickle"
    },
    "io": {
      "doc": "The io module provides the Python interfaces to stream handling. The",
      "type": "module",
      "module": "runpy"
    },
    "re": {
      "doc": "Support for regular expressions (RE).",
      "type": "module",
      "module": "json.encoder"
    },
    "e": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "math"
    },
    "inf": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "math"
    },
    "nan": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "math"
    },
    "pi": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "math"
    },
    "tau": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "math"
    },
    "EVENT_READ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "selectors"
    },
    "EVENT_WRITE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "selectors"
    },
    "math": {
      "doc": "This module provides access to the mathematical functions",
      "type": "module",
      "module": "eudplib.eudlib.mathf.lengthdir"
    },
    "select": {
      "doc": "This module supports asynchronous I/O on multiple file descriptors.",
      "type": "module",
      "module": "selectors"
    },
    "E2BIG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EACCES": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EADDRINUSE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EADDRNOTAVAIL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EAFNOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EAGAIN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EALREADY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EBADF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pathlib"
    },
    "EBADMSG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EBUSY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ECANCELED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ECHILD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ECONNABORTED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ECONNREFUSED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ECONNRESET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EDEADLK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EDEADLOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EDESTADDRREQ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EDOM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EDQUOT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EEXIST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EFAULT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EFBIG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EHOSTDOWN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EHOSTUNREACH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EIDRM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EILSEQ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EINPROGRESS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EINTR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EINVAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pathlib"
    },
    "EIO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EISCONN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EISDIR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ELOOP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pathlib"
    },
    "EMFILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EMLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EMSGSIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENAMETOOLONG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENETDOWN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENETRESET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENETUNREACH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENFILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOBUFS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENODATA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENODEV": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pathlib"
    },
    "ENOEXEC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOLCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOLINK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOMEM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOMSG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOPROTOOPT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOSPC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOSR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOSTR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOSYS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOTCONN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOTDIR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "pathlib"
    },
    "ENOTEMPTY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOTRECOVERABLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOTSOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOTSUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENOTTY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ENXIO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EOPNOTSUPP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EOVERFLOW": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EOWNERDEAD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EPERM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EPFNOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EPIPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EPROTO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EPROTONOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EPROTOTYPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ERANGE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EREMOTE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EROFS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ESHUTDOWN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ESOCKTNOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ESPIPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ESRCH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ESTALE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ETIME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ETIMEDOUT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ETOOMANYREFS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "ETXTBSY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EUSERS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "EWOULDBLOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EXDEV": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSABASEERR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEACCES": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEADDRINUSE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEADDRNOTAVAIL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEAFNOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEALREADY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEBADF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAECONNABORTED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAECONNREFUSED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAECONNRESET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEDESTADDRREQ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEDISCON": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEDQUOT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEFAULT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEHOSTDOWN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEHOSTUNREACH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEINPROGRESS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEINTR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEINVAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEISCONN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAELOOP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEMFILE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEMSGSIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENAMETOOLONG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENETDOWN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENETRESET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENETUNREACH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENOBUFS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENOPROTOOPT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENOTCONN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENOTEMPTY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAENOTSOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEOPNOTSUPP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEPFNOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEPROCLIM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEPROTONOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEPROTOTYPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEREMOTE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAESHUTDOWN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAESOCKTNOSUPPORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAESTALE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAETIMEDOUT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAETOOMANYREFS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEUSERS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAEWOULDBLOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSANOTINITIALISED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSASYSNOTREADY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "WSAVERNOTSUPPORTED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "errno"
    },
    "errorcode": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "errno"
    },
    "AF_APPLETALK": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_BLUETOOTH": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_DECnet": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "AF_INET": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_INET6": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_IPX": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_IRDA": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_LINK": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_SNA": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AF_UNSPEC": {
      "doc": "An enumeration.",
      "type": "AddressFamily",
      "module": "socket"
    },
    "AI_ADDRCONFIG": {
      "doc": "An enumeration.",
      "type": "AddressInfo",
      "module": "socket"
    },
    "AI_ALL": {
      "doc": "An enumeration.",
      "type": "AddressInfo",
      "module": "socket"
    },
    "AI_CANONNAME": {
      "doc": "An enumeration.",
      "type": "AddressInfo",
      "module": "socket"
    },
    "AI_NUMERICHOST": {
      "doc": "An enumeration.",
      "type": "AddressInfo",
      "module": "socket"
    },
    "AI_NUMERICSERV": {
      "doc": "An enumeration.",
      "type": "AddressInfo",
      "module": "socket"
    },
    "AI_PASSIVE": {
      "doc": "An enumeration.",
      "type": "AddressInfo",
      "module": "socket"
    },
    "AI_V4MAPPED": {
      "doc": "An enumeration.",
      "type": "AddressInfo",
      "module": "socket"
    },
    "BDADDR_ANY": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "socket"
    },
    "BDADDR_LOCAL": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "socket"
    },
    "BTPROTO_RFCOMM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "CAPI": {
      "doc": "Capsule objects let you wrap a C \"void *\" pointer in a Python",
      "type": "PyCapsule",
      "module": "socket"
    },
    "EAI_AGAIN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_BADFLAGS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_FAIL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_FAMILY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_MEMORY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_NODATA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_NONAME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_SERVICE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "EAI_SOCKTYPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "INADDR_ALLHOSTS_GROUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "INADDR_ANY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "INADDR_BROADCAST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "INADDR_LOOPBACK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "INADDR_MAX_LOCAL_GROUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "INADDR_NONE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "INADDR_UNSPEC_GROUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPORT_RESERVED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPORT_USERRESERVED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_AH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_CBT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_DSTOPTS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_EGP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_ESP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_FRAGMENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_GGP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_HOPOPTS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_ICLFXBM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_ICMP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_ICMPV6": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_IDP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_IGMP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_IGP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_IP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_IPV4": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_IPV6": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_L2TP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_MAX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_ND": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_NONE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_PGM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_PIM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_PUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_RAW": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_RDP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_ROUTING": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_SCTP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_ST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_TCP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPPROTO_UDP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_CHECKSUM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_DONTFRAG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_HOPLIMIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_HOPOPTS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_JOIN_GROUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_LEAVE_GROUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_MULTICAST_HOPS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_MULTICAST_IF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_MULTICAST_LOOP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_PKTINFO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_RECVRTHDR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_RECVTCLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_RTHDR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_TCLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_UNICAST_HOPS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IPV6_V6ONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_ADD_MEMBERSHIP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_DROP_MEMBERSHIP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_HDRINCL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_MULTICAST_IF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_MULTICAST_LOOP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_MULTICAST_TTL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_OPTIONS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_RECVDSTADDR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_RECVTOS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_TOS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "IP_TTL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "MSG_BCAST": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_CTRUNC": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_DONTROUTE": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_ERRQUEUE": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_MCAST": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_OOB": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_PEEK": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_TRUNC": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "MSG_WAITALL": {
      "doc": "An enumeration.",
      "type": "MsgFlag",
      "module": "socket"
    },
    "NI_DGRAM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "NI_MAXHOST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "NI_MAXSERV": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "NI_NAMEREQD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "NI_NOFQDN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "NI_NUMERICHOST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "NI_NUMERICSERV": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "RCVALL_MAX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "RCVALL_OFF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "RCVALL_ON": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "RCVALL_SOCKETLEVELONLY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SHUT_RD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SHUT_RDWR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SHUT_WR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SIO_KEEPALIVE_VALS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SIO_LOOPBACK_FAST_PATH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SIO_RCVALL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SOCK_DGRAM": {
      "doc": "An enumeration.",
      "type": "SocketKind",
      "module": "socket"
    },
    "SOCK_RAW": {
      "doc": "An enumeration.",
      "type": "SocketKind",
      "module": "socket"
    },
    "SOCK_RDM": {
      "doc": "An enumeration.",
      "type": "SocketKind",
      "module": "socket"
    },
    "SOCK_SEQPACKET": {
      "doc": "An enumeration.",
      "type": "SocketKind",
      "module": "socket"
    },
    "SOCK_STREAM": {
      "doc": "An enumeration.",
      "type": "SocketKind",
      "module": "ssl"
    },
    "SOL_IP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SOL_SOCKET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ssl"
    },
    "SOL_TCP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SOL_UDP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SOMAXCONN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_ACCEPTCONN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_BROADCAST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_DEBUG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_DONTROUTE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_ERROR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_EXCLUSIVEADDRUSE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_KEEPALIVE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_LINGER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_OOBINLINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_RCVBUF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_RCVLOWAT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_RCVTIMEO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_REUSEADDR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_SNDBUF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_SNDLOWAT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_SNDTIMEO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "SO_TYPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ssl"
    },
    "SO_USELOOPBACK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "TCP_MAXSEG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "TCP_NODELAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "socket"
    },
    "errno": {
      "doc": "This module makes available standard errno system symbols.",
      "type": "module",
      "module": "http.client"
    },
    "errorTab": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "socket"
    },
    "has_ipv6": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "socket"
    },
    "selectors": {
      "doc": "Selectors module.",
      "type": "module",
      "module": "socket"
    },
    "HAVE_SEND_HANDLE": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "multiprocessing.reduction"
    },
    "context": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing"
    },
    "pickle": {
      "doc": "Create portable serialized representations of Python objects.",
      "type": "module",
      "module": "multiprocessing.reduction"
    },
    "register": {
      "doc": "Register a reduce function for a type.",
      "type": "method",
      "module": "multiprocessing.reduction"
    },
    "socket": {
      "doc": "This module provides socket operations and some related functions.",
      "type": "module",
      "module": "urllib.request"
    },
    "process": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing.spawn"
    },
    "reduction": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing.spawn"
    },
    "Array": {
      "doc": "Returns a synchronized shared array",
      "type": "method",
      "module": "multiprocessing"
    },
    "Barrier": {
      "doc": "Returns a barrier object",
      "type": "method",
      "module": "multiprocessing"
    },
    "BoundedSemaphore": {
      "doc": "Returns a bounded semaphore object",
      "type": "method",
      "module": "multiprocessing"
    },
    "Condition": {
      "doc": "Returns a condition object",
      "type": "method",
      "module": "multiprocessing"
    },
    "Event": {
      "doc": "Returns an event object",
      "type": "method",
      "module": "multiprocessing"
    },
    "JoinableQueue": {
      "doc": "Returns a queue object",
      "type": "method",
      "module": "multiprocessing"
    },
    "Lock": {
      "doc": "Returns a non-recursive lock object",
      "type": "method",
      "module": "multiprocessing"
    },
    "Manager": {
      "doc": "Returns a manager associated with a running server process",
      "type": "method",
      "module": "multiprocessing"
    },
    "Pipe": {
      "doc": "Returns two connection object connected by a pipe",
      "type": "method",
      "module": "multiprocessing"
    },
    "Pool": {
      "doc": "Returns a process pool object",
      "type": "method",
      "module": "multiprocessing"
    },
    "Queue": {
      "doc": "Returns a queue object",
      "type": "method",
      "module": "multiprocessing"
    },
    "RLock": {
      "doc": "Returns a recursive lock object",
      "type": "method",
      "module": "multiprocessing"
    },
    "RawArray": {
      "doc": "Returns a shared array",
      "type": "method",
      "module": "multiprocessing"
    },
    "RawValue": {
      "doc": "Returns a shared object",
      "type": "method",
      "module": "multiprocessing"
    },
    "SUBDEBUG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "multiprocessing.util"
    },
    "SUBWARNING": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "multiprocessing.util"
    },
    "Semaphore": {
      "doc": "Returns a semaphore object",
      "type": "method",
      "module": "multiprocessing"
    },
    "SimpleQueue": {
      "doc": "Returns a queue object",
      "type": "method",
      "module": "multiprocessing"
    },
    "Value": {
      "doc": "Returns a synchronized shared object",
      "type": "method",
      "module": "multiprocessing"
    },
    "allow_connection_pickling": {
      "doc": "Install support for sending connections and sockets",
      "type": "method",
      "module": "multiprocessing"
    },
    "cpu_count": {
      "doc": "Returns the number of CPUs in the system",
      "type": "method",
      "module": "multiprocessing"
    },
    "freeze_support": {
      "doc": "Check whether this is a fake forked process in a frozen executable.",
      "type": "method",
      "module": "multiprocessing"
    },
    "get_all_start_methods": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "get_context": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing"
    },
    "get_logger": {
      "doc": "Return package logger -- if it does not already exist then",
      "type": "method",
      "module": "multiprocessing"
    },
    "get_start_method": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing.spawn"
    },
    "log_to_stderr": {
      "doc": "Turn on logging and add a handler which prints to stderr",
      "type": "method",
      "module": "multiprocessing"
    },
    "reducer": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing"
    },
    "set_executable": {
      "doc": "Sets the path to a python.exe or pythonw.exe binary used to run",
      "type": "method",
      "module": "multiprocessing"
    },
    "set_forkserver_preload": {
      "doc": "Set list of module names to try to load in forkserver process.",
      "type": "method",
      "module": "multiprocessing"
    },
    "set_start_method": {
      "doc": "",
      "type": "method",
      "module": "multiprocessing.spawn"
    },
    "spawn": {
      "doc": "",
      "type": "module",
      "module": "multiprocessing"
    },
    "CHAR_MAX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "locale"
    },
    "LC_ALL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "locale"
    },
    "LC_COLLATE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "locale"
    },
    "LC_CTYPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "locale"
    },
    "LC_MONETARY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "locale"
    },
    "LC_NUMERIC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "locale"
    },
    "LC_TIME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "locale"
    },
    "encodings": {
      "doc": " Standard \"encodings\" Package",
      "type": "module",
      "module": "locale"
    },
    "k": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "locale_alias": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "locale"
    },
    "locale_encoding_alias": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "locale"
    },
    "v": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "windows_locale": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "locale"
    },
    "gettext": {
      "doc": "Internationalization and localization support.",
      "type": "module",
      "module": "eudplib.localize"
    },
    "locale": {
      "doc": "Locale support module.",
      "type": "module",
      "module": "cgi"
    },
    "BPF": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "random"
    },
    "LOG4": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "random"
    },
    "NV_MAGICCONST": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "random"
    },
    "RECIP_BPF": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "random"
    },
    "SG_MAGICCONST": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "random"
    },
    "TWOPI": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "random"
    },
    "betavariate": {
      "doc": "Beta distribution.",
      "type": "method",
      "module": "random"
    },
    "choice": {
      "doc": "Choose a random element from a non-empty sequence.",
      "type": "method",
      "module": "random"
    },
    "choices": {
      "doc": "Return a k sized list of population elements chosen with replacement.",
      "type": "method",
      "module": "random"
    },
    "expovariate": {
      "doc": "Exponential distribution.",
      "type": "method",
      "module": "random"
    },
    "gammavariate": {
      "doc": "Gamma distribution.  Not the gamma function!",
      "type": "method",
      "module": "random"
    },
    "gauss": {
      "doc": "Gaussian distribution.",
      "type": "method",
      "module": "random"
    },
    "getstate": {
      "doc": "Return internal state; can be passed to setstate() later.",
      "type": "method",
      "module": "random"
    },
    "lognormvariate": {
      "doc": "Log normal distribution.",
      "type": "method",
      "module": "random"
    },
    "normalvariate": {
      "doc": "Normal distribution.",
      "type": "method",
      "module": "random"
    },
    "paretovariate": {
      "doc": "Pareto distribution.  alpha is the shape parameter.",
      "type": "method",
      "module": "random"
    },
    "randbytes": {
      "doc": "Generate n random bytes.",
      "type": "method",
      "module": "random"
    },
    "randint": {
      "doc": "Return random integer in range [a, b], including both end points.",
      "type": "method",
      "module": "random"
    },
    "randrange": {
      "doc": "Choose a random item from range(start, stop[, step]).",
      "type": "method",
      "module": "random"
    },
    "sample": {
      "doc": "Chooses k unique random elements from a population sequence or set.",
      "type": "method",
      "module": "random"
    },
    "seed": {
      "doc": "Initialize internal state from a seed.",
      "type": "method",
      "module": "random"
    },
    "setstate": {
      "doc": "Restore internal state from object returned by getstate().",
      "type": "method",
      "module": "random"
    },
    "shuffle": {
      "doc": "Shuffle list x in place, and return None.",
      "type": "method",
      "module": "random"
    },
    "triangular": {
      "doc": "Triangular distribution.",
      "type": "method",
      "module": "random"
    },
    "uniform": {
      "doc": "Get a random number in the range [a, b) or [a, b] depending on rounding.",
      "type": "method",
      "module": "random"
    },
    "vonmisesvariate": {
      "doc": "Circular data distribution.",
      "type": "method",
      "module": "random"
    },
    "weibullvariate": {
      "doc": "Weibull distribution.",
      "type": "method",
      "module": "random"
    },
    "BytesPath": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.utils.etc"
    },
    "StrPath": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.utils.etc"
    },
    "random": {
      "doc": "Random variable generators.",
      "type": "module",
      "module": "freeze.obfpatch"
    },
    "g_encoding": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.utils.ubconv"
    },
    "binio": {
      "doc": "",
      "type": "module",
      "module": "eudplib.utils"
    },
    "blockstru": {
      "doc": "",
      "type": "module",
      "module": "eudplib.utils"
    },
    "eperror": {
      "doc": "",
      "type": "module",
      "module": "eudplib.utils"
    },
    "etc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.utils"
    },
    "exprproxy": {
      "doc": "",
      "type": "module",
      "module": "eudplib.utils"
    },
    "stackobjs": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.allocator.payload"
    },
    "ubconv": {
      "doc": "",
      "type": "module",
      "module": "eudplib.utils"
    },
    "ut": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.objpool"
    },
    "Evaluable": {
      "doc": "",
      "type": "_UnionGenericAlias",
      "module": "eudplib.core.allocator.payload"
    },
    "defri": {
      "doc": "",
      "type": "RlocInt_C",
      "module": "eudplib.core.allocator.payload"
    },
    "phase": {
      "doc": "",
      "type": "NoneType",
      "module": "eudplib.core.allocator.payload"
    },
    "constexpr": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "payload": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "pbuffer": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "rlocint": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "DEFAULT_MODE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "GetLastError": {
      "doc": "",
      "type": "_FuncPtr",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "RTLD_GLOBAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "RTLD_LOCAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "cdll": {
      "doc": "",
      "type": "LibraryLoader",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "memmove": {
      "doc": "",
      "type": "CFunctionType",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "memset": {
      "doc": "",
      "type": "CFunctionType",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "oledll": {
      "doc": "",
      "type": "LibraryLoader",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "pydll": {
      "doc": "",
      "type": "LibraryLoader",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "pythonapi": {
      "doc": "This class represents the Python library itself.  It allows",
      "type": "PyDLL",
      "module": "eudplib.core.mapdata.unitprp"
    },
    "windll": {
      "doc": "",
      "type": "LibraryLoader",
      "module": "colorama.ansitowin32"
    },
    "wintypes": {
      "doc": "",
      "type": "module",
      "module": "colorama.win32"
    },
    "unit_name_encoding": {
      "doc": "",
      "type": "NoneType",
      "module": "eudplib.core.mapdata.tblformat"
    },
    "locmap": {
      "doc": "",
      "type": "StringIdMap",
      "module": "eudplib.core.mapdata.stringmap"
    },
    "strmap": {
      "doc": "",
      "type": "TBL",
      "module": "eudplib.core.mapdata.stringmap"
    },
    "strsection": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.mapdata.stringmap"
    },
    "swmap": {
      "doc": "",
      "type": "StringIdMap",
      "module": "eudplib.core.mapdata.stringmap"
    },
    "unitmap": {
      "doc": "",
      "type": "StringIdMap",
      "module": "eudplib.core.mapdata.stringmap"
    },
    "chktok": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.loadmap"
    },
    "fixmapdata": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.savemap"
    },
    "mapdata": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.savemap"
    },
    "mpqapi": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.savemap"
    },
    "playerinfo": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "proptable": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "stringmap": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "tblformat": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "unitprp": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "Add": {
      "doc": "",
      "type": "_Modifier",
      "module": "freeze.crypt"
    },
    "All": {
      "doc": "",
      "type": "_Count",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "AllPlayers": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.maprw.inlinecode.ilcprocesstrig"
    },
    "AlliedVictory": {
      "doc": "",
      "type": "_AllyStatus",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Allies": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Ally": {
      "doc": "",
      "type": "_AllyStatus",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "AllyStatus": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "AllyStatusDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "AtLeast": {
      "doc": "",
      "type": "_Comparison",
      "module": "eudplib.eudlib.unitgroup"
    },
    "AtMost": {
      "doc": "",
      "type": "_Comparison",
      "module": "eudplib.eudlib.unitgroup"
    },
    "Attack": {
      "doc": "",
      "type": "_Order",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Buildings": {
      "doc": "",
      "type": "_Score",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Byte": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.rawtrigger.stockact"
    },
    "Clear": {
      "doc": "",
      "type": "_SwitchAction",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Cleared": {
      "doc": "",
      "type": "_SwitchState",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Comparison": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "ComparisonDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "Count": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "CurrentPlayer": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.eudlib.unitgroup"
    },
    "Custom": {
      "doc": "",
      "type": "_Score",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Disable": {
      "doc": "",
      "type": "_PropState",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Dword": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.rawtrigger.stockcond"
    },
    "Enable": {
      "doc": "",
      "type": "_PropState",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Enemy": {
      "doc": "",
      "type": "_AllyStatus",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Exactly": {
      "doc": "",
      "type": "_Comparison",
      "module": "eudplib.eudlib.unitgroup"
    },
    "Foes": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Force1": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Force2": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Force3": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Force4": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Gas": {
      "doc": "",
      "type": "_Resource",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Kills": {
      "doc": "",
      "type": "_KillsSpecialized",
      "module": "eudplib.trigtrg"
    },
    "KillsAndRazings": {
      "doc": "",
      "type": "_Score",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Modifier": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "ModifierDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "Move": {
      "doc": "",
      "type": "_Order",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "NeutralPlayers": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "NonAlliedVictoryPlayers": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Order": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "OrderDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "Ore": {
      "doc": "",
      "type": "_Resource",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "OreAndGas": {
      "doc": "",
      "type": "_Resource",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "P1": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "P10": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "P11": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "P12": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "P2": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "P3": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "P4": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "P5": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "P6": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "P7": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "P8": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "P9": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Patrol": {
      "doc": "",
      "type": "_Order",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Player": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Player1": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Player10": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Player11": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Player12": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Player2": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Player3": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Player4": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Player5": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Player6": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Player7": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Player8": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Player9": {
      "doc": "",
      "type": "_Player",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "PlayerDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "PropState": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "PropStateDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "Random": {
      "doc": "",
      "type": "_SwitchAction",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Razings": {
      "doc": "",
      "type": "_Score",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Resource": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "ResourceDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "Score": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.rawtrigger.stockact"
    },
    "ScoreDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "SetTo": {
      "doc": "",
      "type": "_Modifier",
      "module": "eudplib.eudlib.unitgroup"
    },
    "Subtract": {
      "doc": "",
      "type": "_Modifier",
      "module": "eudplib.eudlib.unitgroup"
    },
    "SwitchAction": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "SwitchActionDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "SwitchState": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "SwitchStateDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.constenc"
    },
    "Toggle": {
      "doc": "",
      "type": "_PropState",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Total": {
      "doc": "",
      "type": "_Score",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Units": {
      "doc": "",
      "type": "_Score",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "UnitsAndBuildings": {
      "doc": "",
      "type": "_Score",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Word": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "bytedump": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "eudobj": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "Trigger": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.rawtrigger.rawtriggerdef"
    },
    "struct": {
      "doc": "Functions to convert between Python values and C structs.",
      "type": "module",
      "module": "zipfile"
    },
    "DefFlingyDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefIconDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefImageDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefIscriptDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefPortraitDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefSpriteDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefStatTextDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefTechDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefAIScriptDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefLocationDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefSwitchDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefUnitDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefUnitOrderDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefUpgradeDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "DefWeaponDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "flingy": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "icon": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "image": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "iscript": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "portrait": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "sprite": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "stattxt": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "tech": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "trg": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector.injFinalizer"
    },
    "unitorder": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "upgrade": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "weapon": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strdict"
    },
    "AIScript": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Flingy": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "Icon": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "Image": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "Iscript": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "Location": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Portrait": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "Sprite": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "StatText": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "String": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "Switch": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.core.rawtrigger.stockact"
    },
    "Tech": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "Unit": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigtrg.trigtrg"
    },
    "UnitOrder": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "Upgrade": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "Weapon": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "difflib": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.rawtrigger.strenc"
    },
    "action": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "condition": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "constenc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "rawtriggerdef": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "stockact": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "stockcond": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "strdict": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "strenc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "triggerscope": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "Self": {
      "doc": "Type variable.",
      "type": "TypeVar",
      "module": "eudplib.core.variable.vbase"
    },
    "bt": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.eudstruct.vararray"
    },
    "AMPER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "AMPEREQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "ASYNC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "ATEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "AWAIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "CIRCUMFLEX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "CIRCUMFLEXEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "COLON": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "COLONEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "COMMA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "COMMENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "DEDENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "DOT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "DOUBLESLASH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "DOUBLESLASHEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "DOUBLESTAR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "DOUBLESTAREQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "ELLIPSIS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "ENCODING": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "ENDMARKER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "EQEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "EQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "ERRORTOKEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "EXACT_TOKEN_TYPES": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "tokenize"
    },
    "GREATER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "GREATEREQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "INDENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "LBRACE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "LEFTSHIFT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "LEFTSHIFTEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "LESS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "LESSEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "LPAR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "LSQB": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "MINEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "MINUS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "NAME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "NEWLINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "NL": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.feedparser"
    },
    "NOTEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "NT_OFFSET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "NUMBER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "N_TOKENS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "OP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "PERCENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "PERCENTEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "PLUS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "PLUSEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "RARROW": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "RBRACE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "RIGHTSHIFT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "RIGHTSHIFTEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "RPAR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "RSQB": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "SEMI": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "SLASH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "SLASHEQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "SOFT_KEYWORD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "STAR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "STAREQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "TILDE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "TYPE_COMMENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "TYPE_IGNORE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "VBAR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "VBAREQUAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "tok_name": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "tokenize"
    },
    "Binnumber": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Comment": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "ContStr": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Decnumber": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Double": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Double3": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Expfloat": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Exponent": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Floatnumber": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Funny": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Hexnumber": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Ignore": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Imagnumber": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Intnumber": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Name": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Number": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Octnumber": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "PlainToken": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Pointfloat": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "PseudoExtras": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "PseudoToken": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Single": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Single3": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Special": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "StringPrefix": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Token": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Triple": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "Whitespace": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "blank_re": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "tokenize"
    },
    "cookie_re": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "tokenize"
    },
    "endpats": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "tokenize"
    },
    "single_quoted": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "tokenize"
    },
    "t": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.inlinecode.ilccompile"
    },
    "tabsize": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "tokenize"
    },
    "triple_quoted": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "tokenize"
    },
    "u": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tokenize"
    },
    "cache": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "linecache"
    },
    "tokenize": {
      "doc": "Tokenization help for Python programs.",
      "type": "module",
      "module": "inspect"
    },
    "linecache": {
      "doc": "Cache lines from Python source files.",
      "type": "module",
      "module": "inspect"
    },
    "isRValueStrict": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "eudplib.core.variable.eudv"
    },
    "traceback": {
      "doc": "Extract, format and print information about Python stack traces.",
      "type": "module",
      "module": "applyeuddraft"
    },
    "eudlv": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "eudv": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "eudxv": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "evcommon": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "vbase": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "vbuf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "TrgAIScript": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgAllyStatus": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgComparison": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgCount": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgLocation": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgModifier": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgOrder": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgPlayer": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgPropState": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgProperty": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgResource": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgScore": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgString": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgSwitch": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgSwitchAction": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgSwitchState": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "TrgUnit": {
      "doc": "",
      "type": "createEncoder",
      "module": "eudplib.core"
    },
    "PyCF_ALLOW_TOP_LEVEL_AWAIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ast"
    },
    "PyCF_ONLY_AST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ast"
    },
    "PyCF_TYPE_COMMENTS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ast"
    },
    "EXTENDED_ARG": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "dis"
    },
    "HAVE_ARGUMENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "dis"
    },
    "cmp_op": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "dis"
    },
    "hascompare": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "hasconst": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "hasfree": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "hasjabs": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "hasjrel": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "haslocal": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "hasname": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "hasnargs": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "opmap": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "dis"
    },
    "opname": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "dis"
    },
    "COMPILER_FLAG_NAMES": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "dis"
    },
    "FORMAT_VALUE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "dis"
    },
    "FORMAT_VALUE_CONVERTERS": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "dis"
    },
    "MAKE_FUNCTION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "dis"
    },
    "MAKE_FUNCTION_FLAGS": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "dis"
    },
    "CORO_CLOSED": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "CORO_CREATED": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "CORO_RUNNING": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "CORO_SUSPENDED": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "CO_ASYNC_GENERATOR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_COROUTINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_GENERATOR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_ITERABLE_COROUTINE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_NESTED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_NEWLOCALS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_NOFREE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_OPTIMIZED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_VARARGS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "CO_VARKEYWORDS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "GEN_CLOSED": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "GEN_CREATED": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "GEN_RUNNING": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "GEN_SUSPENDED": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "inspect"
    },
    "TPFLAGS_IS_ABSTRACT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "inspect"
    },
    "ast": {
      "doc": "",
      "type": "module",
      "module": "inspect"
    },
    "dis": {
      "doc": "Disassembler of Python byte code into mnemonics.",
      "type": "module",
      "module": "main"
    },
    "importlib": {
      "doc": "A pure Python implementation of import.",
      "type": "module",
      "module": "pkgutil"
    },
    "mod_dict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "inspect"
    },
    "modulesbyfile": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "inspect"
    },
    "token": {
      "doc": "Token constants.",
      "type": "module",
      "module": "inspect"
    },
    "iHeader": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "eudplib.core.eudfunc.trace.tracetool"
    },
    "nextTraceId": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.core.eudfunc.trace.tracetool"
    },
    "recordTraceAct": {
      "doc": "",
      "type": "Forward",
      "module": "eudplib.core.eudfunc.trace.tracetool"
    },
    "recordTraceTrigger": {
      "doc": "",
      "type": "RawTrigger",
      "module": "eudplib.core.eudfunc.trace.tracetool"
    },
    "traceHeader": {
      "doc": "",
      "type": "NoneType",
      "module": "eudplib.maprw.savemap"
    },
    "traceKey": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.core.eudfunc.trace.tracetool"
    },
    "traceMap": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.maprw.savemap"
    },
    "traceToolDataEPD": {
      "doc": "",
      "type": "ConstExpr",
      "module": "eudplib.core.eudfunc.trace.tracetool"
    },
    "tracecrypt": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "tracetool": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "ac": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.calcf.bitwise"
    },
    "ev": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.objpool"
    },
    "inspect": {
      "doc": "Get useful information from live Python objects.",
      "type": "module",
      "module": "main"
    },
    "EUDVArray": {
      "doc": "",
      "type": "_lru_cache_wrapper",
      "module": "eudplib.eudlib.unitgroup"
    },
    "EUDVArrayData": {
      "doc": "",
      "type": "_lru_cache_wrapper",
      "module": "eudplib.core.eudstruct.vararray"
    },
    "eudstruct": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "structarr": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "vararray": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "rt": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.calcf.bitwise"
    },
    "consttype": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "eudf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "eudfmethod": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "eudfptr": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "eudfuncn": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "eudtypedfuncn": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "trace": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "ef": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core.calcf.bitwise"
    },
    "f_bitsplit": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.core"
    },
    "bitwise": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "muldiv": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "allocator": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "calcf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "curpl": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "eudfunc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "inlinens": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "inplacecw": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "rawtrigger": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "variable": {
      "doc": "",
      "type": "module",
      "module": "eudplib.core"
    },
    "Constant": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigger.filler"
    },
    "c": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.objpool"
    },
    "ConstCondition": {
      "doc": "",
      "type": "_UnionGenericAlias",
      "module": "eudplib.trigger.tpatcher"
    },
    "actpt": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.trigger.tpatcher"
    },
    "condpt": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.trigger.tpatcher"
    },
    "Actions": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigger.ptrigger"
    },
    "Conditions": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigger.ptrigger"
    },
    "Players": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.trigger.ptrigger"
    },
    "branch": {
      "doc": "",
      "type": "module",
      "module": "eudplib.trigger"
    },
    "filler": {
      "doc": "",
      "type": "module",
      "module": "eudplib.trigger"
    },
    "ptrigger": {
      "doc": "",
      "type": "module",
      "module": "eudplib.trigger"
    },
    "tpatcher": {
      "doc": "",
      "type": "module",
      "module": "eudplib.trigger"
    },
    "triggerdef": {
      "doc": "",
      "type": "module",
      "module": "eudplib.trigger"
    },
    "tg": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru.shortcircuit"
    },
    "lb": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru.breakcont"
    },
    "sb": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru.breakcont"
    },
    "basicstru": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "breakcont": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "cshelper": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "jumptable": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "loopblock": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "shortcircuit": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "simpleblock": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "swblock": {
      "doc": "",
      "type": "module",
      "module": "eudplib.ctrlstru"
    },
    "CRT_ASSEMBLY_VERSION": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "msvcrt"
    },
    "LK_LOCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "LK_NBLCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "LK_NBRLCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "LK_RLCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "LK_UNLCK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "SEM_FAILCRITICALERRORS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "SEM_NOALIGNMENTFAULTEXCEPT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "SEM_NOGPFAULTERRORBOX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "SEM_NOOPENFILEERRORBOX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "msvcrt"
    },
    "ABOVE_NORMAL_PRIORITY_CLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "BELOW_NORMAL_PRIORITY_CLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "CREATE_BREAKAWAY_FROM_JOB": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "CREATE_DEFAULT_ERROR_MODE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "CREATE_NEW_CONSOLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "CREATE_NEW_PROCESS_GROUP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "CREATE_NO_WINDOW": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "DETACHED_PROCESS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "DEVNULL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "HIGH_PRIORITY_CLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "IDLE_PRIORITY_CLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "NORMAL_PRIORITY_CLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "PIPE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "REALTIME_PRIORITY_CLASS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "STARTF_USESHOWWINDOW": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "STARTF_USESTDHANDLES": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "STDOUT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "colorama.win32"
    },
    "STD_ERROR_HANDLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "STD_INPUT_HANDLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "STD_OUTPUT_HANDLE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "SW_HIDE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "subprocess"
    },
    "fcntl": {
      "doc": "",
      "type": "NoneType",
      "module": "subprocess"
    },
    "msvcrt": {
      "doc": "",
      "type": "module",
      "module": "subprocess"
    },
    "subprocess": {
      "doc": "Subprocesses with accessible I/O streams",
      "type": "module",
      "module": "applyeuddraft"
    },
    "libFile": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.epscript.epscompile"
    },
    "libeps": {
      "doc": "An instance of this class represents a loaded dll/shared",
      "type": "CDLL",
      "module": "eudplib.epscript.epscompile"
    },
    "is_scdb_map": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "eudplib.epscript.epsimp"
    },
    "lineno_regex": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "eudplib.epscript.epsimp"
    },
    "epscompile": {
      "doc": "",
      "type": "module",
      "module": "eudplib.epscript"
    },
    "epsimp": {
      "doc": "",
      "type": "module",
      "module": "eudplib.epscript"
    },
    "cs": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.objpool"
    },
    "f_getcurpl": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_dwbreak": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_dwbreak2": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_dwepdread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_dwread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_epdread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "cp": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof.ptrmemio"
    },
    "dwm": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof.ptrmemio"
    },
    "brw": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof.ptrmemio"
    },
    "cpm": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof.ptrmemio"
    },
    "f_bread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_wread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "bm": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.stringf.rwcommon"
    },
    "cm": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof.mblockio"
    },
    "f_memcmp": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_repmovsd_epd": {
      "doc": "",
      "type": "EUDFullFuncN",
      "module": "eudplib.eudlib"
    },
    "f_cunitepdread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_cunitread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_epdcunitread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_epdspriteread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_spriteepdread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_spriteread_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "bwm": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof.ptrmemio"
    },
    "bwepdio": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof"
    },
    "byterw": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof"
    },
    "cpbyterw": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof"
    },
    "cpmemio": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof"
    },
    "dwepdio": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof"
    },
    "mblockio": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof"
    },
    "memifgen": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof"
    },
    "modcurpl": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof"
    },
    "ptrmemio": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof"
    },
    "varrayreader": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.memiof"
    },
    "EUDDeque": {
      "doc": "",
      "type": "_lru_cache_wrapper",
      "module": "eudplib.eudlib"
    },
    "EUDQueue": {
      "doc": "",
      "type": "_lru_cache_wrapper",
      "module": "eudplib.eudlib"
    },
    "locf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "f_atan2": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_atan2_256": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_lengthdir": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_lengthdir_256": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_getgametick": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "runtrigtrg": {
      "doc": "",
      "type": "module",
      "module": "eudplib.trigtrg"
    },
    "trigtrg": {
      "doc": "",
      "type": "module",
      "module": "eudplib.trigtrg"
    },
    "AllocTrigTriggerLink": {
      "doc": "",
      "type": "_lru_cache_wrapper",
      "module": "eudplib.trigtrg.runtrigtrg"
    },
    "RunTrigTrigger": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.trigtrg.runtrigtrg"
    },
    "player": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.trigtrg.runtrigtrg"
    },
    "ProxyTypes": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "weakref"
    },
    "KW_ONLY": {
      "doc": "",
      "type": "_KW_ONLY_TYPE",
      "module": "dataclasses"
    },
    "MISSING": {
      "doc": "",
      "type": "_MISSING_TYPE",
      "module": "dataclasses"
    },
    "copy": {
      "doc": "Generic (shallow and deep) copying operations.",
      "type": "module",
      "module": "dataclasses"
    },
    "keyword": {
      "doc": "Keywords (from \"Grammar/python.gram\")",
      "type": "module",
      "module": "dataclasses"
    },
    "int_or_var": {
      "doc": "Represent a PEP 604 union type",
      "type": "UnionType",
      "module": "eudplib.offsetmap.csprite"
    },
    "dws_top": {
      "doc": "",
      "type": "EUDVariable",
      "module": "eudplib.eudlib.utilf.mempatch"
    },
    "dwstack": {
      "doc": "",
      "type": "EUDArray",
      "module": "eudplib.eudlib.utilf.mempatch"
    },
    "f_blockpatch_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_dwpatch_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_unpatchall": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "patchMax": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.eudlib.utilf.mempatch"
    },
    "patchstack": {
      "doc": "",
      "type": "EUDArray",
      "module": "eudplib.eudlib.utilf.mempatch"
    },
    "ps_top": {
      "doc": "",
      "type": "EUDVariable",
      "module": "eudplib.eudlib.utilf.mempatch"
    },
    "f_playerexist": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_dwrand": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_rand": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_randomize": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "binsearch": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf"
    },
    "gametick": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf"
    },
    "listloop": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf"
    },
    "logic": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf"
    },
    "mempatch": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf"
    },
    "pexist": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf"
    },
    "unlimiterflag": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf"
    },
    "userpl": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.utilf"
    },
    "f_sqrt": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "atan2": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.mathf"
    },
    "lengthdir": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.mathf"
    },
    "pow": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.mathf"
    },
    "sqrt": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.mathf"
    },
    "QueueGameCommand": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "QueueGameCommand_MergeArchon": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "QueueGameCommand_MergeDarkArchon": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "QueueGameCommand_MinimapPing": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "QueueGameCommand_PauseGame": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "QueueGameCommand_QueuedRightClick": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "QueueGameCommand_RestartGame": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "QueueGameCommand_ResumeGame": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "QueueGameCommand_RightClick": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "QueueGameCommand_Select": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "QueueGameCommand_TrainUnit": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "QueueGameCommand_UseCheat": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "bw": {
      "doc": "",
      "type": "EUDByteWriter",
      "module": "eudplib.eudlib.qgcf.qgc"
    },
    "qgc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "br1": {
      "doc": "",
      "type": "EUDByteReader",
      "module": "eudplib.eudlib.stringf.texteffect"
    },
    "br2": {
      "doc": "",
      "type": "EUDByteReader",
      "module": "eudplib.eudlib.stringf.strfunc"
    },
    "bs1": {
      "doc": "",
      "type": "EUDByteStream",
      "module": "eudplib.eudlib.stringf.strfunc"
    },
    "bw1": {
      "doc": "",
      "type": "EUDByteWriter",
      "module": "eudplib.eudlib.stringf.strfunc"
    },
    "GetMapStringAddr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_dbstr_adddw": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_dbstr_addptr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_dbstr_addstr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_dbstr_addstr_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "GetTBLAddr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "cw": {
      "doc": "",
      "type": "CPByteWriter",
      "module": "eudplib.eudlib.stringf.texteffect"
    },
    "f_cpstr_adddw": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_cpstr_addptr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_cpstr_addstr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib.stringf.cpprint"
    },
    "f_cpstr_addstr_epd": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib.stringf.cpprint"
    },
    "f_getnextchatdst": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib.stringf.cpprint"
    },
    "f_gettextptr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_raise_CCMU": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "prevcp": {
      "doc": "",
      "type": "EUDVariable",
      "module": "eudplib.eudlib.stringf.cpprint"
    },
    "cp949_table": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "f_cp949_to_utf8_cpy": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "error": {
      "doc": "",
      "type": "module",
      "module": "urllib"
    },
    "parse": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "request": {
      "doc": "",
      "type": "module",
      "module": "urllib"
    },
    "response": {
      "doc": "",
      "type": "module",
      "module": "urllib"
    },
    "MAX_CACHE_SIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "urllib.parse"
    },
    "non_hierarchical": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "urllib.parse"
    },
    "scheme_chars": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "urllib.parse"
    },
    "uses_fragment": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "urllib.parse"
    },
    "uses_netloc": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "urllib.parse"
    },
    "uses_params": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "urllib.parse"
    },
    "uses_query": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "urllib.parse"
    },
    "uses_relative": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "urllib.parse"
    },
    "base64mime": {
      "doc": "Base64 content transfer encoding per RFCs 2045-2047.",
      "type": "module",
      "module": "email"
    },
    "charset": {
      "doc": "",
      "type": "module",
      "module": "email"
    },
    "encoders": {
      "doc": "Encodings and related functions.",
      "type": "module",
      "module": "email"
    },
    "errors": {
      "doc": "email package exception classes.",
      "type": "module",
      "module": "email.message"
    },
    "feedparser": {
      "doc": "FeedParser - An email feed parser.",
      "type": "module",
      "module": "email"
    },
    "header": {
      "doc": "Header encoding and decoding functionality.",
      "type": "module",
      "module": "email._policybase"
    },
    "iterators": {
      "doc": "Various types of useful iterators and generators.",
      "type": "module",
      "module": "email"
    },
    "message": {
      "doc": "Basic message object for the email package object model.",
      "type": "module",
      "module": "email"
    },
    "parser": {
      "doc": "A parser of RFC 2822 and MIME email messages.",
      "type": "module",
      "module": "email"
    },
    "quoprimime": {
      "doc": "Quoted-printable content transfer encoding per RFCs 2045-2047.",
      "type": "module",
      "module": "email"
    },
    "utils": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "CRLF": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.utils"
    },
    "EMPTYSTRING": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.feedparser"
    },
    "MAXBINSIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "base64"
    },
    "MAXLINESIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "quopri"
    },
    "binascii": {
      "doc": "Conversion between binary data and ASCII",
      "type": "module",
      "module": "zipfile"
    },
    "MISC_LEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "email.base64mime"
    },
    "ESCAPE": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "json.encoder"
    },
    "HEX": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "quopri"
    },
    "ALIASES": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "email.charset"
    },
    "BASE64": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "email.charset"
    },
    "CHARSETS": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "email.charset"
    },
    "CODEC_MAP": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "email.charset"
    },
    "DEFAULT_CHARSET": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.charset"
    },
    "QP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "email.charset"
    },
    "RFC2047_CHROME_LEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "email.charset"
    },
    "SHORTEST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "email.charset"
    },
    "UNKNOWN8BIT": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.charset"
    },
    "email": {
      "doc": "A package for parsing, handling, and generating email messages.",
      "type": "module",
      "module": "urllib.request"
    },
    "BSPACE": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "email.header"
    },
    "FWS": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.header"
    },
    "MAXLINELEN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "email.header"
    },
    "SPACE": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email._parseaddr"
    },
    "SPACE8": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.header"
    },
    "USASCII": {
      "doc": "Map character sets to their email properties.",
      "type": "Charset",
      "module": "email.header"
    },
    "UTF8": {
      "doc": "Map character sets to their email properties.",
      "type": "Charset",
      "module": "email.header"
    },
    "ecre": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.header"
    },
    "fcre": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.header"
    },
    "MAXYEAR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "datetime"
    },
    "MINYEAR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "datetime"
    },
    "datetime_CAPI": {
      "doc": "Capsule objects let you wrap a C \"void *\" pointer in a Python",
      "type": "PyCapsule",
      "module": "datetime"
    },
    "EPOCH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "FRIDAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "February": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "January": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "MONDAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "SATURDAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "SUNDAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "THURSDAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "TUESDAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "WEDNESDAY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "calendar"
    },
    "calendar": {
      "doc": "Calendar printing functions",
      "type": "module",
      "module": "email._parseaddr"
    },
    "datetime": {
      "doc": "Fast implementation of the datetime type.",
      "type": "module",
      "module": "email.utils"
    },
    "day_abbr": {
      "doc": "",
      "type": "_localized_day",
      "module": "calendar"
    },
    "day_name": {
      "doc": "",
      "type": "_localized_day",
      "module": "calendar"
    },
    "firstweekday": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "mdays": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "calendar"
    },
    "month": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "month_abbr": {
      "doc": "",
      "type": "_localized_month",
      "module": "calendar"
    },
    "month_name": {
      "doc": "",
      "type": "_localized_month",
      "module": "calendar"
    },
    "monthcalendar": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "prcal": {
      "doc": "Print a year's calendar.",
      "type": "method",
      "module": "calendar"
    },
    "prmonth": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "prweek": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "week": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "weekheader": {
      "doc": "",
      "type": "method",
      "module": "calendar"
    },
    "COMMASPACE": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.utils"
    },
    "TICK": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.utils"
    },
    "UEMPTYSTRING": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.utils"
    },
    "escapesre": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.utils"
    },
    "rfc2231_continuation": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.utils"
    },
    "specialsre": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.utils"
    },
    "urllib": {
      "doc": "",
      "type": "module",
      "module": "urllib.error"
    },
    "compat32": {
      "doc": "Controls for how messages are interpreted and formatted.",
      "type": "Compat32",
      "module": "email.message"
    },
    "NLCRE": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.feedparser"
    },
    "NLCRE_bol": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.feedparser"
    },
    "NLCRE_crack": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.feedparser"
    },
    "NLCRE_eol": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.feedparser"
    },
    "NeedMoreData": {
      "doc": "The base class of the class hierarchy.",
      "type": "object",
      "module": "email.feedparser"
    },
    "headerRE": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.feedparser"
    },
    "base64": {
      "doc": "Base16, Base32, Base64 (RFC 3548), Base85 and Ascii85 data encodings",
      "type": "module",
      "module": "urllib.request"
    },
    "SEMISPACE": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "email.message"
    },
    "quopri": {
      "doc": "Conversions to/from quoted-printable transport encoding as per RFC 1521.",
      "type": "module",
      "module": "email.message"
    },
    "tspecials": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "email.message"
    },
    "uu": {
      "doc": "Implementation of the UUencode and UUdecode functions.",
      "type": "module",
      "module": "email.message"
    },
    "codepoint2name": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "html.entities"
    },
    "entitydefs": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "html.entities"
    },
    "html5": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "html.entities"
    },
    "name2codepoint": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "html.entities"
    },
    "entities": {
      "doc": "HTML character entity references.",
      "type": "module",
      "module": "html"
    },
    "posixpath": {
      "doc": "Common operations on Posix pathnames.",
      "type": "module",
      "module": "urllib.request"
    },
    "CHECK_CRC32": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "CHECK_CRC64": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "CHECK_ID_MAX": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "CHECK_NONE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "CHECK_SHA256": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "CHECK_UNKNOWN": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_ARM": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_ARMTHUMB": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_DELTA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_IA64": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_LZMA1": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_LZMA2": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_POWERPC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_SPARC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FILTER_X86": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FORMAT_ALONE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FORMAT_AUTO": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FORMAT_RAW": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "FORMAT_XZ": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "MF_BT2": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "MF_BT3": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "MF_BT4": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "MF_HC3": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "MF_HC4": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "MODE_FAST": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "MODE_NORMAL": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "PRESET_DEFAULT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "PRESET_EXTREME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "lzma"
    },
    "COPY_BUFSIZE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "shutil"
    },
    "fnmatch": {
      "doc": "Filename matching with shell patterns.",
      "type": "module",
      "module": "pathlib"
    },
    "nt": {
      "doc": "This module provides access to operating system functionality that is",
      "type": "module",
      "module": "shutil"
    },
    "posix": {
      "doc": "",
      "type": "NoneType",
      "module": "shutil"
    },
    "tempdir": {
      "doc": "",
      "type": "NoneType",
      "module": "tempfile"
    },
    "template": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "tempfile"
    },
    "html": {
      "doc": "",
      "type": "module",
      "module": "cgi"
    },
    "logfile": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "cgi"
    },
    "logfp": {
      "doc": "",
      "type": "NoneType",
      "module": "cgi"
    },
    "maxlen": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "cgi"
    },
    "tempfile": {
      "doc": "Temporary files.",
      "type": "module",
      "module": "urllib.request"
    },
    "cgi": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.stringf.fmtprint"
    },
    "string": {
      "doc": "A collection of string constants.",
      "type": "module",
      "module": "urllib.request"
    },
    "f_strcmp": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_strcpy": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "f_strnstr": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "PLVarMask": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.eudlib.stringf.pname"
    },
    "PLVarUnit": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.eudlib.stringf.pname"
    },
    "f_check_id": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib.stringf.pname"
    },
    "applyInjector": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector"
    },
    "injFinalizer": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector"
    },
    "mainloop": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector"
    },
    "payloadInit": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector"
    },
    "payloadReloc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector"
    },
    "vectorReloc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector"
    },
    "sf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector.mainloop"
    },
    "sharedTriggers": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.maprw.inlinecode.btInliner"
    },
    "tt": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector.vectorReloc"
    },
    "btInliner": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.inlinecode"
    },
    "ilccompile": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.inlinecode"
    },
    "ilcprocesstrig": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.inlinecode"
    },
    "rtt": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw.injector.injFinalizer"
    },
    "trglist": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.maprw.injector.vectorReloc"
    },
    "skip_payload_relocator": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "eudplib.maprw.injector.applyInjector"
    },
    "hasAlreadyStarted": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.maprw.injector.mainloop"
    },
    "jumper": {
      "doc": "",
      "type": "NoneType",
      "module": "eudplib.maprw.injector.mainloop"
    },
    "startFunctionList1": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.maprw.injector.mainloop"
    },
    "startFunctionList2": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.maprw.injector.mainloop"
    },
    "MPQ_COMP_ZLIB": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "MPQ_FILE_COMPRESS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "MPQ_FILE_ENCRYPTED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "MPQ_FILE_FIX_KEY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "MPQ_FILE_REPLACEEXISTING": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "libstorm": {
      "doc": "This class represents a dll exporting functions using the",
      "type": "WinDLL",
      "module": "eudplib.core.mapdata.mpqapi"
    },
    "ctypes": {
      "doc": "create and manipulate C data types in Python",
      "type": "module",
      "module": "colorama.win32"
    },
    "injector": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw"
    },
    "inlinecode": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw"
    },
    "loadmap": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw"
    },
    "mpqadd": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw"
    },
    "savemap": {
      "doc": "",
      "type": "module",
      "module": "eudplib.maprw"
    },
    "color_code": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "eudplib.eudlib.stringf.texteffect"
    },
    "color_codes": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "eudplib.eudlib.stringf.texteffect"
    },
    "color_v": {
      "doc": "",
      "type": "EUDVariable",
      "module": "eudplib.eudlib.stringf.texteffect"
    },
    "f_cpchar_adddw": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "id_codes": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "eudplib.eudlib.stringf.texteffect"
    },
    "id_gen": {
      "doc": "Return elements from the iterable until it is exhausted. Then repeat the sequence indefinitely.",
      "type": "cycle",
      "module": "eudplib.eudlib.stringf.texteffect"
    },
    "DisplayTextAt": {
      "doc": "",
      "type": "EUDFullFuncN",
      "module": "eudplib.eudlib"
    },
    "DisplayTextAllAt": {
      "doc": "",
      "type": "EUDFullFuncN",
      "module": "eudplib.eudlib"
    },
    "cpprint": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "cpstr": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "cputf8": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "dbstr": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "eudprint": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "fmtprint": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "pname": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "rwcommon": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "strall": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "strbuffer": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "strfunc": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "tblprint": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "texteffect": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "GrpWire32": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "eudplib.eudlib.wireframe.wiredata"
    },
    "GrpWire64": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "eudplib.eudlib.wireframe.wiredata"
    },
    "TranWire32": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "eudplib.eudlib.wireframe.wiredata"
    },
    "TranWire64": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "eudplib.eudlib.wireframe.wiredata"
    },
    "Wirefram32": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "eudplib.eudlib.wireframe.wiredata"
    },
    "Wirefram64": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "eudplib.eudlib.wireframe.wiredata"
    },
    "SetGrpWire": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "SetTranWire": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "SetWirefram": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "SetWireframes": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "eudplib.eudlib"
    },
    "grpwire": {
      "doc": "",
      "type": "EUDVariable",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "grpwire_default32": {
      "doc": "",
      "type": "EUDArray",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "grpwire_default64": {
      "doc": "",
      "type": "EUDArray",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "is64bit": {
      "doc": "",
      "type": "EUDLightBool",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "tranwire": {
      "doc": "",
      "type": "EUDVariable",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "tranwire_default32": {
      "doc": "",
      "type": "EUDArray",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "tranwire_default64": {
      "doc": "",
      "type": "EUDArray",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "wd": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "wirefram": {
      "doc": "",
      "type": "EUDVariable",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "wirefram_default32": {
      "doc": "",
      "type": "EUDArray",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "wirefram_default64": {
      "doc": "",
      "type": "EUDArray",
      "module": "eudplib.eudlib.wireframe.wireframe"
    },
    "wiredata": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "wireframe": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "eudarray": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "eudgrp": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "eudqueue": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "eudstack": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "mathf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "memiof": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "objpool": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "playerv": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "qgcf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "s": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "stringf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "unitgroup": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "utilf": {
      "doc": "",
      "type": "module",
      "module": "eudplib.eudlib"
    },
    "codec": {
      "doc": "",
      "type": "MultibyteCodec",
      "module": "encodings.cp949"
    },
    "mbc": {
      "doc": "",
      "type": "module",
      "module": "encodings.cp949"
    },
    "ntpath": {
      "doc": "Common pathname manipulations, WindowsNT/95 version.",
      "type": "module",
      "module": "pathlib"
    },
    "BZIP2_VERSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "DEFAULT_VERSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "LZMA_VERSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "MAX_EXTRACT_VERSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP64_LIMIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP64_VERSION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP_BZIP2": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP_DEFLATED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP_FILECOUNT_LIMIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP_LZMA": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP_MAX_COMMENT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "ZIP_STORED": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "bz2": {
      "doc": "Interface to the libbzip2 compression library.",
      "type": "module",
      "module": "zipfile"
    },
    "compressor_names": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "zipfile"
    },
    "lzma": {
      "doc": "Interface to the liblzma compression library.",
      "type": "module",
      "module": "zipfile"
    },
    "pathlib": {
      "doc": "",
      "type": "module",
      "module": "zipfile"
    },
    "shutil": {
      "doc": "Utility functions for copying and archiving files and directory trees.",
      "type": "module",
      "module": "zipfile"
    },
    "sizeCentralDir": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "sizeEndCentDir": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "sizeEndCentDir64": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "sizeEndCentDir64Locator": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "sizeFileHeader": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "zipfile"
    },
    "stringCentralDir": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipfile"
    },
    "stringEndArchive": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipfile"
    },
    "stringEndArchive64": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipfile"
    },
    "stringEndArchive64Locator": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipfile"
    },
    "stringFileHeader": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipfile"
    },
    "structCentralDir": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zipfile"
    },
    "structEndArchive": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "zipfile"
    },
    "structEndArchive64": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zipfile"
    },
    "structEndArchive64Locator": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zipfile"
    },
    "structFileHeader": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "zipfile"
    },
    "zlib": {
      "doc": "The functions in this module allow compression and decompression using the",
      "type": "module",
      "module": "zipfile"
    },
    "algorithms_available": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "hashlib"
    },
    "algorithms_guaranteed": {
      "doc": "set() -> new empty set object",
      "type": "set",
      "module": "hashlib"
    },
    "client": {
      "doc": "HTTP/1.1 client library",
      "type": "module",
      "module": "http"
    },
    "ALERT_DESCRIPTION_ACCESS_DENIED": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_BAD_CERTIFICATE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_BAD_CERTIFICATE_HASH_VALUE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_BAD_CERTIFICATE_STATUS_RESPONSE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_BAD_RECORD_MAC": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_CERTIFICATE_EXPIRED": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_CERTIFICATE_REVOKED": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_CERTIFICATE_UNKNOWN": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_CERTIFICATE_UNOBTAINABLE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_CLOSE_NOTIFY": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_DECODE_ERROR": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_DECOMPRESSION_FAILURE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_DECRYPT_ERROR": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_HANDSHAKE_FAILURE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_ILLEGAL_PARAMETER": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_INSUFFICIENT_SECURITY": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_INTERNAL_ERROR": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_NO_RENEGOTIATION": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_PROTOCOL_VERSION": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_RECORD_OVERFLOW": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_UNEXPECTED_MESSAGE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_UNKNOWN_CA": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_UNKNOWN_PSK_IDENTITY": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_UNRECOGNIZED_NAME": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_UNSUPPORTED_CERTIFICATE": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_UNSUPPORTED_EXTENSION": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "ALERT_DESCRIPTION_USER_CANCELLED": {
      "doc": "An enumeration.",
      "type": "AlertDescription",
      "module": "ssl"
    },
    "CERT_NONE": {
      "doc": "An enumeration.",
      "type": "VerifyMode",
      "module": "ssl"
    },
    "CERT_OPTIONAL": {
      "doc": "An enumeration.",
      "type": "VerifyMode",
      "module": "ssl"
    },
    "CERT_REQUIRED": {
      "doc": "An enumeration.",
      "type": "VerifyMode",
      "module": "ssl"
    },
    "CHANNEL_BINDING_TYPES": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "ssl"
    },
    "HAS_ALPN": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_ECDH": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_NEVER_CHECK_COMMON_NAME": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_NPN": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_SNI": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_SSLv2": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_SSLv3": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_TLSv1": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_TLSv1_1": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_TLSv1_2": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "HAS_TLSv1_3": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "ssl"
    },
    "OPENSSL_VERSION": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "ssl"
    },
    "OPENSSL_VERSION_INFO": {
      "doc": "Built-in immutable sequence.",
      "type": "tuple",
      "module": "ssl"
    },
    "OPENSSL_VERSION_NUMBER": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ssl"
    },
    "OP_ALL": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_CIPHER_SERVER_PREFERENCE": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_ENABLE_MIDDLEBOX_COMPAT": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_COMPRESSION": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_RENEGOTIATION": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_SSLv2": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_SSLv3": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_TICKET": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_TLSv1": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_TLSv1_1": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_TLSv1_2": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_NO_TLSv1_3": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_SINGLE_DH_USE": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "OP_SINGLE_ECDH_USE": {
      "doc": "An enumeration.",
      "type": "Options",
      "module": "ssl"
    },
    "PEM_FOOTER": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "ssl"
    },
    "PEM_HEADER": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "ssl"
    },
    "PROTOCOL_SSLv23": {
      "doc": "An enumeration.",
      "type": "_SSLMethod",
      "module": "ssl"
    },
    "PROTOCOL_TLS": {
      "doc": "An enumeration.",
      "type": "_SSLMethod",
      "module": "ssl"
    },
    "PROTOCOL_TLS_CLIENT": {
      "doc": "An enumeration.",
      "type": "_SSLMethod",
      "module": "ssl"
    },
    "PROTOCOL_TLS_SERVER": {
      "doc": "An enumeration.",
      "type": "_SSLMethod",
      "module": "ssl"
    },
    "PROTOCOL_TLSv1": {
      "doc": "An enumeration.",
      "type": "_SSLMethod",
      "module": "ssl"
    },
    "PROTOCOL_TLSv1_1": {
      "doc": "An enumeration.",
      "type": "_SSLMethod",
      "module": "ssl"
    },
    "PROTOCOL_TLSv1_2": {
      "doc": "An enumeration.",
      "type": "_SSLMethod",
      "module": "ssl"
    },
    "SSL_ERROR_EOF": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_INVALID_ERROR_CODE": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_SSL": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_SYSCALL": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_WANT_CONNECT": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_WANT_READ": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_WANT_WRITE": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_WANT_X509_LOOKUP": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "SSL_ERROR_ZERO_RETURN": {
      "doc": "An enumeration.",
      "type": "SSLErrorNumber",
      "module": "ssl"
    },
    "VERIFY_ALLOW_PROXY_CERTS": {
      "doc": "An enumeration.",
      "type": "VerifyFlags",
      "module": "ssl"
    },
    "VERIFY_CRL_CHECK_CHAIN": {
      "doc": "An enumeration.",
      "type": "VerifyFlags",
      "module": "ssl"
    },
    "VERIFY_CRL_CHECK_LEAF": {
      "doc": "An enumeration.",
      "type": "VerifyFlags",
      "module": "ssl"
    },
    "VERIFY_DEFAULT": {
      "doc": "An enumeration.",
      "type": "VerifyFlags",
      "module": "ssl"
    },
    "VERIFY_X509_PARTIAL_CHAIN": {
      "doc": "An enumeration.",
      "type": "VerifyFlags",
      "module": "ssl"
    },
    "VERIFY_X509_STRICT": {
      "doc": "An enumeration.",
      "type": "VerifyFlags",
      "module": "ssl"
    },
    "VERIFY_X509_TRUSTED_FIRST": {
      "doc": "An enumeration.",
      "type": "VerifyFlags",
      "module": "ssl"
    },
    "ACCEPTED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "ALREADY_REPORTED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "BAD_GATEWAY": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "BAD_REQUEST": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "CONFLICT": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "CONTINUE": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "CREATED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "EARLY_HINTS": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "EXPECTATION_FAILED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "FAILED_DEPENDENCY": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "FORBIDDEN": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "FOUND": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "GATEWAY_TIMEOUT": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "GONE": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "HTTPS_PORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "http.client"
    },
    "HTTP_PORT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "http.client"
    },
    "HTTP_VERSION_NOT_SUPPORTED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "IM_A_TEAPOT": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "IM_USED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "INSUFFICIENT_STORAGE": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "INTERNAL_SERVER_ERROR": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "LENGTH_REQUIRED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "LOCKED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "LOOP_DETECTED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "METHOD_NOT_ALLOWED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "MISDIRECTED_REQUEST": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "MOVED_PERMANENTLY": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "MULTIPLE_CHOICES": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "MULTI_STATUS": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NETWORK_AUTHENTICATION_REQUIRED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NON_AUTHORITATIVE_INFORMATION": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NOT_ACCEPTABLE": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NOT_EXTENDED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NOT_FOUND": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NOT_IMPLEMENTED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NOT_MODIFIED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "NO_CONTENT": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "OK": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "PARTIAL_CONTENT": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "PAYMENT_REQUIRED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "PERMANENT_REDIRECT": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "PRECONDITION_FAILED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "PRECONDITION_REQUIRED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "PROCESSING": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "PROXY_AUTHENTICATION_REQUIRED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "REQUESTED_RANGE_NOT_SATISFIABLE": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "REQUEST_ENTITY_TOO_LARGE": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "REQUEST_HEADER_FIELDS_TOO_LARGE": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "REQUEST_TIMEOUT": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "REQUEST_URI_TOO_LONG": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "RESET_CONTENT": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "SEE_OTHER": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "SERVICE_UNAVAILABLE": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "SWITCHING_PROTOCOLS": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "TEMPORARY_REDIRECT": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "TOO_EARLY": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "TOO_MANY_REQUESTS": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "UNAUTHORIZED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "UNAVAILABLE_FOR_LEGAL_REASONS": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "UNPROCESSABLE_ENTITY": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "UNSUPPORTED_MEDIA_TYPE": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "UPGRADE_REQUIRED": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "USE_PROXY": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "VARIANT_ALSO_NEGOTIATES": {
      "doc": "HTTP status codes and reason phrases",
      "type": "HTTPStatus",
      "module": "http.client"
    },
    "http": {
      "doc": "",
      "type": "module",
      "module": "urllib.request"
    },
    "responses": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "http.client"
    },
    "ssl": {
      "doc": "This module provides some more Pythonic support for SSL.",
      "type": "module",
      "module": "urllib.request"
    },
    "MAXFTPCACHE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "urllib.request"
    },
    "bisect": {
      "doc": "Bisection algorithms.",
      "type": "module",
      "module": "urllib.request"
    },
    "ftpcache": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "urllib.request"
    },
    "hashlib": {
      "doc": "hashlib module - A common interface to many hash functions.",
      "type": "module",
      "module": "urllib.request"
    },
    "MB_ICONASTERISK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "MB_ICONEXCLAMATION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "MB_ICONHAND": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "applyeuddraft"
    },
    "MB_ICONQUESTION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "MB_OK": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "applyeuddraft"
    },
    "SND_ALIAS": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_APPLICATION": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_ASYNC": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_FILENAME": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_LOOP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_MEMORY": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_NODEFAULT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_NOSTOP": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_NOWAIT": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "SND_PURGE": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "winsound"
    },
    "MAX_PATH": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "ctypes.wintypes"
    },
    "GetAsyncKeyState": {
      "doc": "",
      "type": "WinFunctionType",
      "module": "msgbox"
    },
    "GetConsoleWindow": {
      "doc": "",
      "type": "WinFunctionType",
      "module": "msgbox"
    },
    "GetForegroundWindow": {
      "doc": "",
      "type": "WinFunctionType",
      "module": "msgbox"
    },
    "SetForegroundWindow": {
      "doc": "",
      "type": "WinFunctionType",
      "module": "msgbox"
    },
    "isWindows": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "msgbox"
    },
    "RELEASE_URL": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "autoupdate"
    },
    "VERSION_URL": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "autoupdate"
    },
    "atexit": {
      "doc": "allow programmer to define multiple exit functions to be executed",
      "type": "module",
      "module": "multiprocessing.util"
    },
    "msgbox": {
      "doc": "",
      "type": "module",
      "module": "applyeuddraft"
    },
    "zipfile": {
      "doc": "",
      "type": "module",
      "module": "autoupdate"
    },
    "basepath": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "applyeuddraft"
    },
    "freeze_enabled": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "pluginLoader"
    },
    "prompt_enabled": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "pluginLoader"
    },
    "scbankSettings": {
      "doc": "",
      "type": "NoneType",
      "module": "pluginLoader"
    },
    "scbank_enabled": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "pluginLoader"
    },
    "BEL": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "colorama.ansitowin32"
    },
    "Back": {
      "doc": "",
      "type": "AnsiBack",
      "module": "readconfig"
    },
    "CSI": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "colorama.ansi"
    },
    "Cursor": {
      "doc": "",
      "type": "AnsiCursor",
      "module": "colorama"
    },
    "Fore": {
      "doc": "",
      "type": "AnsiFore",
      "module": "readconfig"
    },
    "OSC": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "colorama.ansi"
    },
    "Style": {
      "doc": "",
      "type": "AnsiStyle",
      "module": "colorama"
    },
    "ENABLE_VIRTUAL_TERMINAL_PROCESSING": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "colorama.win32"
    },
    "STDERR": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "colorama.win32"
    },
    "win32": {
      "doc": "",
      "type": "module",
      "module": "colorama"
    },
    "winterm": {
      "doc": "",
      "type": "module",
      "module": "colorama"
    },
    "atexit_done": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "colorama.initialise"
    },
    "fixed_windows_console": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "colorama.initialise"
    },
    "orig_stderr": {
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "type": "TextIOWrapper",
      "module": "colorama.initialise"
    },
    "orig_stdout": {
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "type": "TextIOWrapper",
      "module": "colorama.initialise"
    },
    "wrapped_stderr": {
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "type": "TextIOWrapper",
      "module": "colorama.initialise"
    },
    "wrapped_stdout": {
      "doc": "Character and line based layer over a BufferedIOBase object, buffer.",
      "type": "TextIOWrapper",
      "module": "colorama.initialise"
    },
    "ansi": {
      "doc": "",
      "type": "module",
      "module": "colorama"
    },
    "ansitowin32": {
      "doc": "",
      "type": "module",
      "module": "colorama"
    },
    "initialise": {
      "doc": "",
      "type": "module",
      "module": "colorama"
    },
    "textwrap": {
      "doc": "Text wrapping and filling.",
      "type": "module",
      "module": "readconfig"
    },
    "DEFAULT_LOGGING_FORMAT": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "multiprocessing.util"
    },
    "LOGGER_NAME": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "multiprocessing.util"
    },
    "MAXFD": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "multiprocessing.util"
    },
    "NOTSET": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "multiprocessing.util"
    },
    "abstract_sockets_supported": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "multiprocessing.util"
    },
    "weakref": {
      "doc": "Weak reference support for Python.",
      "type": "module",
      "module": "eudplib.eudlib.objpool"
    },
    "WINEXE": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "multiprocessing.spawn"
    },
    "WINSERVICE": {
      "doc": "bool(x) -> bool",
      "type": "bool",
      "module": "multiprocessing.spawn"
    },
    "old_main_modules": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "multiprocessing.spawn"
    },
    "runpy": {
      "doc": "runpy.py - locating and running Python code using the module namespace",
      "type": "module",
      "module": "multiprocessing.spawn"
    },
    "autoupdate": {
      "doc": "",
      "type": "module",
      "module": "euddraft"
    },
    "ep": {
      "doc": "",
      "type": "module",
      "module": "applyeuddraft"
    },
    "mp": {
      "doc": "",
      "type": "module",
      "module": "euddraft"
    },
    "default_ptex": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "freeze.pdefault"
    },
    "default_pupx": {
      "doc": "bytes(iterable_of_ints) -> bytes",
      "type": "bytes",
      "module": "freeze.pdefault"
    },
    "mix": {
      "doc": "",
      "type": "EUDTypedFuncN",
      "module": "freeze.crypt"
    },
    "unTDict": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "freeze.crypt"
    },
    "ctrlstru": {
      "doc": "",
      "type": "module",
      "module": "freeze.obfpatch"
    },
    "patchList": {
      "doc": "Built-in mutable sequence.",
      "type": "list",
      "module": "freeze.obfpatch"
    },
    "trigger": {
      "doc": "",
      "type": "module",
      "module": "freeze.obfpatch"
    },
    "crypt": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "freeze": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "keycalc": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "mpqh": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "obfjump": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "pdefault": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "trigcrypt": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "trigutils": {
      "doc": "",
      "type": "module",
      "module": "freeze"
    },
    "edPath": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "applyeuddraft"
    },
    "epPath": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "applyeuddraft"
    },
    "freezeMpq": {
      "doc": "",
      "type": "module",
      "module": "applyeuddraft"
    },
    "globalPluginPath": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "applyeuddraft"
    },
    "scbank_core": {
      "doc": "",
      "type": "module",
      "module": "applyeuddraft"
    },
    "globalPool": {
      "doc": "_GlobalObjPool(pool: eudplib.eudlib.objpool.ObjPool | None, max_fieldn: int = 8, max_object_num: int = 32768)",
      "type": "_GlobalObjPool",
      "module": "eudplib.eudlib.objpool"
    },
    "json": {
      "doc": "",
      "type": "module",
      "module": "main"
    },
    "pkgutil": {
      "doc": "Utilities to support packages.",
      "type": "module",
      "module": "main"
    },
    "settings": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "main"
    },
    "NUMBER_RE": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "json.scanner"
    },
    "BACKSLASH": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "json.decoder"
    },
    "NaN": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "json.decoder"
    },
    "NegInf": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "json.decoder"
    },
    "PosInf": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "json.decoder"
    },
    "STRINGCHUNK": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "json.decoder"
    },
    "WHITESPACE_STR": {
      "doc": "str(object='') -> str",
      "type": "str",
      "module": "json.decoder"
    },
    "scanner": {
      "doc": "",
      "type": "module",
      "module": "json"
    },
    "ESCAPE_ASCII": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "json.encoder"
    },
    "ESCAPE_DCT": {
      "doc": "dict() -> new empty dictionary",
      "type": "dict",
      "module": "json.encoder"
    },
    "HAS_UTF8": {
      "doc": "Compiled regular expression object.",
      "type": "Pattern",
      "module": "json.encoder"
    },
    "INFINITY": {
      "doc": "Convert a string or number to a floating point number, if possible.",
      "type": "float",
      "module": "json.encoder"
    },
    "i": {
      "doc": "int([x]) -> integer",
      "type": "int",
      "module": "json.encoder"
    },
    "decoder": {
      "doc": "",
      "type": "module",
      "module": "json"
    },
    "encoder": {
      "doc": "",
      "type": "module",
      "module": "json"
    },
    "zipimport": {
      "doc": "zipimport provides support for importing Python modules from Zip archives.",
      "type": "module",
      "module": "pkgutil"
    }
  }
}